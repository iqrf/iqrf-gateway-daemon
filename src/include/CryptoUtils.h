#pragma once

#include <openssl/evp.h>
#include <openssl/rand.h>
#include <openssl/sha.h>
#include <nlohmann/json.hpp>

#include <algorithm>
#include <cstdint>
#include <stdexcept>
#include <vector>

#define ENCODED_SECRET_LEN 44

using json = nlohmann::json;

class CryptoUtils {
public:

  /**
    * @brief Generate random bytes of specified length
    * @param len Length of data to generate
    * @return Vector of randomly generated bytes
    */
  static std::vector<unsigned char> random_data(std::size_t len) {
    std::vector<unsigned char> buffer(len);
    if (RAND_bytes(buffer.data(), static_cast<int>(len)) != 1) {
      throw std::runtime_error("Failed to generate random bytes.");
    }
    return buffer;
  }

  /**
   * @brief Compute SHA-256 hash from salt and key
   * @param salt Salt to hash
   * @param key Secret to hash
   * @return Vector of bytes representing hashed salt and secret
   */
  static std::vector<unsigned char> sha256_hash_data(const std::vector<unsigned char>& salt, const std::vector<unsigned char>& key) {
    std::vector<unsigned char> hash(EVP_MAX_MD_SIZE);
    EVP_MD_CTX* ctx = EVP_MD_CTX_new();
    unsigned int digest_len = 0;
    if (!ctx) {
      throw std::runtime_error("Failed to create hashing context.");
    }

    if (EVP_DigestInit_ex(ctx, EVP_sha256(), NULL) != 1) {
      EVP_MD_CTX_free(ctx);
      throw std::runtime_error("Failed to initialize digest.");
    }

    if (EVP_DigestUpdate(ctx, salt.data(), salt.size()) != 1) {
      EVP_MD_CTX_free(ctx);
      throw std::runtime_error("Failed to update digest with salt.");
    }

    if (EVP_DigestUpdate(ctx, key.data(), key.size()) != 1) {
      EVP_MD_CTX_free(ctx);
      throw std::runtime_error("Failed to update digest with key.");
    }

    if (EVP_DigestFinal_ex(ctx, hash.data(), &digest_len) != 1) {
      EVP_MD_CTX_free(ctx);
      throw std::runtime_error("Failed to finalize digest.");
    }

    EVP_MD_CTX_free(ctx);
    hash.resize(digest_len);
    return hash;
  }

  /**
   * @brief Encode bytes to base64 string
   * @param data Vector of bytes to encode
   * @return Base64-encoded string
   */
  static std::string base64_encode_data(const std::vector<unsigned char>& data) {
    int encoded_len = 4 * ((data.size() + 2) / 3);
    std::vector<unsigned char> buffer(encoded_len + 16);
    EVP_ENCODE_CTX *ctx = EVP_ENCODE_CTX_new();
    if (!ctx) {
      throw std::runtime_error("Failed to create encoding context.");
    }
    int encode_len = 0, final_len = 0;

    EVP_EncodeInit(ctx);
    if (
      EVP_EncodeUpdate(
        ctx,
        buffer.data(),
        &encode_len,
        reinterpret_cast<const unsigned char *>(data.data()),
        static_cast<int>(data.size())) != 1
    ) {
      EVP_ENCODE_CTX_free(ctx);
      throw std::runtime_error("Failed to update encode with data.");
    }
    EVP_EncodeFinal(ctx, buffer.data() + encode_len, &final_len);
    encode_len += final_len;
    EVP_ENCODE_CTX_free(ctx);
    std::string result(reinterpret_cast<char *>(buffer.data()), encode_len);
    result.erase(std::remove(result.begin(), result.end(), '\n'), result.end());
    return result;
  }

  /**
   * @brief Decode base64 string into bytes
   * @param data Base64-encoded string
   * @return Vector of decoded bytes
   */
  static std::vector<unsigned char> base64_decode_data(const std::string& data) {
    std::vector<unsigned char> decoded(data.size());
    EVP_ENCODE_CTX *ctx = EVP_ENCODE_CTX_new();
    if (!ctx) {
      throw std::runtime_error("Failed to create decoding context.");
    }

    int out_len = 0, final_len = 0;
    EVP_DecodeInit(ctx);
    if (
      EVP_DecodeUpdate(
        ctx,
        decoded.data(),
        &out_len,
        reinterpret_cast<const unsigned char *>(data.data()),
        data.size()
      ) < 0
    ) {
      EVP_ENCODE_CTX_free(ctx);
      throw std::runtime_error("Failed to update decode with data.");
    }

    if (EVP_DecodeFinal(ctx, decoded.data() + out_len, &final_len) != 1) {
      EVP_ENCODE_CTX_free(ctx);
      throw std::runtime_error("Failed to finalize decoding.");
    }

    EVP_ENCODE_CTX_free(ctx);
    decoded.resize(out_len + final_len);
    return decoded;
  }

  /**
   * @brief Check if character is a valid base64 character
   * @param c Character to check
   * @return True if character is a valid base64 character, false otherwise
   */
  static bool is_base64_character(const char c) {
    return (std::isalnum(static_cast<unsigned char>(c)) || c == '+' || c == '/' || c == '=');
  }

  /**
   * @brief Parse token into ID and secret
   * @param token API token
   * @param id Token ID container
   * @param secret Secret container
   */
  static void parse_token(const std::string& token, uint32_t& id, std::string& secret) {
    const char delim = ';';
    size_t start = 0;
    size_t end = token.find(delim);

    std::vector<std::string> parts;

    while (end != std::string::npos) {
      parts.emplace_back(token.substr(start, end - start));
      start = end + 1;
      end = token.find(delim, start);
    }
    parts.emplace_back(token.substr(start));

    if (parts.size() != 3) {
      throw std::invalid_argument("Invalid API token format.");
    }

    if (parts[0] != "iqrfgd2") {
      throw std::invalid_argument("Unsupported API token type.");
    }

    if (!std::all_of(parts[1].begin(), parts[1].end(), ::isdigit)) {
      throw std::invalid_argument("API token ID part contains non-numeric characters.");
    }
    id = static_cast<uint32_t>(std::stoul(parts[1]));
    if (parts[2].length() != ENCODED_SECRET_LEN) {
      throw std::invalid_argument("Invalid API token secret length.");
    }
    if (!std::all_of(parts[2].begin(), parts[2].end(), is_base64_character)) {
      throw std::invalid_argument("API token secret contains invalid characters.");
    }
    secret = parts[2];
  }

  /**
   * @brief Construct shareable token, to be used for verification
   * @param id Token ID
   * @param key Base64-encoded key
   * @param json_output Output in JSON format
   * @return Token containing a prefix, ID and key
   */
  static std::string construct_shareable_token(uint32_t id, const std::string& key, bool json_output) {
    std::string token("iqrfgd2;" + std::to_string(id) + ';' + key);
    if (json_output) {
      json doc = {
        {"token", token}
      };
      return doc.dump();
    }
    return token;
  }
};
