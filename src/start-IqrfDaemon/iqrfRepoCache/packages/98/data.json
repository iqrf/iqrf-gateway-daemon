{"dpa": "0400", "driver": "//############################################################################################\r\n// File_:   $RCSfile: 0002_DDC-SE01.js,v $\r\n// Version: $Revision: 1.12 $\r\n// Date:    $Date: 2019/05/10 10:21:01 $\r\n//############################################################################################\r\n// Driver for 'DDC-SE01 sensor example'\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x0002,\r\n  'Type' : 'Handler',  \r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0x0001, 'Notes' : [\r\n        'Implemented iqrf.sensor.FinalizeSensor? functions.' ]\r\n    },\r\n    { 'Version' : 0x0000, 'Notes' : [\r\n        'Release Notes:',\r\n        '+ Initial release',\r\n        'Hello' ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n\r\n// Namespace: iqrf.sensor\r\nnamespace( 'iqrf.sensor' );\r\n\r\n// This product sensors list\r\niqrf.sensor.SensorsList =\r\n  [\r\n    iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE,  // 0\r\n    iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE,  // 1\r\n    iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7,  // 2 : FinalizeSensor Light\r\n    iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7   // 3 : FinalizeSensor Potentiometer\r\n  ];\r\n\r\n// Breakdown the Binary Data7 sensor values\r\niqrf.sensor.FinalizeSensor = function ( sensor, index, frcCommand, extendedFrcData )\r\n{\r\n  // Is it binary7 data type at the expected indexes, but not 2bit FRC (has no meaning to breakdown)?\r\n  if ( sensor.type === iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7 && ( index === 2 || index === 3 ) && frcCommand !== iqrf.sensor.STD_SENSOR_FRC_2BITS )\r\n  {\r\n    // Yes, breakdown the value ...\r\n    sensor.breakdown = [];\r\n    // ... to the one value\r\n    sensor.breakdown[0] =\r\n      {\r\n        // Keep quantity type\r\n        id: sensor.id,\r\n        type: sensor.type,\r\n        // Find out the names based on the index\r\n        name: index === 2 ? 'Light indicator'/* index 2 */ : 'Potentiometer'/* index 3 */,\r\n        shortName: index === 2 ? 'light' : 'pot',\r\n        // And the unit is...\r\n        unit: '%',\r\n        decimalPlaces: 1\r\n      };\r\n\r\n    if ( sensor.value !== undefined )\r\n        // Compute the value the same way for both binary data7 sensors, i.e. convert binary values 0-127 to 100.0-0.0 %\r\n      sensor.breakdown[0].value = isNaN( sensor.value ) ? NaN : iqrf.Round( ( 127 - sensor.value ) * 100.0 / 127, 1 );\r\n  }\r\n};\r\n\r\n//############################################################################################\r\n", "handlerHash": "A7EDA10634B8BB0C580A9316EC39B8678DCD8A161A3FA3DA5832D382224F7E17", "handlerUrl": "https://repository.iqrfalliance.org/download/handlers/0002_0001_DDC-SE01.hex", "hwpid": 2, "hwpidVer": 1, "notes": "Implemented iqrf.sensor.FinalizeSensor? functions.", "os": "08C8", "packageID": 98, "standards": [{"driver": "//############################################################################################\r\n\r\n/* Title: Global IQRF driver library routines\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n\r\nBecause of potential usage of JScript at *Microsoft.ClearScript.Windows.JScriptEngine* the following features cannot used:\r\n\r\n* 'let' instead of 'var' where appropriate\r\n* 'const'\r\n* default parameter values\r\n* binary literals\r\n* enums\r\n*/\r\n\r\n/*\r\nToDo\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : -1,\r\n  'Type' : 'Standard',  \r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release' ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n\r\n// JavaScript 'namespace' helper routine\r\nvar globalObject = this;\r\n\r\n/* Function: namespace\r\nDeclares a new namespace.\r\n\r\nParameters:\r\n  name - string: Namespace name. Use dots for multilevel namespace.\r\n*/\r\nvar namespace = function ( name )\r\n{\r\n  var tokens = name.split( '.' );\r\n  var object = globalObject;\r\n  while ( tokens.length > 0 )\r\n  {\r\n    var token = tokens.shift();\r\n    object = object[token] = object[token] || {};\r\n  }\r\n  return object;\r\n};\r\n\r\n//############################################################################################\r\n\r\n// Array.isArray is not defined at JScript\r\nif ( Array.isArray === undefined )\r\n{\r\n  Array.isArray = function ( obj ) \r\n  {\r\n    return obj.constructor === Array;\r\n  };\r\n}\r\n\r\n//############################################################################################\r\n// Namespace: iqrf\r\nnamespace( 'iqrf' );\r\n\r\n/* String: iqrf.PNUM_Coordinator\r\nCoordinator peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_Coordinator = '00';\r\n/* String: iqrf.PNUM_Node\r\nNode peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_Node = '01';\r\n/* String: iqrf.PNUM_OS\r\nOS peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_OS = '02';\r\n/* String: iqrf.PNUM_EEPROM\r\nEEPROM peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_EEPROM = '03';\r\n/* String: iqrf.PNUM_EEEPROM\r\nExternal EEPROM peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_EEEPROM = '04';\r\n/* String: iqrf.PNUM_RAM\r\nRAM peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_RAM = '05';\r\n/* String: iqrf.PNUM_LEDR\r\nRed LED peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_LEDR = '06';\r\n/* String: iqrf.PNUM_LEDG\r\nGreen LED peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_LEDG = '07';\r\n/* String: iqrf.PNUM_SPI\r\nSPI peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_SPI = '08';\r\n/* String: iqrf.PNUM_IO\r\nIO peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_IO = '09';\r\n/* String: iqrf.PNUM_Thermometer\r\nThermometer peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_Thermometer = '0A';\r\n/* String: iqrf.PNUM_PWM\r\nPWM peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_PWM = '0B';\r\n/* String: iqrf.PNUM_UART\r\nUART peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_UART = '0C';\r\n/* String: iqrf.PNUM_FRC\r\nFRC peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_FRC = '0D';\r\n/* String: iqrf.PNUM_Enumeration\r\nEnumeration peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_Enumeration = 'FF';\r\n\r\n// PCMD response flag\r\niqrf.PCMD_ResponseFlag = 0x80;\r\n\r\n/* Constructor: iqrf.DpaRawHdpMessage\r\nCreates a raw-hdp DPA message with specified PNUM and PCMD.\r\n\r\nParameters:\r\n  pnum - string: PNUM value.\r\n  pcmd - string: PCMD value.\r\n  rdata - string: [optional] PDATA value as a string of dot separated bytes.\r\n*/\r\n\r\niqrf.DpaRawHdpMessage = function ( pnum, pcmd, rdata )\r\n{\r\n  // 'Asserts'\r\n  iqrf.ParseStringByte( pnum );\r\n  iqrf.ParseStringByte( pcmd );\r\n\r\n  this.pnum = pnum;\r\n  this.pcmd = pcmd;\r\n\r\n  this.ctype = 'dpa';\r\n  this.type = 'raw-hdp';\r\n  this.hwpid = 'FfFf';\r\n\r\n  if ( rdata !== undefined )\r\n  {\r\n    if ( typeof rdata !== 'string' )\r\n      throw new Error( 'iqrf.DpaRawHdpMessage: Optional string parameter rdata is defined but type is ' + typeof rdata );\r\n\r\n    if ( rdata.length !== 0 )\r\n    {\r\n      // 'Assert'\r\n      iqrf.ParseStringBytes( rdata );\r\n\r\n      this.rdata = rdata;\r\n    }\r\n  }\r\n};\r\n\r\n/* Constructor: iqrf.DpaRawHdpMessageCoordinator\r\nSame as <iqrf.DpaRawHdpMessage> but it also sets nadr to '00'.\r\n*/\r\niqrf.DpaRawHdpMessageCoordinator = function ( pnum, pcmd, rdata )\r\n{\r\n  var result = new iqrf.DpaRawHdpMessage( pnum, pcmd, rdata );\r\n  result.nadr = '00';\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.stricmp\r\nCompares two string in case insensitive way (not using locale).\r\n\r\nParameters:\r\n  str1 - string: 1st string to compare.\r\n  str2 - string: 2nd string to compare.\r\n\r\nReturns:\r\n  boolean: true if strings are equal, otherwise false.\r\n*/\r\niqrf.stricmp = function ( str1, str2 )\r\n{\r\n  return str1.toUpperCase() === str2.toUpperCase();\r\n};\r\n\r\n/* Function: iqrf.indexOf\r\nReturns the index of the first occurrence of a value in an array.\r\nReason for the implementation is that some engines (JScript) does not support Array.indexOf().\r\n\r\nParameters:\r\n  arr - array: An array.\r\n  val - object: The value to locate in arr.\r\n  useStricmp - boolean: [optional] if true then iqrf.stricmp() is used for the object match. Default is false.\r\n\r\nReturns:\r\n  number: The index of the first occurrence of val in the arr, or -1 if val is not found.  \r\n*/\r\niqrf.indexOf = function ( arr, val, useStricmp )\r\n{\r\n  // Test if the indexOf() is supported (e.g. JScriptEngine does not, V8ScriptEngine does)\r\n  if ( arr.indexOf !== undefined && useStricmp !== true )\r\n    return arr.indexOf( val );\r\n\r\n  var arr_length = arr.length;\r\n  for ( var indexOfResult = 0; indexOfResult < arr_length; indexOfResult++ )\r\n    if ( useStricmp === true )\r\n    {\r\n      if ( iqrf.stricmp( arr[indexOfResult], val ) )\r\n        return indexOfResult;\r\n    }\r\n    else\r\n    {\r\n      if ( arr[indexOfResult] === val )\r\n        return indexOfResult;\r\n    }\r\n\r\n  return -1;\r\n};\r\n\r\n/* Function: iqrf.CheckResponsePnumPcmdDlen\r\nChecks DPA Response.\r\n\r\nParameters:\r\n  response - object: DPA Response message (raw-hdp format)\r\n  pnum - string: Required PNUM, e.g. '01'.\r\n  pcmd - string: Required PCMD(s), e.g. '03', '04.05'.\r\n  dlen - string: [optional] Required PDATA (rdata part) length. Negative number specifies a minimum length. When not used (undefined), then no check is performed.\r\n\r\nReturns:\r\n  array: Array of bytes containing rdata bytes from the original DPA Response message.  \r\n*/\r\niqrf.CheckResponsePnumPcmdDlen = function ( response, pnum, pcmd, dlen )\r\n{\r\n  if ( response.rcode !== '00' )\r\n    throw new Error( 'iqrf.CheckResponsePnumPcmdDlen: Field response.rcode is not \\'00\\' but \\'' + response.rcode + '\\', status=' + response.status );\r\n\r\n  if ( !iqrf.stricmp( response.pnum, pnum ) )\r\n    throw new Error( 'iqrf.CheckResponsePnumPcmdDlen: Invalid pnum=' + response.pnum + ', expected ' + pnum );\r\n\r\n  if ( -1 === iqrf.indexOf( pcmd.split( '.' ), response.pcmd, true ) )\r\n    throw new Error( 'iqrf.CheckResponsePnumPcmdDlen: Invalid pcmd=' + response.pcmd + ', expected ' + pcmd );\r\n\r\n  var result = iqrf.ParseRdata( response );\r\n  if ( dlen !== undefined )\r\n  {\r\n    if ( dlen >= 0 )\r\n    {\r\n      if ( result.length !== dlen )\r\n        throw new Error( 'iqrf.CheckResponsePnumPcmdDlen: Invalid response length=' + result.length + ', expected ' + dlen );\r\n    }\r\n    else\r\n      if ( result.length < -dlen )\r\n        throw new Error( 'iqrf.CheckResponsePnumPcmdDlen: Invalid response length=' + result.length + ', expected at least ' + -dlen );\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.ParseStringByte\r\nConverts hexadecimal byte from string into a number.\r\n\r\nParameters:\r\n  byte - string: string to convert.\r\n\r\nReturns:\r\n  number: Byte value of the string.  \r\n*/\r\niqrf.ParseStringByte = function ( byte )\r\n{\r\n  if ( typeof byte !== 'string' )\r\n    throw new Error( 'ParseStringByte: Parameter byte expected string but is ' + typeof byte );\r\n\r\n  if ( byte.length !== 2 )\r\n    throw new Error( 'ParseStringByte: Parameter byte expected 2 characters long but is ' + byte.length + ' characters long' );\r\n\r\n  var result = parseInt( byte, 16 );\r\n  if ( isNaN( result ) )\r\n    throw new Error( 'ParseStringByte: Parameter byte ' + byte + ' cannot be converted from hexadecimal' );\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.ParseStringBytes\r\nSplits dot separated bytes from string into array of bytes.\r\n\r\nParameters:\r\n  bytes - string: [optional] Input string with bytes.\r\n\r\nReturns:\r\n  array: Array of bytes containing bytes from the string. If parameter bytes is not used an ampty array is returned.\r\n*/\r\niqrf.ParseStringBytes = function ( bytes )\r\n{\r\n  var result = [];\r\n  if ( bytes !== undefined )\r\n  {\r\n    if ( typeof bytes !== 'string' )\r\n      throw new Error( 'iqrf.ParseStringBytes: Type of parameter bytes is not string, but ' + typeof bytes );\r\n\r\n    if ( bytes.length !== 0 )\r\n    {\r\n      var bytesSplit = bytes.split( '.' );\r\n      while ( bytesSplit.length > 0 )\r\n        result[result.length] = iqrf.ParseStringByte( bytesSplit.shift() );\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.ParseRdata\r\nSplits rdata from DPA message (raw-hdp format) into array of bytes.\r\n\r\nParameters:\r\n  response - object: DPA message (raw-hdp format).\r\n\r\nReturns:\r\n  array: Array of bytes containing rdata bytes from the original DPA message.  \r\n*/\r\niqrf.ParseRdata = function ( response )\r\n{\r\n  return iqrf.ParseStringBytes( response.rdata );\r\n};\r\n\r\n/* Function: iqrf.ToHexStringByte\r\nConverts byte value to the 2 character long hexadecimal string.\r\n\r\nParameters:\r\n  value - number: Input byte value.\r\n\r\nReturns:\r\n  string: 2 character long hexadecimal string.  \r\n*/\r\niqrf.ToHexStringByte = function ( value )\r\n{\r\n  if ( typeof value !== 'number' )\r\n    throw new Error( 'iqrf.ToHexStringByte: Parameter value is not number but ' + typeof value );\r\n\r\n  if ( value < 0 || value > 0xFF )\r\n    throw new Error( 'iqrf.ToHexStringByte: Parameter value ' + String( value ) + ' out of range' );\r\n\r\n  var result = value.toString( 16 );\r\n  if ( result.length !== 2 )\r\n    result = '0' + result;\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.IntToHexStringBytesArray\r\nConverts integer value to hexadecimal string of the specified length containing the bytes the little-endian value consists of.\r\n\r\nParameters:\r\n  value - number: Input integer value.\r\n  length - number: Number of bytes the integer consists of.\r\n\r\nReturns:\r\n  string: String list of the individual bytes.  \r\n*/\r\niqrf.IntToHexStringBytesArray = function ( value, length )\r\n{\r\n  if ( typeof value !== 'number' )\r\n    throw new Error( 'iqrf.IntToHexStringBytesArray: Parameter value is not number but ' + typeof value );\r\n\r\n  if ( typeof length !== 'number' || length < 1 )\r\n    throw new Error( 'iqrf.IntToHexStringBytesArray: Parameter length is invalid: ' + length );\r\n\r\n  var result = '';\r\n  do\r\n  {\r\n    if ( result.length !== 0 )\r\n      result += '.';\r\n    result += iqrf.ToHexStringByte( value & 0xFF );\r\n\r\n    value >>= 8;\r\n  }\r\n  while ( --length !== 0 );\r\n\r\n  // ToDo: Improve (e.g. 2197816638 >> 8 == -8191995)\r\n  if ( value !== 0 && value !== -1 )\r\n    throw new Error( 'iqrf.IntToHexStringBytesArray: Parameter value is out of range' );\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.BytesToHexStringBytesArray\r\nConverts array of bytes to the string representation (list of dot separated 2 character long byte values).\r\n\r\nParameters:\r\n  bytes - array: Array of bytes.\r\n  prefixDot - boolean: [optional] If true then the result is always prefixed by a dot character. Default is false.\r\n  startIndex - number: [optional] Staring index of the byte to convert from. Default is 0.\r\n  endIndex - number: [optional] Ending index of the byte to convert to. Default is bytes.length - 1.\r\n\r\nReturns:\r\n  string: String list of the individual bytes.  \r\n*/\r\niqrf.BytesToHexStringBytesArray = function ( bytes, prefixDot, startIndex, endIndex )\r\n{\r\n  var result = '';\r\n  if ( bytes !== undefined )\r\n  {\r\n    if ( !Array.isArray( bytes ) )\r\n      throw new Error( 'iqrf.BytesToHexStringBytesArray: Parameter bytes is not an array but ' + typeof bytes );\r\n\r\n    if ( startIndex === undefined )\r\n      startIndex = 0;\r\n\r\n    if ( endIndex === undefined )\r\n      endIndex = bytes.length - 1;\r\n\r\n    for ( var index = startIndex; index <= endIndex; index++ )\r\n    {\r\n      if ( result.length !== 0 || prefixDot === true )\r\n        result += '.';\r\n      result += iqrf.ToHexStringByte( bytes[index] );\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.BitmapToIndexes\r\nReturns an array of indexes of set bits in the bitmap.\r\n\r\nParameters:\r\n  bitmap - array: Array of bytes.\r\n  indexFrom - number: Starting index of the byte in the bitmap.\r\n  indexTo - number: Ending index of the byte in the bitmap.\r\n  offset - number: [optional] Value to start indexing from. Default value is 0.\r\n\r\nReturns:\r\n  array: Array of integers specifying the offset indexes of bits set in the bitmap.  \r\n*/\r\niqrf.BitmapToIndexes = function ( bitmap, indexFrom, indexTo, offset )\r\n{\r\n  if ( !Array.isArray( bitmap ) )\r\n    throw new Error( 'iqrf.BitmapToIndexes: Parameter bitmap is not an array but ' + typeof bitmap );\r\n\r\n  if ( offset === undefined )\r\n    offset = 0;\r\n\r\n  var result = [];\r\n  for ( var index = indexFrom; index <= indexTo; index++ )\r\n  {\r\n    var bitmapByte = bitmap[index];\r\n    if ( bitmapByte === 0 )\r\n      offset += 8;\r\n    else\r\n      for ( var bitMask = 0x01; bitMask !== 0x100; bitMask <<= 1 )\r\n      {\r\n        if ( ( bitmapByte & bitMask ) !== 0 )\r\n          result[result.length] = offset;\r\n        offset++;\r\n      }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.IndexesToBitmap\r\nReturns an array of bytes with the selected indexes.\r\n\r\nParameters:\r\n  indexes - array: array of integers each specifying the index of bit to set in the bitmap.\r\n  bitmapSize - number: Size of the bitmap in bytes.\r\n\r\nReturns:\r\n  array: Array of bytes with the bit set according to the indexes parameter.  \r\n*/\r\niqrf.IndexesToBitmap = function ( indexes, bitmapSize )\r\n{\r\n  if ( !Array.isArray( indexes ) )\r\n    throw new Error( 'iqrf.IndexesToBitmap: Parameter bitmap is not an array but ' + typeof indexes );\r\n\r\n  var bitmap = [];\r\n  for ( var index = 0; index < bitmapSize; index++ )\r\n    bitmap[index] = 0;\r\n\r\n  var indexes_length = indexes.length;\r\n  for ( index = 0; index < indexes_length; index++ )\r\n  {\r\n    var oneIndex = indexes[index];\r\n    var bitmapIndex = Math.floor( oneIndex / 8 );\r\n    if ( bitmapIndex >= bitmapSize )\r\n      throw new Error( 'iqrf.IndexesToBitmap: Index ' + oneIndex + ' out of bitmap size ' + bitmapSize );\r\n\r\n    bitmap[bitmapIndex] |= 1 << ( oneIndex % 8 );\r\n  }\r\n\r\n  return bitmap;\r\n};\r\n\r\n/* Function: iqrf.NormalizeStringByte\r\nConverts string byte into 2 character string for sure.\r\n\r\nParameters:\r\n  byte - string: string byte value to normalize.\r\n\r\nReturns:\r\n  string: 2 character long hexadecimal string.\r\n*/\r\niqrf.NormalizeStringByte = function ( byte )\r\n{\r\n  return iqrf.ToHexStringByte( iqrf.ParseStringByte( byte ) );\r\n};\r\n\r\n/* Function: iqrf.UInt16toInt16\r\nConverts one's complement signed value stored at unsigned word (2 bytes or 16 bits) into signed 16 bit value.\r\n\r\nParameters:\r\n  uint16 - number: Input unsigned 16 bit value containing 16 bit signed value.\r\n\r\nReturns:\r\n  number: Signed 16 bit value.\r\n*/\r\niqrf.UInt16toInt16 = function ( uint16 )\r\n{\r\n  if ( uint16 < 0 || uint16 > 0xFfFf )\r\n    throw new Error( 'iqrf.UInt16toInt16: Parameter uint16 = ' + uint16 + ' is out of range' );\r\n\r\n  return uint16 < 0x8000 ? uint16 : uint16 - 0x10000;\r\n};\r\n\r\n/* Function: iqrf.UInt8toInt8\r\nConverts one's complement signed value stored at unsigned word (1 byte or 8 bits) into signed 8 bit value.\r\n\r\nParameters:\r\n  uint8 - number: Input unsigned 8 bit value containing 8 bit signed value.\r\n\r\nReturns:\r\n  number: Signed 8 bit value.\r\n*/\r\niqrf.UInt8toInt8 = function ( uint8 )\r\n{\r\n  if ( uint8 < 0 || uint8 > 0xFf )\r\n    throw new Error( 'iqrf.UInt8toInt8: Parameter uint8 = ' + uint8 + ' is out of range' );\r\n\r\n  return uint8 < 0x80 ? uint8 : uint8 - 0x100;\r\n};\r\n\r\n/* Function: iqrf.Round\r\nRounds number to specified number of decimal places.\r\n\r\nParameters:\r\n  value - number: Input number to round.\r\n  decimals - number: Number of decimal places to round number to.\r\n\r\nReturns:\r\n  number: Rounded number.\r\n*/\r\niqrf.Round = function ( value, decimals )\r\n{\r\n  return Number( Math.round( value + 'e' + decimals ) + 'e-' + decimals );\r\n};\r\n\r\n//############################################################################################\r\n", "name": "Driver Library", "notes": "Initial release", "standardID": -1, "version": 0.0, "versionFlags": 0}, {"driver": "//############################################################################################\r\n\r\n/* Title: IQRF Standards Sensor driver\r\nSee also: <https://www.iqrfalliance.org/techDocs/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x5E,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 15, 'Notes' : [\r\n        '+ New quantities added (TimeSpan, Illuminance, NO2 (nitrogen dioxide), SO2 (sulfur dioxide), CO (carbon monoxide), O3 (ozone), Atmospheric Pressure, Color Temperature, TimeSpanLong, UV Index, Sound Pressure Level, Particulates PM2.5, Data Block, Altitude, Acceleration, pH, Ammonia, Methane ).',\r\n        '+ 4 bytes FRC added.',\r\n        '! Fixed negative numbers calculation for signed quantities.' ,\r\n        '! Fixed computation of Earth\u2019s Magnetic Field value.' ,\r\n        '+ Error sensor values detected and returned as NaN.',\r\n        '+ Sensor enumeration gives list of supported FRC commands.',\r\n        '+ iqrf.sensor.Frc* functions added.' ,\r\n        '+ Optional parameter writtenData at iqrf.sensor.ReadSensorsWithTypes_Request.' ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.sensor\r\nnamespace( 'iqrf.sensor' );\r\n\r\n// IQRF Standards Sensor PNUM value\r\niqrf.sensor.PNUM = '5e';\r\n\r\n// IQRF Sensor standard peripheral - sensor types\r\n// 2 bytes\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE\r\nTemperature sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE = 0x01;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_CO2\r\nCarbon dioxide sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_CO2 = 0x02;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_VOC\r\nVolatile organic compounds sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_VOC = 0x03;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE\r\nExtra-low voltage sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE = 0x04;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD\r\nEarth\u2019s magnetic field sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD = 0x05;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE\r\nLow voltage sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE = 0x06;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_CURRENT\r\nCurrent sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_CURRENT = 0x07;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_POWER\r\nPower sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_POWER = 0x08;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY\r\nMains frequency sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY = 0x09;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN\r\nTimespan value.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_TIMESPAN = 0x0A;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE\r\nIlluminance sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE = 0x0B;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_NO2\r\nNitrogen dioxide sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_NO2 = 0x0C;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_SO2\r\nSulfur dioxide sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_SO2 = 0x0D;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_CO\r\nCarbon monoxide sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_CO = 0x0E;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_O3\r\nOzone sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_O3 = 0x0F;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE\r\nAtmospheric pressure sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE = 0x10;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE\r\nColor temperature sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE = 0x11;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_PARTICULATES_PM25\r\nParticulates PM2.5 sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_PARTICULATES_PM25 = 0x12;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_SOUND_PRESSURE_LEVEL\r\nSound pressure level sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_SOUND_PRESSURE_LEVEL = 0x13;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_ALTITUDE\r\nAltitude sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_ALTITUDE = 0x14;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_ACCELERATION\r\nAcceleration sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_ACCELERATION = 0x15;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_NH3\r\nAmmonia sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_NH3 = 0x16;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_METHANE\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_METHANE = 0x17;\r\n\r\n//  1 byte\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY\r\nRelative humidity sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY = 0x80;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7\r\n7 bits binary data sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7 = 0x81;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR\r\nPower factor sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR = 0x82;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_UV_INDEX\r\nUV index sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_UV_INDEX = 0x83;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_PH\r\npH sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_PH = 0x84;\r\n\r\n//  4 bytes\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30\r\n30 bits binary data sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30 = 0xA0;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_CONSUMPTION\r\nConsumption sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_CONSUMPTION = 0xA1;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_DATETIME\r\nDate and time vallue.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_DATETIME = 0xA2;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN_LONG\r\nLong timespan value.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_TIMESPAN_LONG = 0xA3;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_LATITUDE\r\nLatitude value.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_LATITUDE = 0xA4;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_LONGITUDE\r\nLongitude value.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_LONGITUDE = 0xA5;\r\n\r\n//  Multiple bytes\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_DATA_BLOCK\r\nData block containing proprietary data.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_DATA_BLOCK = 0xC0;\r\n\r\n// FRC commands\r\n/* Const: iqrf.sensor.STD_SENSOR_FRC_2BITS\r\nFRC command to return 2-bits sensor data of the supporting sensor types.\r\n*/\r\niqrf.sensor.STD_SENSOR_FRC_2BITS = 0x10;\r\n/* Const: iqrf.sensor.STD_SENSOR_FRC_1BYTE\r\nFRC command to return 1-byte wide sensor data of the supporting sensor types. \r\n*/\r\niqrf.sensor.STD_SENSOR_FRC_1BYTE = 0x90;\r\n/* Const: iqrf.sensor.STD_SENSOR_FRC_2BYTES\r\nFRC command to return 2-bytes wide sensor data of the supporting sensor types.\r\n*/\r\niqrf.sensor.STD_SENSOR_FRC_2BYTES = 0xE0;\r\n/* Const: iqrf.sensor.STD_SENSOR_FRC_4BYTES\r\nFRC command to return 4-bytes wide sensor data of the supporting sensor types.\r\n*/\r\niqrf.sensor.STD_SENSOR_FRC_4BYTES = 0xF9;\r\n\r\n// Sensor types\r\niqrf.sensor.SensorTypes = [];\r\n// 2 bytes\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE] =\r\n  {\r\n    id: 'TEMPERATURE',\r\n    name: 'Temperature',\r\n    shortName: 'T',\r\n    unit: '\u00b0C',\r\n    decimalPlaces: 4,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE, iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_CO2] =\r\n  {\r\n    id: 'CO2',\r\n    name: 'Carbon dioxide',\r\n    shortName: 'CO2',\r\n    unit: 'ppm',\r\n    decimalPlaces: 0,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE, iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_VOC] =\r\n  {\r\n    id: 'VOC',\r\n    name: 'Volatile organic compound',\r\n    shortName: 'VOC',\r\n    unit: 'ppm',\r\n    decimalPlaces: 0,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE, iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE] =\r\n  {\r\n    id: 'EXTRA_LOW_VOLTAGE',\r\n    name: 'Extra-low voltage',\r\n    shortName: 'U',\r\n    unit: 'V',\r\n    decimalPlaces: 3,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD] =\r\n  {\r\n    id: 'EARTHS_MAGNETIC_FIELD',\r\n    name: 'Earth\u2019s magnetic field',\r\n    shortName: 'B',\r\n    unit: 'T',\r\n    decimalPlaces: 7,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE] =\r\n  {\r\n    id: 'LOW_VOLTAGE',\r\n    name: 'Low voltage',\r\n    shortName: 'U',\r\n    unit: 'V',\r\n    decimalPlaces: 4,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_CURRENT] =\r\n  {\r\n    id: 'CURRENT',\r\n    name: 'Current',\r\n    shortName: 'I',\r\n    unit: 'A',\r\n    decimalPlaces: 3,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_POWER] =\r\n  {\r\n    id: 'POWER',\r\n    name: 'Power',\r\n    shortName: 'E',\r\n    unit: 'W',\r\n    decimalPlaces: 2,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY] =\r\n  {\r\n    id: 'MAINS_FREQUENCY',\r\n    name: 'Mains frequency',\r\n    shortName: 'f',\r\n    unit: 'Hz',\r\n    decimalPlaces: 3,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN] =\r\n  {\r\n    id: 'TIMESPAN',\r\n    name: 'Timespan',\r\n    shortName: 't',\r\n    unit: 's',\r\n    decimalPlaces: 0,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE] =\r\n  {\r\n    id: 'ILLUMINANCE',\r\n    name: 'Illuminance',\r\n    shortName: 'Ev',\r\n    unit: 'lx',\r\n    decimalPlaces: 0,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_NO2] =\r\n  {\r\n    id: 'NO2',\r\n    name: 'Nitrogen dioxide',\r\n    shortName: 'NO2',\r\n    unit: 'ppm',\r\n    decimalPlaces: 3,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_SO2] =\r\n  {\r\n    id: 'SO2',\r\n    name: 'Sulfur dioxide',\r\n    shortName: 'SO2',\r\n    unit: 'ppm',\r\n    decimalPlaces: 3,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_CO] =\r\n  {\r\n    id: 'CO',\r\n    name: 'Carbon monoxide',\r\n    shortName: 'CO',\r\n    unit: 'ppm',\r\n    decimalPlaces: 2,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_O3] =\r\n  {\r\n    id: 'O3',\r\n    name: 'Ozone',\r\n    shortName: 'O3',\r\n    unit: 'ppm',\r\n    decimalPlaces: 4,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE] =\r\n  {\r\n    id: 'ATMOSPHERIC_PRESSURE',\r\n    name: 'Atmospheric pressure',\r\n    shortName: 'p',\r\n    unit: 'hPa',\r\n    decimalPlaces: 4,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE] =\r\n  {\r\n    id: 'COLOR_TEMPERATURE',\r\n    name: 'Color temperature',\r\n    shortName: 'Tc',\r\n    unit: 'K',\r\n    decimalPlaces: 0,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_PARTICULATES_PM25] =\r\n  {\r\n    id: 'PARTICULATES_PM25',\r\n    name: 'Particulates PM2.5',\r\n    shortName: 'PM2.5',\r\n    unit: '\u00b5g/m3',\r\n    decimalPlaces: 2,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_SOUND_PRESSURE_LEVEL] =\r\n  {\r\n    id: 'SOUND_PRESSURE_LEVEL',\r\n    name: 'Sound pressure level',\r\n    shortName: 'Lp',\r\n    unit: 'dB',\r\n    decimalPlaces: 4,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_ALTITUDE] =\r\n  {\r\n    id: 'ALTITUDE',\r\n    name: 'Altitude',\r\n    shortName: 'h',\r\n    unit: 'm',\r\n    decimalPlaces: 2,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_ACCELERATION] =\r\n  {\r\n    id: 'ACCELERATION',\r\n    name: 'Acceleration',\r\n    shortName: 'a',\r\n    unit: 'm/s2',\r\n    decimalPlaces: 8,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_NH3] =\r\n  {\r\n\tid: 'NH3',\r\n    name: 'Ammonia',\r\n    shortName: 'NH3',\r\n    unit: 'ppm',\r\n    decimalPlaces: 1,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_METHANE] =\r\n  {\r\n    id: 'METHANE',\r\n    name: 'Methane',\r\n    shortName: 'CH4',\r\n    unit: '%',\r\n    decimalPlaces: 3,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\n\r\n// 1 byte\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY] =\r\n  {\r\n    id: 'RELATIVE_HUMIDITY',\r\n    name: 'Relative humidity',\r\n    shortName: 'RH',\r\n    unit: '%',\r\n    decimalPlaces: 1,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7] =\r\n  {\r\n    id: 'BINARYDATA7',\r\n    name: 'Binary data7',\r\n    shortName: 'bin7',\r\n    unit: '?',\r\n    decimalPlaces: 0,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BITS, iqrf.sensor.STD_SENSOR_FRC_1BYTE]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR] =\r\n  {\r\n    id: 'POWER_FACTOR',\r\n    name: 'Power factor',\r\n    shortName: 'cos ?',\r\n    unit: '',\r\n    decimalPlaces: 3,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_UV_INDEX] =\r\n  {\r\n    id: 'UV_INDEX',\r\n    name: 'UV index',\r\n    shortName: 'UV',\r\n    unit: '',\r\n    decimalPlaces: 3,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_PH] =\r\n  {\r\n    id: 'PH',\r\n    name: 'pH',\r\n    shortName: 'pH',\r\n    unit: '',\r\n    decimalPlaces: 4,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE]\r\n  };\r\n\r\n// 4 bytes\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30] =\r\n  {\r\n    id: 'BINARYDATA30',\r\n    name: 'Binary data30',\r\n    shortName: 'bin30',\r\n    unit: '?',\r\n    decimalPlaces: 0,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES, iqrf.sensor.STD_SENSOR_FRC_4BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_CONSUMPTION] =\r\n  {\r\n    id: 'CONSUMPTION',\r\n    name: 'Consumption',\r\n    shortName: 'E',\r\n    unit: 'Wh',\r\n    decimalPlaces: 0,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_4BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_DATETIME] =\r\n  {\r\n    id: 'DATETIME',\r\n    name: 'DateTime',\r\n    shortName: 'DateTime',\r\n    unit: '',\r\n    decimalPlaces: 0,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_4BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN_LONG] =\r\n  {\r\n    id: 'TIMESPAN_LONG',\r\n    name: 'Timespan long',\r\n    shortName: 't',\r\n    unit: 's',\r\n    decimalPlaces: 4,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_4BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_LATITUDE] =\r\n  {\r\n    id: 'LATITUDE',\r\n    name: 'Latitude',\r\n    shortName: 'LAT',\r\n    unit: '\u00b0',\r\n    decimalPlaces: 7,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_4BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_LONGITUDE] =\r\n  {\r\n    id: 'LONGITUDE',\r\n    name: 'Longitude',\r\n    shortName: 'LONG',\r\n    unit: '\u00b0',\r\n    decimalPlaces: 7,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_4BYTES]\r\n  };\r\n\r\n// Multiple bytes\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_DATA_BLOCK] =\r\n  {\r\n    id: 'DATA_BLOCK',\r\n    name: 'Data block',\r\n    shortName: 'datablock',\r\n    unit: '?',\r\n    decimalPlaces: 0,\r\n    frcs: []\r\n  };\r\n\r\n/* Function: iqrf.sensor.Enumerate_Request\r\nEncodes DPA request to enumerate sensors.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.sensor.Enumerate_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.sensor.PNUM, '3e' );\r\n};\r\n\r\n/* Function: iqrf.sensor.Enumerate_Response\r\nDecodes DPA response from sensor enumeration.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  array: Array of objects describing each sensor. The object has the following fields:\r\n\r\n* id - string: Value type as \"identifier\" text.\r\n* type - number: Value type of the sensor (quantity). See IQRF Sensor standard for details.\r\n* name - string: Name of the sensor (quantity).\r\n* shortName - string: Short name of the sensor (quantity). Typically it is a symbol used at physics.\r\n* unit - string: Unit of the quantity. Dimensionless quantity has empty string \"\".\r\n* decimalPlaces - number: Number of valid decimal places.\r\n* frcs - array: Array of FRC commands supported by the sensor.\r\n* breakdown - array: [optional] see <iqrf.sensor.ReadSensorsWithTypes_Response> for more information.\r\n*/\r\niqrf.sensor.Enumerate_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.sensor.PNUM, 'be', -1 );\r\n\r\n  var result = [];\r\n  for ( var index in responseData )\r\n  {\r\n    var sensorType = responseData[index];\r\n    var sensorObj = iqrf.sensor.SensorTypes[sensorType];\r\n    if ( sensorObj === undefined )\r\n      throw new Error( 'iqrf.sensor.Enumerate_Response: Unknown sensor type ' + sensorType );\r\n\r\n    var sensorOut =\r\n    {\r\n      id: sensorObj.id,\r\n      type: sensorType,\r\n      name: sensorObj.name,\r\n      shortName: sensorObj.shortName,\r\n      unit: sensorObj.unit,\r\n      decimalPlaces: sensorObj.decimalPlaces,\r\n      frcs: sensorObj.frcs\r\n    };\r\n\r\n    var sensorOutIndex = result.length;\r\n    result[sensorOutIndex] = sensorOut;\r\n\r\n    if ( iqrf.sensor.FinalizeSensor !== undefined )\r\n      iqrf.sensor.FinalizeSensor( sensorOut, sensorOutIndex );\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\niqrf.sensor.Indexes2bitmap = function ( sensorIndexes )\r\n{\r\n  var bitmap = 0;\r\n  for ( var index in sensorIndexes )\r\n    bitmap |= 1 << sensorIndexes[index];\r\n\r\n  return iqrf.IntToHexStringBytesArray( bitmap, 4 );\r\n};\r\n\r\n/* Function: iqrf.sensor.ReadSensorsWithTypes_Request\r\nEncodes DPA request to read sensors values.\r\n\r\nParameters:\r\n  sensorIndexes - Specifies sensors to read data from:\r\n\r\n* undefined: Missing parameter: reads 1st sensor.\r\n* number: -1: reads all sensors.\r\n* array: array of indexes: specifies sensors to read.\r\n  \r\n  writtenData - array: [optional] array of 5-bytes-arrays (for each sensor). See IQRF Sensor standards for details.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.sensor.ReadSensorsWithTypes_Request = function ( sensorIndexes, writtenData )\r\n{\r\n  var result = new iqrf.DpaRawHdpMessage( iqrf.sensor.PNUM, '01' );\r\n  if ( sensorIndexes !== undefined )\r\n  {\r\n    if ( sensorIndexes === -1 )\r\n      result.rdata = 'ff.ff.ff.ff';\r\n    else\r\n      result.rdata = iqrf.sensor.Indexes2bitmap( sensorIndexes );\r\n  }\r\n\r\n  if ( writtenData !== undefined )\r\n  {\r\n    var writtenData_length = writtenData.length;\r\n    for ( var index = 0; index < writtenData_length; index++ )\r\n    {\r\n      var oneData = writtenData[index];\r\n      if ( oneData.length !== 5 )\r\n        throw new Error( 'iqrf.sensor.ReadSensorsWithTypes_Request: Written data item length is not 5 but ' + oneData.length );\r\n\r\n      result.rdata += iqrf.BytesToHexStringBytesArray( oneData, true );\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.sensor.ReadSensorsWithTypes_Response\r\nDecodes DPA response from sensor value reading.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n  request - string: [optional] request used to generate specified \"response\" parameter. It is a return value from <iqrf.sensor.ReadSensorsWithTypes_Request>. Although this parameter is optional it is needed for breakdown of the \"anonymous\" sensor types \"Binary Data7\", \"Binary Data30\" and \"Data Block\" by the product specific driver. Please see <iqrf.sensor.FinalizeSensor> for more information.\r\n\r\nReturns:\r\n  array: Array of objects for every read sensor. The object has the following fields:\r\n\r\n* id - string: Value type as \"identifier\" text.\r\n* type - number: Value type of the sensor (quantity). See IQRF Sensor standard for details.\r\n* name - string: Name of the sensor (quantity).\r\n* shortName - string: Short name of the sensor (quantity). Typically it is a symbol used at physics.\r\n* value - number: Value of the sensor. It equals to NaN to indicate an error value.\r\n* unit - string: Unit of the quantity. Dimensionless quantity has empty string \"\".\r\n* decimalPlaces - number: Number of valid decimal places.\r\n* breakdown - array: [optional] See <iqrf.sensor.FinalizeSensor> for more information.\r\n\r\nExample:\r\n--- Text\r\n[\r\n  {\r\n    \"id\" : \"TEMPERATURE\",\r\n    \"type\": 1,\r\n    \"name\": \"Temperature\",\r\n    \"shortName\": \"T\",\r\n    \"value\": 22.3,\r\n    \"unit\": \"\u00b0C\",\r\n    \"decimalPlaces\": 4\r\n  },\r\n  {\r\n    \"id\" : \"RELATIVE_HUMIDITY\",\r\n    \"type\": 128,\r\n    \"name\": \"Relative humidity\",\r\n    \"shortName\": \"RH\",\r\n    \"value\": 35,\r\n    \"unit\": \"%\",\r\n    \"decimalPlaces\": 1\r\n  },\r\n  {\r\n    \"id\" : \"MAINS_FREQUENCY\",\r\n    \"type\": 9,\r\n    \"name\": \"Mains frequency\",\r\n    \"shortName\": \"f\",\r\n    \"value\": 49.98,\r\n    \"unit\": \"Hz\", 3,\r\n    \"decimalPlaces\": 4\r\n  },\r\n  {\r\n    \"id\" : \"BINARYDATA7\",\r\n    \"type\": 129,\r\n    \"name\": \"Binary data7\",\r\n    \"shortName\": \"bin7\",\r\n    \"value\": 88,\r\n    \"unit\": \"?\",\r\n    \"decimalPlaces\": 0,\r\n    \"breakdown\":\r\n    [\r\n      {\r\n        \"id\" : \"BINARYDATA7\",\r\n        \"type\": 129,\r\n        \"name\": \"Potentiometer\",\r\n        \"shortName\": \"pot\",\r\n        \"value\": 30.7,\r\n        \"unit\": \"%\",\r\n        \"decimalPlaces\": 1\r\n      }\r\n    ]\r\n  }\r\n]\r\n---\r\n*/\r\niqrf.sensor.ReadSensorsWithTypes_Response = function ( response, request )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.sensor.PNUM, '81' );\r\n\r\n  if ( request !== undefined )\r\n  {\r\n    var requestData = iqrf.ParseStringBytes( request.rdata );\r\n    var RequestedIndexes = iqrf.BitmapToIndexes( requestData, 0, 3 );\r\n    // If no sensor was requested, then actually the 1st was requested\r\n    if ( RequestedIndexes.length === 0 )\r\n      RequestedIndexes[0] = 0;\r\n  }\r\n\r\n  var result = [];\r\n  var responseData_length = responseData.length;\r\n  for ( var index = 0; index < responseData_length; )\r\n  {\r\n    var sensorType = responseData[index++];\r\n    var sensorObj = iqrf.sensor.SensorTypes[sensorType];\r\n    if ( sensorObj === undefined )\r\n      throw new Error( 'iqrf.sensor.ReadSensorsWithTypes_Response: Unknown sensor type ' + sensorType );\r\n\r\n    var sensorValue;\r\n\r\n    switch ( sensorType )\r\n    {\r\n      default:\r\n        throw new Error( 'iqrf.sensor.ReadSensorsWithTypes_Response: Unimplemented sensor type value ' + sensorType );\r\n\r\n      // 2 bytes\r\n      // ----------------\r\n      case iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : iqrf.UInt16toInt16( sensorValue ) / 16.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 16.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_CO2:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_VOC:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        if ( sensorValue === 0x8000 )\r\n          sensorValue = NaN;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        if ( sensorValue === 0xFfFf )\r\n          sensorValue = NaN;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_CURRENT:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : iqrf.UInt16toInt16( sensorValue ) / 1000.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_NO2:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_SO2:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_METHANE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 1000.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : iqrf.UInt16toInt16( sensorValue ) / 10000000.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_POWER:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 4.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_CO:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 100.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_O3:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 10000.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_PARTICULATES_PM25:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : sensorValue / 4.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_SOUND_PRESSURE_LEVEL:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : sensorValue / 16.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_ALTITUDE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 4.0 - 1024.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_ACCELERATION:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : iqrf.UInt16toInt16( sensorValue ) / 256.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_NH3:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 10.0;\r\n        break;\r\n\r\n      // 1 byte\r\n      // ----------------\r\n      case iqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY:\r\n        sensorValue = responseData[index] === 0xEE ? NaN : ( responseData[index] / 2.0 );\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7:\r\n        sensorValue = ( responseData[index] & 0x80 ) !== 0 ? NaN : responseData[index];\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR:\r\n        sensorValue = responseData[index] === 0xEE ? NaN : responseData[index] / 200.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_UV_INDEX:\r\n        sensorValue = responseData[index] === 0xFF ? NaN : responseData[index] / 8.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_PH:\r\n        sensorValue = responseData[index] === 0xFF ? NaN : responseData[index] / 16.0;\r\n        break;\r\n\r\n      // 4 bytes\r\n      // ----------------\r\n      case iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30:\r\n        sensorValue = ( responseData[index + 3] & 0x80 ) !== 0 ? NaN : ( responseData[index] + ( responseData[index + 1] * 0x100 ) + ( responseData[index + 2] * 0x10000 ) + ( responseData[index + 3] * 0x1000000 ) );\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_CONSUMPTION:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 ) + ( responseData[index + 2] * 0x10000 ) + ( responseData[index + 3] * 0x1000000 );\r\n        if ( sensorValue === 0xFfFfFfFf )\r\n          sensorValue = NaN;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_DATETIME:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 ) + ( responseData[index + 2] * 0x10000 ) + ( responseData[index + 3] * 0x1000000 );\r\n        if ( sensorValue === 0xFfFfFfFf )\r\n          sensorValue = NaN;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN_LONG:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 ) + ( responseData[index + 2] * 0x10000 ) + ( responseData[index + 3] * 0x1000000 );\r\n        sensorValue = sensorValue === 0xFfFfFfFf ? NaN : sensorValue / 16.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_LATITUDE:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_LONGITUDE:\r\n        if ( responseData[index + 3] === 0xFF || ( responseData[index + 2] & 0x40 ) === 0x00 )\r\n          sensorValue = NaN;\r\n        else\r\n        {\r\n          sensorValue = responseData[index + 3] + ( ( responseData[index + 2] & 0x3F ) + ( responseData[index] + ( responseData[index + 1] * 0x100 ) ) / 10000 ) / 60;\r\n          if ( ( responseData[index + 2] & 0x80 ) !== 0x00 )\r\n            sensorValue = -sensorValue;\r\n        }\r\n        break;\r\n\r\n      // Multiple bytes\r\n      // ----------------\r\n      case iqrf.sensor.STD_SENSOR_TYPE_DATA_BLOCK:\r\n        {\r\n          sensorValue = [];\r\n          var length = responseData[index];\r\n          for ( var dataIndex = 1; dataIndex <= length; dataIndex++ )\r\n            sensorValue[sensorValue.length] = responseData[index + dataIndex];\r\n          break;\r\n        }\r\n    }\r\n\r\n    var oneSensor =\r\n    {\r\n      id: sensorObj.id,\r\n      type: sensorType,\r\n      name: sensorObj.name,\r\n      shortName: sensorObj.shortName,\r\n      value: sensorValue,\r\n      unit: sensorObj.unit,\r\n      decimalPlaces: sensorObj.decimalPlaces\r\n    };\r\n\r\n    if ( iqrf.sensor.FinalizeSensor !== undefined )\r\n      iqrf.sensor.FinalizeSensor( oneSensor, RequestedIndexes !== undefined ? RequestedIndexes[result.length] : undefined );\r\n\r\n    result[result.length] = oneSensor;\r\n\r\n    var sensorDataLength;\r\n    if ( ( sensorType & 0x80 ) === 0 )\r\n      sensorDataLength = 2;\r\n    else if ( ( sensorType & 0xE0 ) === 0x80 )\r\n      sensorDataLength = 1;\r\n    else if ( ( sensorType & 0xE0 ) === 0xA0 )\r\n      sensorDataLength = 4;\r\n    else\r\n      sensorDataLength = responseData[index] + 1;\r\n\r\n    index += sensorDataLength;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.sensor.Frc_Request\r\nPrepares FRC request to read standard sensor values.\r\n_Requires FRC embedded peripheral driver_.\r\n\r\nParameters:\r\n  sensorType - number: Type of sensor (quantity) to read values of. Use iqrf.sensor.STD_SENSOR_TYPE_* constant. Use 0 to specify the sensor only by sensorIndex parameter.\r\n  sensorIndex - number: Index of the sensor. If the sensor type is specified, then it is an index among of all sensors of the specified type. If sensorType is 0 then it is overall sensor index. Some FRC commands might use top 3 bits of this parameter for passing additional data.\r\n  frcCommand - number: One of predefined standard sensor FRC commands. See iqrf.sensor.STD_SENSOR_FRC_* constants.\r\n  selectedNodes - array: [optional] Array if integer values corresponding to the selected nodes. Use default value or empty array to select all nodes and use sleepAfterFrc parameter.\r\n  sleepAfterFrc - object: [optional] Object with the following fields to put the nodes into sleep mode after the FRC is finished:\r\n      * time - number: See DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n      * control - number: See DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n\r\nReturns: \r\n  array: 2 items long array. 1st item is a prepared request to initiate the RFC. 2nd item is a prepared request to get additional FRC data from the network. For smaller networks extra FRC result might not be needed.\r\n*/\r\niqrf.sensor.Frc_Request = function ( sensorType, sensorIndex, frcCommand, selectedNodes, sleepAfterFrc )\r\n{\r\n  var userData = [0x5E, sensorType, sensorIndex];\r\n  if ( sleepAfterFrc === undefined )\r\n    userData[userData.length] = 0x00;\r\n  else\r\n    userData.push( 0x01, sleepAfterFrc.time & 0xFF, sleepAfterFrc.time >> 8, sleepAfterFrc.control );\r\n\r\n  var result = [];\r\n  result[0] = selectedNodes === undefined || selectedNodes.length === 0 ? iqrf.embed.frc.Send_Request( frcCommand, userData ) : iqrf.embed.frc.SendSelective_Request( frcCommand, selectedNodes, userData );\r\n  result[1] = iqrf.embed.frc.ExtraResult_Request();\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.sensor.Frc_Response\r\nParses FRC response into sensor values. See <iqrf.sensor.Frc_Request> for more details.\r\n_Requires FRC embedded peripheral driver_.\r\n\r\nParameters:\r\n  sensorType - number: Type of sensor (quantity) to read values of. The type must be alway specified even when 0 was passed as sensorType parameter at iqrf.sensor.Frc_Request. If an optional parameter frcSendRequest, then the sensorType parameter is internally assigned from frcSendRequest so it does not have to be specified at all.\r\n  frcCommand - number: One of predefined standard sensor FRC commands. Use the same value that was passed to iqrf.sensor.Frc_Request. If an optional parameter frcSendRequest, then the frcCommand parameter is internally assigned from frcSendRequest so it does not have to be specified at all.\r\n  responseFrcSend - object: Response for the 1st request from iqrf.sensor.Frc_Request.\r\n  responseFrcExtraResult - object: [optional] Response for the 2nd request from iqrf.sensor.Frc_Request.\r\n  frcSendRequest - string: [optional] FrcSend request that was used to generate specified responseFrcSend. It is a return value[0] from <iqrf.sensor.Frc_Request>. Although this parameter is optional, it is needed for breakdown of the \"anonymous\" sensor types \"Binary Data7\", \"Binary Data30\" and \"Data Block\" by the product specific driver. Please see iqrf.sensor.FinalizeSensor for more information.\r\n\r\nReturns:\r\n  array: Array of objects for every read sensor. Object array index represent the node address (or index in case selectedNodes parameter was used). The object has the same fields as object at the return  value of <iqrf.sensor.ReadSensorsWithTypes_Response>.\r\n*/\r\niqrf.sensor.Frc_Response = function ( sensorType, frcCommand, responseFrcSend, responseFrcExtraResult, frcSendRequest )\r\n{\r\n  var responseFrcExtraResultParsed;\r\n  if ( responseFrcExtraResult !== undefined )\r\n    responseFrcExtraResultParsed = iqrf.embed.frc.ExtraResult_Response( responseFrcExtraResult );\r\n  var parsedFrc = iqrf.embed.frc.ParseResponses( frcCommand, iqrf.embed.frc.Send_Response( responseFrcSend ), responseFrcExtraResultParsed );\r\n\r\n  if ( frcSendRequest !== undefined )\r\n  {\r\n    var requestData = iqrf.ParseStringBytes( frcSendRequest.rdata );\r\n\r\n    // Get FRC command from request\r\n    frcCommand = requestData[0];\r\n\r\n    // If specific sensor type requested, use it\r\n    if ( requestData[2] !== 0 )\r\n      sensorType = requestData[2];\r\n\r\n    if ( iqrf.sensor.FinalizeSensor !== undefined && iqrf.sensor.SensorsList !== undefined )\r\n    {\r\n      // Sensor index from request\r\n      var sensorIndex = requestData[3] & 0x1f;\r\n      // Index from the list \r\n      var listIndex = 0;\r\n      for ( ; listIndex < iqrf.sensor.SensorsList.length; listIndex++ )\r\n      {\r\n        // Any sensor type or exact match?\r\n        if ( requestData[2] === 0 || requestData[2] === iqrf.sensor.SensorsList[listIndex] )\r\n        {\r\n          // Index counted?\r\n          if ( sensorIndex === 0 )\r\n          {\r\n            // Got the sensor index!\r\n            sensorIndex = listIndex;\r\n\r\n            // Flag the sensor index was found\r\n            listIndex = undefined;\r\n            break;\r\n          }\r\n          // Next index\r\n          sensorIndex--;\r\n        }\r\n      }\r\n\r\n      // Sensor index not found?\r\n      if ( listIndex !== undefined )\r\n        sensorIndex = undefined;\r\n    }\r\n  }\r\n\r\n  var sensorObj = iqrf.sensor.SensorTypes[sensorType];\r\n  if ( sensorObj === undefined )\r\n    throw new Error( 'iqrf.sensor.Frc_Response: Unknown sensor type ' + sensorType );\r\n\r\n  if ( -1 === iqrf.indexOf( sensorObj.frcs, frcCommand ) )\r\n    throw new Error( 'iqrf.sensor.Frc_Response: Unsupported FRC command ' + frcCommand + ' by sensor type ' + sensorType + '=' + sensorObj.name );\r\n\r\n  var result = [];\r\n  for ( var index in parsedFrc )\r\n  {\r\n    var frcValue = parsedFrc[index];\r\n\r\n    if ( frcValue === 0 )\r\n      throw new Error( 'iqrf.sensor.Frc_Response: Error FRC value 0 at index ' + index );\r\n\r\n    var value;\r\n    var decodeValue = false;\r\n\r\n    if ( frcCommand !== iqrf.sensor.STD_SENSOR_FRC_2BITS )\r\n      switch ( frcValue )\r\n      {\r\n        case 1:\r\n          value = undefined;\r\n          break;\r\n\r\n        case 2:\r\n          value = NaN;\r\n          break;\r\n\r\n        case 3:\r\n          throw new Error( 'iqrf.sensor.Frc_Response: Unsupported FRC value 3 at index ' + index );\r\n\r\n        default:\r\n          decodeValue = true;\r\n          break;\r\n      }\r\n    else\r\n      switch ( frcValue )\r\n      {\r\n        case 1:\r\n          value = undefined;\r\n          break;\r\n\r\n        case 2:\r\n        case 3:\r\n          decodeValue = true;\r\n          break;\r\n\r\n        default:\r\n          throw new Error( 'iqrf.sensor.Frc_Response: Error FRC value ' + frcValue + ' at index ' + index );\r\n      }\r\n\r\n    if ( decodeValue )\r\n      switch ( sensorType )\r\n      {\r\n        default:\r\n          throw new Error( 'iqrf.sensor.Frc_Response: Unimplemented sensor type value ' + sensorType + '=' + sensorObj.name );\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE:\r\n          switch ( frcCommand )\r\n          {\r\n            case iqrf.sensor.STD_SENSOR_FRC_1BYTE:\r\n              value = iqrf.UInt8toInt8( frcValue ) / 2.0 - 22;\r\n              break;\r\n\r\n            case iqrf.sensor.STD_SENSOR_FRC_2BYTES:\r\n              value = iqrf.UInt16toInt16( frcValue ^ 0x8000 ) / 16.0;\r\n              break;\r\n          }\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE:\r\n          value = iqrf.UInt16toInt16( frcValue ^ 0x8000 ) / 16.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_SOUND_PRESSURE_LEVEL:\r\n        case iqrf.STD_SENSOR_TYPE_TIMESPAN_LONG:\r\n          value = ( frcValue - 4 ) / 16.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_CO2:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_VOC:\r\n          switch ( frcCommand )\r\n          {\r\n            case iqrf.sensor.STD_SENSOR_FRC_1BYTE:\r\n              value = ( frcValue - 4 ) * 16;\r\n              break;\r\n\r\n            case iqrf.sensor.STD_SENSOR_FRC_2BYTES:\r\n              value = frcValue - 4;\r\n              break;\r\n          }\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE:\r\n        case iqrf.STD_SENSOR_TYPE_CONSUMPTION:\r\n        case iqrf.STD_SENSOR_TYPE_DATETIME:\r\n          value = frcValue - 4;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_CURRENT:\r\n          value = iqrf.UInt16toInt16( frcValue ^ 0x8000 ) / 1000.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_NO2:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_SO2:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_METHANE:\r\n          value = ( frcValue - 4 ) / 1000.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD:\r\n          value = iqrf.UInt16toInt16( frcValue ^ 0x8000 ) / 10000000.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_POWER:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_PARTICULATES_PM25:\r\n          value = ( frcValue - 4 ) / 4.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_CO:\r\n          value = ( frcValue - 4 ) / 100.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_O3:\r\n          value = ( frcValue - 4 ) / 10000.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_ALTITUDE:\r\n          value = iqrf.UInt16toInt16( frcValue ^ 0x8000 ) / 4.0 - 1024.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_ACCELERATION:\r\n          value = ( iqrf.UInt16toInt16( frcValue ) - 4 ) / 256.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_NH3:\r\n          value = ( frcValue - 4 ) / 10.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY:\r\n          value = ( frcValue - 4 ) / 2.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7:\r\n          switch ( frcCommand )\r\n          {\r\n            case iqrf.sensor.STD_SENSOR_FRC_2BITS:\r\n              value = frcValue & 0x01;\r\n              break;\r\n\r\n            case iqrf.sensor.STD_SENSOR_FRC_1BYTE:\r\n              value = frcValue - 4;\r\n              break;\r\n          }\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR:\r\n          value = ( frcValue - 4 ) / 200.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_UV_INDEX:\r\n          value = ( frcValue - 4 ) / 8.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_PH:\r\n          value = ( frcValue - 4 ) / 16.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30:\r\n          switch ( frcCommand )\r\n          {\r\n            case iqrf.sensor.STD_SENSOR_FRC_2BITS:\r\n              value = frcValue & 0x01;\r\n              break;\r\n\r\n            case iqrf.sensor.STD_SENSOR_FRC_4BYTES:\r\n              value = frcValue - 4;\r\n              break;\r\n          }\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_LATITUDE:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_LONGITUDE:\r\n          value = frcValue;\r\n          break;\r\n      }\r\n\r\n    if ( value !== undefined )\r\n    {\r\n      var oneSensor =\r\n      {\r\n        id: sensorObj.id,\r\n        type: sensorType,\r\n        name: sensorObj.name,\r\n        shortName: sensorObj.shortName,\r\n        value: value,\r\n        unit: sensorObj.unit,\r\n        decimalPlaces: sensorObj.decimalPlaces\r\n      };\r\n\r\n      if ( iqrf.sensor.FinalizeSensor !== undefined )\r\n        iqrf.sensor.FinalizeSensor(\r\n          // Sensor object\r\n          oneSensor,\r\n          // Sensor index\r\n          sensorIndex,\r\n          // FRC command\r\n          frcCommand,\r\n          // Extended FRC data if specified\r\n          requestData !== undefined ? ( requestData[3] >> 5 ) : undefined );\r\n\r\n      result[index] = oneSensor;\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.sensor.FinalizeSensor\r\nThis function should be implemented in the product driver in order to breakdown \"anonymous\" sensor types \"Binary Data7\", \"Binary Data30\" and \"Data Block\". The function is called by <iqrf.sensor.ReadSensorsWithTypes_Response>, <iqrf.sensor.Enumerate_Response>, and <iqrf.sensor.Frc_Response>. Also variable <iqrf.sensor.SensorsList> should be declared in the product driver. The function might also add custom product specific properties to the sensor object.\r\n\r\nWhen the function is called from <iqrf.sensor.Enumerate_Response> then sensor.value is undefined, therefore \"value\" property should not be created at the resulting breakdown sensor object.\r\n\r\nThis function might modify the sensor object. It must not alter the properties \"id\", \"type\", \"name\", \"shortName\", \"value\", \"unit\" and \"decimalPlaces\", but it might add custom product specific properties. In case of anonymous sensor data types it is supposed to add property \"breakdown\" that has the same format as return value at <iqrf.sensor.ReadSensorsWithTypes_Response>. Each array member must share the same sensor type as the \"sensor\" parameter. Please also note, that the \"value\" property must be number.\r\n\r\nParameters:\r\n  sensor - object: See member of the return array at <iqrf.sensor.ReadSensorsWithTypes_Response>.\r\n  index - number: Sensor index. It might be undefined if the required parameters were not passed to the functions that call this function.\r\n  frcCommand - number: [optional] When sensor value from the FRC result is to be processed, then this parameter is FRC command.\r\n  extendedFrcData - number: [optional] When sensor value from the FRC result is to be processed, then this parameter is extended FRC data according to the IQRF Sensor standards FRC that is used by some standard quantities.\r\n\r\nExample:\r\n--- Text\r\n// \"sensor\" parameter in entry:\r\n{\r\n    \"id\" : \"BINARYDATA7\",\r\n    \"type\": 129,\r\n    \"name\": \"Binary data7\",\r\n    \"shortName\": \"bin7\",\r\n    \"value\": 88,\r\n    \"unit\": \"?\",\r\n    \"decimalPlaces\": 0\r\n}\r\n---\r\n--- Text\r\n// \"sensor\" parameter on exit:\r\n{\r\n    \"id\" : \"BINARYDATA7\",\r\n    \"type\": 129,\r\n    \"name\": \"Binary data7\",\r\n    \"shortName\": \"bin7\",\r\n    \"value\": 88,\r\n    \"unit\": \"?\",\r\n    \"decimalPlaces\": 0,\r\n    \"breakdown\":\r\n    [\r\n      {\r\n        \"id\" : \"BINARYDATA7\",\r\n        \"type\": 129,\r\n        \"name\": \"Potentiometer\",\r\n        \"shortName\": \"pot\",\r\n        \"value\": 30.7,\r\n        \"unit\": \"%\",\r\n        \"decimalPlaces\": 1\r\n      }\r\n    ]\r\n}\r\n---\r\n*/\r\n\r\n/* Variable: iqrf.sensor.SensorsList\r\nThis variable declared in the product driver is an array listing all supported sensor types in the right order. The variable should be implemented in order to breakdown \"anonymous\" sensor types \"Binary Data7\", \"Binary Data30\" and \"Data Block\".\r\n\r\nExample:\r\n--- Text\r\n// This product sensors list\r\niqrf.sensor.SensorsList =\r\n  [\r\n    iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE,  // 0\r\n    iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE,  // 1\r\n    iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7,  // 2 : Light indicator\r\n    iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7   // 3 : Potentiometer\r\n  ];\r\n---\r\n*/\r\n\r\n//############################################################################################\r\n", "name": "IQRF: Sensor", "notes": "+ New quantities added (TimeSpan, Illuminance, NO2 (nitrogen dioxide), SO2 (sulfur dioxide), CO (carbon monoxide), O3 (ozone), Atmospheric Pressure, Color Temperature, TimeSpanLong, UV Index, Sound Pressure Level, Particulates PM2.5, Data Block, Altitude, Acceleration, pH, Ammonia, Methane ).\n+ 4 bytes FRC added.\n! Fixed negative numbers calculation for signed quantities.\n! Fixed computation of Earth\u2019s Magnetic Field value.\n+ Error sensor values detected and returned as NaN.\n+ Sensor enumeration gives list of supported FRC commands.\n+ iqrf.sensor.Frc* functions added.\n+ Optional parameter writtenData at iqrf.sensor.ReadSensorsWithTypes_Request.", "standardID": 94, "version": 15.0, "versionFlags": 0}, {"driver": "//############################################################################################\r\n\r\n/* Title: Embedded Coordinator peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x00,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 2.00, 'VersionFlags' : 1, 'Notes' : [\r\n        'Changes for DPA 4.00',\r\n        'Discarded functions for DPA commands CMD_COORDINATOR_READ_REMOTELY_BONDED_MID, CMD_COORDINATOR_CLEAR_REMOTELY_BONDED_MID, CMD_COORDINATOR_ENABLE_REMOTE_BONDING, CMD_COORDINATOR_REBOND_NODE, CMD_COORDINATOR_DISCOVERY_DATA, and CMD_NODE_REMOVE_BOND_ADDRESS.',\r\n        'Parameter bondingMask at BondNode_Request renamed to bondingTestRetries.'\r\n        ]\r\n    },    \r\n    { 'Version' : 1.00, 'VersionFlags' : 1, 'Notes' : [\r\n        'Added SmartConnect support for DPA > 3.02.',\r\n        'DiscoveredDevices_Response and BondedDevices_Response ignore addresses above 239.',\r\n        'Added SetMID.'\r\n        ]\r\n    },\r\n    { 'Version' : 0.00, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.coordinator\r\n// All prepared DPA requests have nadr set to '00'.\r\nnamespace( 'iqrf.embed.coordinator' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.AddrInfo_Request\r\nEncodes DPA request to get basic network information.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.coordinator.AddrInfo_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '00' );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.AddrInfo_Response\r\nDecodes DPA response from getting basic network information.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  object: Object with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide for details):\r\n\r\n* devNr - number: \r\n* did - number: \r\n*/\r\niqrf.embed.coordinator.AddrInfo_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '80', 2 );\r\n\r\n  var result =\r\n  {\r\n    devNr: responseData[0],\r\n    did: responseData[1]\r\n  };\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.DiscoveredDevices_Request\r\nEncodes DPA request to get list of discovered devices\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.coordinator.DiscoveredDevices_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '01' );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.DiscoveredDevices_Response\r\nDecodes DPA response from getting list of discovered devices.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  array: Array if integer values corresponding to the addresses of the discovered devices.\r\n*/\r\niqrf.embed.coordinator.DiscoveredDevices_Response = function ( response )\r\n{\r\n  return iqrf.BitmapToIndexes( iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '81', 32 ), 0, 29 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.BondedDevices_Request\r\nEncodes DPA request to get list of bonded devices\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.coordinator.BondedDevices_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '02' );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.BondedDevices_Response\r\nDecodes DPA response from getting list of bonded devices.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  array: Array if integer values corresponding to the addresses of the bonded devices.\r\n*/\r\niqrf.embed.coordinator.BondedDevices_Response = function ( response )\r\n{\r\n  return iqrf.BitmapToIndexes( iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '82', 32 ), 0, 29 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.ClearAllBonds_Request\r\nEncodes DPA request to clear all bonds.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.coordinator.ClearAllBonds_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '03' );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.ClearAllBonds_Response\r\nDecodes DPA response from clearing all bonds.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.coordinator.ClearAllBonds_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '83', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.BondNode_Request\r\nEncodes DPA request to bond a node.\r\n\r\nParameters:\r\n  reqAddr - number: Requested address.\r\n  bondingTestRetries - number: Bonding mask.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.coordinator.BondNode_Request = function ( reqAddr, bondingTestRetries )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '04', iqrf.ToHexStringByte( reqAddr ) + '.' + iqrf.ToHexStringByte( bondingTestRetries ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.BondNode_Response\r\nDecodes DPA response from bonding a node.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  object: Object with the following fields:\r\n\r\n* bondAddr - number: Address of the node newly bonded to the network.\r\n* devNr - number: Number of bonded network nodes.\r\n*/\r\niqrf.embed.coordinator.BondNode_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '84', 2 );\r\n\r\n  var result =\r\n  {\r\n    bondAddr: responseData[0],\r\n    devNr: responseData[1]\r\n  };\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.RemoveBond_Request\r\nEncodes DPA request to remove bond.\r\n\r\nParameters:\r\n  bondAddr - number: Address of the node to remove the bond to.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.coordinator.RemoveBond_Request = function ( bondAddr )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '05', iqrf.ToHexStringByte( bondAddr ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.RemoveBond_Response\r\nDecodes DPA response from removing bond.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  number: Number of bonded network nodes.\r\n*/\r\niqrf.embed.coordinator.RemoveBond_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '85', 1 );\r\n  return responseData[0];\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.Discovery_Request\r\nEncodes DPA request to run discovery.\r\n\r\nParameters:\r\n  txPower - number: TX Power used for discovery. \r\n  maxAddr - number: Nonzero value specifies maximum node address to be part of the discovery process. \r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.coordinator.Discovery_Request = function ( txPower, maxAddr )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '07', iqrf.ToHexStringByte( txPower ) + '.' + iqrf.ToHexStringByte( maxAddr ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.Discovery_Response\r\nDecodes DPA response from running discovery.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  number: Number of discovered network nodes.\r\n*/\r\niqrf.embed.coordinator.Discovery_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '87', 1 );\r\n  return responseData[0];\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.SetDpaParams_Request\r\nEncodes DPA request to set DPA parameter.\r\n\r\nParameters:\r\n  dpaParam - number: DPA param to set.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.coordinator.SetDpaParams_Request = function ( dpaParam )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '08', iqrf.ToHexStringByte( dpaParam ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.SetDpaParams_Response\r\nDecodes DPA response from setting DPA parameter.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  number: Previous DPA parameter value.\r\n*/\r\niqrf.embed.coordinator.SetDpaParams_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '88', 1 );\r\n  return responseData[0];\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.SetHops_Request\r\nEncodes DPA request to specify number of hops\r\n\r\nParameters:\r\n  requestHops - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  responseHops - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.coordinator.SetHops_Request = function ( requestHops, responseHops )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '09', iqrf.ToHexStringByte( requestHops ) + '.' + iqrf.ToHexStringByte( responseHops ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.SetHops_Response\r\nDecodes DPA response from specifying number of hops.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\nobject: Object with the following fields storing previous values:\r\n\r\n* requestHops - number: \r\n* responseHops - number: \r\n*/\r\niqrf.embed.coordinator.SetHops_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '89', 2 );\r\n\r\n  var result =\r\n  {\r\n    requestHops: responseData[0],\r\n    responseHops: responseData[1]\r\n  };\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.Backup_Request\r\nEncodes DPA request to backup coordinator.\r\n\r\nParameters:\r\n  index - number: Index of the block of data.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.coordinator.Backup_Request = function ( index )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '0B', iqrf.ToHexStringByte( index ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.Backup_Response\r\nDecodes DPA response from backing up coordinator.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  array: Array of bytes with the backup content.\r\n*/\r\niqrf.embed.coordinator.Backup_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '8B', 49 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.Restore_Request\r\nEncodes DPA request to restore coordinator.\r\n\r\nParameters:\r\n  networkData - array: One block of the coordinator network info data previously obtained by a backup command.  \r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.coordinator.Restore_Request = function ( networkData )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '0C', iqrf.BytesToHexStringBytesArray( networkData ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.Restore_Response\r\nDecodes DPA response from restoring coordinator.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.coordinator.Restore_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '8C', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.AuthorizeBond_Request\r\nEncodes DPA request to authorize previously remotely pre-bonded node.\r\n\r\nParameters:\r\n  reqAddr - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  mid - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.coordinator.AuthorizeBond_Request = function ( reqAddr, mid )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '0D', iqrf.ToHexStringByte( reqAddr ) + '.' + iqrf.IntToHexStringBytesArray( mid, 4 ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.AuthorizeBond_Response\r\nDecodes DPA response from authorizing previously remotely pre-bonded node.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  object: Object with the following fields:\r\n\r\n* bondAddr - number: Address of the node newly bonded to the network.\r\n* devNr - number: Number of bonded network nodes.\r\n*/\r\niqrf.embed.coordinator.AuthorizeBond_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '8D', 2 );\r\n\r\n  var result =\r\n  {\r\n    bondAddr: responseData[0],\r\n    devNr: responseData[1]\r\n  };\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.SmartConnect_Request\r\nEncodes DPA request for Smart Connect.\r\nFrom version 1.00 for DPA > 3.02.\r\n\r\nParameters:\r\n  reqAddr - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  bondingTestRetries - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  ibk - array: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  mid - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  virtualDeviceAddress - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  userData - array:  see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\n\r\niqrf.embed.coordinator.SmartConnect_Request = function ( reqAddr, bondingTestRetries, ibk, mid, virtualDeviceAddress, userData )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '12',\r\n    iqrf.ToHexStringByte( reqAddr ) + '.' +\r\n    iqrf.ToHexStringByte( bondingTestRetries ) + '.' +\r\n    iqrf.BytesToHexStringBytesArray( ibk ) + '.' +\r\n    iqrf.IntToHexStringBytesArray( mid, 4 ) + '.00.00.' +\r\n    iqrf.ToHexStringByte( virtualDeviceAddress ) + '.00.00.00.00.00.00.00.00.00.' +\r\n    iqrf.BytesToHexStringBytesArray( userData ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.SmartConnect_Response\r\nDecodes DPA response from Smart Connect.\r\nFrom version 1.00 for DPA > 3.02.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  object: Object with the following fields:\r\n\r\n* bondAddr - number: Address of the node newly bonded to the network.\r\n* devNr - number: Number of bonded network nodes.\r\n*/\r\niqrf.embed.coordinator.SmartConnect_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '92', 2 );\r\n\r\n  var result =\r\n  {\r\n    bondAddr: responseData[0],\r\n    devNr: responseData[1]\r\n  };\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.SetMID_Request\r\nEncodes DPA request to set the MID.\r\nFrom version 1.00 for DPA > 3.02.\r\n\r\nParameters:\r\n  bondAddr - number: Address of the node.\r\n  mid - number: MID to write to the Coordinator's database.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.coordinator.SetMID_Request = function ( bondAddr, mid )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '13', iqrf.IntToHexStringBytesArray( mid, 4 ) + '.' + iqrf.ToHexStringByte( bondAddr ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.SetMID_Response\r\nDecodes DPA response from setting the MID.\r\nFrom version 1.00 for DPA > 3.02.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.coordinator.SetMID_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '93', 0 );\r\n};\r\n\r\n//############################################################################################\r\n", "name": "Embed: Coordinator", "notes": "Changes for DPA 4.00\nDiscarded functions for DPA commands CMD_COORDINATOR_READ_REMOTELY_BONDED_MID, CMD_COORDINATOR_CLEAR_REMOTELY_BONDED_MID, CMD_COORDINATOR_ENABLE_REMOTE_BONDING, CMD_COORDINATOR_REBOND_NODE, CMD_COORDINATOR_DISCOVERY_DATA, and CMD_NODE_REMOVE_BOND_ADDRESS.\nParameter bondingMask at BondNode_Request renamed to bondingTestRetries.", "standardID": 0, "version": 2.0, "versionFlags": 1}, {"driver": "//############################################################################################\r\n\r\n/* Title: Embedded Node peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x01,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 1.00, 'VersionFlags' : 1, 'Notes' : [\r\n        'Changes for DPA 4.00',\r\n        'Discarded functions for DPA commands CMD_NODE_READ_REMOTELY_BONDED_MID, CMD_NODE_CLEAR_REMOTELY_BONDED_MID, and CMD_NODE_ENABLE_REMOTE_BONDING.'\r\n        ]\r\n    },    \r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.node\r\nnamespace( 'iqrf.embed.node' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.node.Read_Request\r\nEncodes DPA request to read Node information.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.node.Read_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_Node, '00' );\r\n};\r\n\r\n/* Function: iqrf.embed.node.Read_Response\r\nDecodes DPA response from reading Node information.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  object: Object with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide/index.html?page=NodeRead.html for details):\r\n\r\n* ntwADDR - number: \r\n* ntwVRN - number: \r\n* ntwZIN - number:  \r\n* ntwDID - number: \r\n* ntwPVRN - number: \r\n* ntwUSERADDRESS - number: \r\n* ntwID - number: \r\n* ntwVRNFNZ - number: \r\n* ntwCFG - number: \r\n* flags - number: \r\n*/\r\niqrf.embed.node.Read_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Node, '80', 12 );\r\n\r\n  var result =\r\n  {\r\n    ntwADDR: responseData[0],\r\n    ntwVRN: responseData[1],\r\n    ntwZIN: responseData[2],\r\n    ntwDID: responseData[3],\r\n    ntwPVRN: responseData[4],\r\n    ntwUSERADDRESS: responseData[5] + ( responseData[6] * 0x100 ),\r\n    ntwID: responseData[7] + ( responseData[8] * 0x100 ),\r\n    ntwVRNFNZ: responseData[9],\r\n    ntwCFG: responseData[10],\r\n    flags: responseData[11]\r\n  };\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.node.RemoveBond_Request\r\nEncodes DPA request to remove bond.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.node.RemoveBond_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_Node, '01' );\r\n};\r\n\r\n/* Function: iqrf.embed.node.RemoveBond_Response\r\nDecodes DPA response from removing bond.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.node.RemoveBond_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Node, '81', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.node.RemoveBondAddress_Request\r\nEncodes DPA request to remove bond address.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.node.RemoveBondAddress_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_Node, '05' );\r\n};\r\n\r\n/* Function: iqrf.embed.node.RemoveBondAddress_Response\r\nDecodes DPA response from removing bond address.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.node.RemoveBondAddress_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Node, '85', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.node.Backup_Request\r\nEncodes DPA request to backup node.\r\n\r\nParameters:\r\n  index - number: Index of the block of data.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.node.Backup_Request = function ( index )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_Node, '06', iqrf.ToHexStringByte( index ) );\r\n};\r\n\r\n/* Function: iqrf.embed.node.Backup_Response\r\nDecodes DPA response from backing up node.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  array: Array of bytes with the backup content.\r\n*/\r\niqrf.embed.node.Backup_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Node, '86', 49 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.node.Restore_Request\r\nEncodes DPA request to restore node.\r\n\r\nParameters:\r\n  networkData - array: One block of the coordinator network info data previously obtained by a backup command.  \r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.node.Restore_Request = function ( networkData )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_Node, '07', iqrf.BytesToHexStringBytesArray( networkData ) );\r\n};\r\n\r\n/* Function: iqrf.embed.node.Restore_Response\r\nDecodes DPA response from restoring node.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.node.Restore_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Node, '87', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.node.ValidateBonds_Request\r\nEncodes DPA request to validate bonds.\r\n\r\nParameters:\r\n  nodes - array: Array of objects with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide for details):\r\n\r\n*  bondAddr - number: Address of the node to validate.\r\n*  mid - number: MID to check against.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.node.ValidateBonds_Request = function ( nodes )\r\n{\r\n  var data = '';\r\n  var nodes_length = nodes.length;\r\n  for ( var index = 0; index < nodes_length; index++ )\r\n  {\r\n    var oneNode = nodes[index];\r\n    data += iqrf.ToHexStringByte( oneNode.bondAddr ) + '.' + iqrf.IntToHexStringBytesArray( oneNode.mid, 4 );\r\n  }\r\n\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_Node, '08', data );\r\n};\r\n\r\n/* Function: iqrf.embed.node.ValidateBonds_Response\r\nDecodes DPA response from validating bonds.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.node.ValidateBonds_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Node, '88', 0 );\r\n};\r\n\r\n\r\n//############################################################################################\r\n", "name": "Embed: Node", "notes": "Changes for DPA 4.00\nDiscarded functions for DPA commands CMD_NODE_READ_REMOTELY_BONDED_MID, CMD_NODE_CLEAR_REMOTELY_BONDED_MID, and CMD_NODE_ENABLE_REMOTE_BONDING.", "standardID": 1, "version": 1.0, "versionFlags": 1}, {"driver": "//############################################################################################\r\n\r\n/* Title: Embedded OS peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x02,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 1.00, 'VersionFlags' : 1, 'Notes' : [\r\n        'Read_Response returns ibk field compatible with DPA > 3.02',\r\n        'WriteCfg_Request - checksum parameter removed',\r\n        'TestRfSignal added'\r\n        ]\r\n    },\r\n    { 'Version' : 0.00, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.os\r\nnamespace( 'iqrf.embed.os' );\r\n\r\n/* Function: iqrf.embed.os.Read_Request\r\nEncodes DPA request to read OS.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.os.Read_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '00' );\r\n};\r\n\r\n/* Function: iqrf.embed.os.Read_Response\r\nDecodes DPA response from reading OS.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  object: Object with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide/ for details):\r\n\r\n* mid - number: \r\n* osVersion - number: \r\n* trMcuType - number: \r\n* osBuild - number: \r\n* rssi - number: \r\n* supplyVoltage - number: contains real voltage value\r\n* flags - number: \r\n* slotLimits - number: \r\n* ibk - array: (from version 1.00 for DPA > 3.02)\r\n*/\r\niqrf.embed.os.Read_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '80', 28 );\r\n\r\n  var result =\r\n    {\r\n      mid: responseData[0] + ( responseData[1] * 0x100 ) + ( responseData[2] * 0x10000 ) + ( responseData[3] * 0x1000000 ),\r\n      osVersion: responseData[4],\r\n      trMcuType: responseData[5],\r\n      osBuild: responseData[6] + ( responseData[7] * 0x100 ),\r\n      rssi: responseData[8],\r\n      supplyVoltage: 261.12 / ( 127 - responseData[9] ),\r\n      flags: responseData[10],\r\n      slotLimits: responseData[11],\r\n      ibk: responseData.slice( 12, 28 )\r\n    };\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.Reset_Request\r\nEncodes DPA request to reset.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.os.Reset_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '01' );\r\n};\r\n\r\n/* Function: iqrf.embed.os.Reset_Response\r\nDecodes DPA response from reset.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.os.Reset_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '81', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.ReadCfg_Request\r\nEncodes DPA request to read configuration.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.os.ReadCfg_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '02' );\r\n};\r\n\r\n/* Function: iqrf.embed.os.ReadCfg_Response\r\nDecodes DPA response from reading configuration.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  object: Object with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide for details):\r\n\r\n* checksum - number: \r\n* configuration - array: \r\n* rfpgm - number: \r\n* undocumented - number: \r\n*/\r\niqrf.embed.os.ReadCfg_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '82', 34 );\r\n\r\n  var result =\r\n    {\r\n      checksum: responseData[0],\r\n      configuration: responseData.slice( 1, 32 ),\r\n      rfpgm: responseData[32],\r\n      undocumented: responseData[33]\r\n    };\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.Rfpgm_Request\r\nEncodes DPA request to start RFPGM.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.os.Rfpgm_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '03' );\r\n};\r\n\r\n/* Function: iqrf.embed.os.Rfpgm_Response\r\nDecodes DPA response from starting RFPGM.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.os.Rfpgm_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '83', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.Sleep_Request\r\nEncodes DPA request to sleep.\r\n\r\nParameters:\r\n  time - number: See DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  control - number: See DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.os.Sleep_Request = function ( time, control )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '04', iqrf.IntToHexStringBytesArray( time, 2 ) + '.' + iqrf.ToHexStringByte( control ) );\r\n};\r\n\r\n/* Function: iqrf.embed.os.Sleep_Response\r\nDecodes DPA response from sleeping.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.os.Sleep_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '84', 0 );\r\n};\r\n\r\niqrf.embed.os.Batch_ConstructRequests = function ( requests )\r\n{\r\n  var data = '';\r\n  var requests_length = requests.length;\r\n  for ( var index = 0; index < requests_length; index++ )\r\n  {\r\n    var oneRequest = requests[index];\r\n    var hwpid = parseInt( oneRequest.hwpid, 16 );\r\n    var oneData =\r\n      iqrf.NormalizeStringByte( oneRequest.pnum ) + '.' +\r\n      iqrf.NormalizeStringByte( oneRequest.pcmd ) + '.' +\r\n      iqrf.ToHexStringByte( hwpid & 0xFF ) + '.' +\r\n      iqrf.ToHexStringByte( hwpid >> 8 );\r\n\r\n    if ( oneRequest.rdata !== undefined )\r\n      oneData += '.' + iqrf.BytesToHexStringBytesArray( iqrf.ParseStringBytes( oneRequest.rdata ) );\r\n\r\n    oneData = iqrf.ToHexStringByte( 1 + ( 1 + oneData.length ) / 3 ) + '.' + oneData;\r\n\r\n    if ( data.length !== 0 )\r\n      data += '.';\r\n    data += oneData;\r\n  }\r\n\r\n  return data + '.00';\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.Batch_Request\r\nEncodes DPA request to execute a batch.\r\n\r\nParameters:\r\n  requests - array: Array of objects (requests) created by other ?_Request functions.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.os.Batch_Request = function ( requests )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '05', iqrf.embed.os.Batch_ConstructRequests( requests ) );\r\n};\r\n\r\n/* Function: iqrf.embed.os.Batch_Response\r\nDecodes DPA response from executing a batch.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.os.Batch_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '85', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.SetSecurity_Request\r\nEncodes DPA request to set various security parameters.\r\n\r\nParameters:\r\n  type - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  data - array: see DPA documentation https://www.iqrf.org/DpaTechGuide for details. \r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.os.SetSecurity_Request = function ( type, data )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '06', iqrf.ToHexStringByte( type ) + iqrf.BytesToHexStringBytesArray( data, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.os.SetSecurity_Response\r\nDecodes DPA response from setting various security parameters.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.os.SetSecurity_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '86', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.Restart_Request\r\nEncodes DPA request to restart device.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.os.Restart_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '08' );\r\n};\r\n\r\n/* Function: iqrf.embed.os.Restart_Response\r\nDecodes DPA response from restarting device.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.os.Restart_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '88', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.WriteCfgByte_Request\r\nEncodes DPA request to write configuration bytes.\r\n\r\nParameters:\r\n  bytes - array: Array of objects with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide for details):\r\n\r\n* address - number: \r\n* value - number: \r\n* mask - number: \r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.os.WriteCfgByte_Request = function ( bytes )\r\n{\r\n  var data = '';\r\n  var bytes_length = bytes.length;\r\n  for ( var index = 0; index < bytes_length; index++ )\r\n  {\r\n    if ( data.length !== 0 )\r\n      data += '.';\r\n\r\n    var oneByte = bytes[index];\r\n    data +=\r\n      iqrf.ToHexStringByte( oneByte.address ) + '.' +\r\n      iqrf.ToHexStringByte( oneByte.value ) + '.' +\r\n      iqrf.ToHexStringByte( oneByte.mask );\r\n  }\r\n\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '09', data );\r\n};\r\n\r\n/* Function: iqrf.embed.os.WriteCfgByte_Response\r\nDecodes DPA response from writing configuration bytes.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.os.WriteCfgByte_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '89', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.LoadCode_Request\r\nEncodes DPA request to load code.\r\n\r\nParameters:\r\n  flags - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  address - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  length - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  checkSum - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.os.LoadCode_Request = function ( flags, address, length, checkSum )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '0A',\r\n    iqrf.ToHexStringByte( flags ) + '.' +\r\n    iqrf.IntToHexStringBytesArray( address, 2 ) + '.' +\r\n    iqrf.IntToHexStringBytesArray( length, 2 ) + '.' +\r\n    iqrf.IntToHexStringBytesArray( checkSum, 2 ) );\r\n};\r\n\r\n/* Function: iqrf.embed.os.LoadCode_Response\r\nDecodes DPA response from loading code.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  number: Loading code result value.\r\n*/\r\niqrf.embed.os.LoadCode_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '8A', 1 );\r\n  return responseData[0];\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.SelectiveBatch_Request\r\nEncodes DPA request to execute a selective batch.\r\n\r\nParameters:\r\n  selectedNodes - array: Array if integer values corresponding to the selected nodes.\r\n  requests - array: Array of objects (requests) created by other ?_Request functions.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.os.SelectiveBatch_Request = function ( selectedNodes, requests )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '0B',\r\n    iqrf.BytesToHexStringBytesArray( iqrf.IndexesToBitmap( selectedNodes, 30 ) ) + '.' + iqrf.embed.os.Batch_ConstructRequests( requests ) );\r\n};\r\n\r\n/* Function: iqrf.embed.os.SelectiveBatch_Response\r\nDecodes DPA response from executing a selective batch.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.os.SelectiveBatch_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '8B', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.TestRfSignal_Request\r\nEncodes DPA request to test RF signal.\r\n\r\nParameters:\r\n  channel - number: The channel to test. \r\n  rxFilter - number: RX filter value passed as a parameter to checkRF().\r\n  time  - number: Time interval to test the signal. Unit is 10 ms. \r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.os.TestRfSignal_Request = function ( channel, rxFilter, time )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '0C',\r\n    iqrf.ToHexStringByte( channel ) + '.' + iqrf.ToHexStringByte( rxFilter ) + '.' + iqrf.IntToHexStringBytesArray( time, 2 ) );\r\n};\r\n\r\n/* Function: iqrf.embed.os.TestRfSignal_Response\r\nDecodes DPA response from testing RF signal.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  number: See FRC_TestRFsignal FRC command documentation.\r\n*/\r\niqrf.embed.os.TestRfSignal_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '8C', 1 );\r\n\r\n  return responseData[0];\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.WriteCfg_Request\r\nEncodes DPA request to write configuration.\r\n\r\nParameters:\r\n  configuration - array: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  rfpgm - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.os.WriteCfg_Request = function ( configuration, rfpgm )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '0F', '00' + iqrf.BytesToHexStringBytesArray( configuration, true ) + '.' + iqrf.ToHexStringByte( rfpgm ) );\r\n};\r\n\r\n/* Function: iqrf.embed.os.WriteCfg_Response\r\nDecodes DPA response from writing configuration.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.os.WriteCfg_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '8F', 0 );\r\n};\r\n\r\n//############################################################################################\r\n", "name": "Embed: OS", "notes": "Read_Response returns ibk field compatible with DPA > 3.02\nWriteCfg_Request - checksum parameter removed\nTestRfSignal added", "standardID": 2, "version": 1.0, "versionFlags": 1}, {"driver": "//############################################################################################\r\n\r\n/* Title: Embedded EEPROM peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x03,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.eeprom\r\nnamespace( 'iqrf.embed.eeprom' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.eeprom.Read_Request\r\nEncodes DPA request to read from memory.\r\n\r\nParameters:\r\n  address - number: Memory address to read from.\r\n  len - number: Length of data to read.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.eeprom.Read_Request = function ( address, len )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_EEPROM, '00', iqrf.ToHexStringByte( address ) + '.' + iqrf.ToHexStringByte( len ) );\r\n};\r\n\r\n/* Function: iqrf.embed.eeprom.Read_Response\r\nDecodes DPA response from reading from memory.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  array: Read data.\r\n*/\r\niqrf.embed.eeprom.Read_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_EEPROM, '80' );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.eeprom.Write_Request\r\nEncodes DPA request to write to memory.\r\n\r\nParameters:\r\n  address - number: Address to write data to.\r\n  pdata - array: Data to write.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.eeprom.Write_Request = function ( address, pdata )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_EEPROM, '01', iqrf.ToHexStringByte( address ) + iqrf.BytesToHexStringBytesArray( pdata, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.eeprom.Write_Response\r\nDecodes DPA response from writing to memory.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.eeprom.Write_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_EEPROM, '81', 0 );\r\n};\r\n\r\n//############################################################################################\r\n", "name": "Embed: EEPROM", "notes": "Initial release", "standardID": 3, "version": 0.0, "versionFlags": 0}, {"driver": "//############################################################################################\r\n\r\n/* Title: Embedded External EEPROM (aka EEEPROM) peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x04,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.eeeprom\r\nnamespace( 'iqrf.embed.eeeprom' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.eeeprom.Read_Request\r\nEncodes DPA request to read from memory.\r\n\r\nParameters:\r\n  address - number: Memory address to read from.\r\n  len - number: Length of data to read.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.eeeprom.Read_Request = function ( address, len )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_EEEPROM, '02', iqrf.IntToHexStringBytesArray( address, 2 ) + '.' + iqrf.ToHexStringByte( len ) );\r\n};\r\n\r\n/* Function: iqrf.embed.eeeprom.Read_Response\r\nDecodes DPA response from reading from memory.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  array: Read data.\r\n*/\r\niqrf.embed.eeeprom.Read_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_EEEPROM, '82' );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.eeeprom.Write_Request\r\nEncodes DPA request to write to memory.\r\n\r\nParameters:\r\n  address - number: Address to write data to.\r\n  pdata - number: Data to write.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.eeeprom.Write_Request = function ( address, pdata )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_EEEPROM, '03', iqrf.IntToHexStringBytesArray( address, 2 ) + iqrf.BytesToHexStringBytesArray( pdata, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.eeeprom.Write_Response\r\nDecodes DPA response from writing to memory.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.eeeprom.Write_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_EEEPROM, '83', 0 );\r\n};\r\n\r\n//############################################################################################\r\n", "name": "Embed: EEEPROM", "notes": "Initial release", "standardID": 4, "version": 0.0, "versionFlags": 0}, {"driver": "//############################################################################################\r\n\r\n/* Title: Embedded RAM peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x05,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.ram\r\nnamespace( 'iqrf.embed.ram' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.ram.Read_Request\r\nEncodes DPA request to read from memory.\r\n\r\nParameters:\r\n  address - number: Memory address to read from.\r\n  len - number: Length of data to read.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.ram.Read_Request = function ( address, len )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_RAM, '00', iqrf.ToHexStringByte( address ) + '.' + iqrf.ToHexStringByte( len ) );\r\n};\r\n\r\n/* Function: iqrf.embed.ram.Read_Response\r\nDecodes DPA response from reading from memory.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  array: Read data.\r\n*/\r\niqrf.embed.ram.Read_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_RAM, '80' );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.ram.Write_Request\r\nEncodes DPA request to write to memory.\r\n\r\nParameters:\r\n  address - number: Address to write data to.\r\n  pdata - array: Data to write.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.ram.Write_Request = function ( address, pdata )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_RAM, '01', iqrf.ToHexStringByte( address ) + iqrf.BytesToHexStringBytesArray( pdata, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.ram.Write_Response\r\nDecodes DPA response from writing to memory.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.ram.Write_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_RAM, '81', 0 );\r\n};\r\n\r\n//############################################################################################\r\n", "name": "Embed: RAM", "notes": "Initial release", "standardID": 5, "version": 0.0, "versionFlags": 0}, {"driver": "//############################################################################################\r\n\r\n/* Title: Embedded Red LED peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x06,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 1.00, 'VersionFlags' : 1, 'Notes' : [\r\n        'Get_Request and Get_Response removed.',\r\n        'Added Flashing command.'\r\n        ]\r\n    },\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.ledr\r\nnamespace( 'iqrf.embed.ledr' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.ledr.Set_Request\r\nEncodes DPA request to set the LED.\r\n\r\nParameters:\r\n  onOff - boolean: Required LED state. true is on, false is off.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.ledr.Set_Request = function ( onOff )\r\n{\r\n  if ( typeof onOff !== 'boolean' )\r\n    throw new Error( 'iqrf.embed.ledr.Set_Request: Parameter onOff expected to be boolean but not ' + typeof onOff );\r\n\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_LEDR, iqrf.ToHexStringByte( onOff ? 1 : 0 ) );\r\n};\r\n\r\n/* Function: iqrf.embed.ledr.Set_Response\r\nDecodes DPA response from setting the LED.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.ledr.Set_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_LEDR, '80.81', 0 );\r\n};\r\n\r\n/* Function: iqrf.embed.ledr.Pulse_Request\r\nEncodes DPA request to pulse the LED.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.ledr.Pulse_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_LEDR, '03' );\r\n};\r\n\r\n/* Function: iqrf.embed.ledr.Pulse_Response\r\nDecodes DPA response from pulsing the LED.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.ledr.Pulse_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_LEDR, '83', 0 );\r\n};\r\n\r\n/* Function: iqrf.embed.ledr.Flashing_Request\r\nEncodes DPA request for flashing the LED.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.ledr.Flashing_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_LEDR, '04' );\r\n};\r\n\r\n/* Function: iqrf.embed.ledr.Flashing_Response\r\nDecodes DPA response from flashing the LED.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.ledr.Flashing_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_LEDR, '84', 0 );\r\n};\r\n\r\n//############################################################################################\r\n", "name": "Embed: Red LED", "notes": "Get_Request and Get_Response removed.\nAdded Flashing command.", "standardID": 6, "version": 1.0, "versionFlags": 1}, {"driver": "//############################################################################################\r\n\r\n/* Title: Embedded Green LED peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x07,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 1.00, 'VersionFlags' : 1, 'Notes' : [\r\n        'Get_Request and Get_Response removed.',\r\n        'Added Flashing command.'\r\n        ]\r\n    },\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.ledg\r\nnamespace( 'iqrf.embed.ledg' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.ledg.Set_Request\r\nEncodes DPA request to set the LED.\r\n\r\nParameters:\r\n  onOff - boolean: Required LED state. true is on, false is off.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.ledg.Set_Request = function ( onOff )\r\n{\r\n  if ( typeof onOff !== 'boolean' )\r\n    throw new Error( 'iqrf.embed.ledg.Set_Request: Parameter onOff expected to be boolean but not ' + typeof onOff );\r\n\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_LEDG, iqrf.ToHexStringByte( onOff ? 1 : 0 ) );\r\n};\r\n\r\n/* Function: iqrf.embed.ledg.Set_Response\r\nDecodes DPA response from setting the LED.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.ledg.Set_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_LEDG, '80.81', 0 );\r\n};\r\n\r\n/* Function: iqrf.embed.ledg.Pulse_Request\r\nEncodes DPA request to pulse the LED.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.ledg.Pulse_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_LEDG, '03' );\r\n};\r\n\r\n/* Function: iqrf.embed.ledg.Pulse_Response\r\nDecodes DPA response from pulsing the LED.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.ledg.Pulse_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_LEDG, '83', 0 );\r\n};\r\n\r\n/* Function: iqrf.embed.ledg.Flashing_Request\r\nEncodes DPA request for flashing the LED.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.ledg.Flashing_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_LEDG, '04' );\r\n};\r\n\r\n/* Function: iqrf.embed.ledg.Flashing_Response\r\nDecodes DPA response from flashing the LED.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.ledg.Flashing_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_LEDG, '84', 0 );\r\n};\r\n\r\n//############################################################################################\r\n", "name": "Embed: Green LED", "notes": "Get_Request and Get_Response removed.\nAdded Flashing command.", "standardID": 7, "version": 1.0, "versionFlags": 1}, {"driver": "//############################################################################################\r\n\r\n/* Title: Embedded SPI peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x08,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.spi\r\nnamespace( 'iqrf.embed.spi' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.spi.WriteRead_Request\r\nEncodes DPA request to write and/or read data to/from SPI peripheral.\r\n\r\nParameters:\r\n  readTimeout - number:\r\n  writtenData - array: Array of bytes.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.spi.WriteRead_Request = function ( readTimeout, writtenData )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_SPI, '00', iqrf.ToHexStringByte( readTimeout ) + iqrf.BytesToHexStringBytesArray( writtenData, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.spi.WriteRead_Response\r\nDecodes DPA response from writing and/or reading data to/from SPI peripheral.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  array: Read data.\r\n*/\r\niqrf.embed.spi.WriteRead_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_SPI, '80' );\r\n};\r\n\r\n//############################################################################################\r\n", "name": "Embed: SPI", "notes": "Initial release", "standardID": 8, "version": 0.0, "versionFlags": 0}, {"driver": "//############################################################################################\r\n\r\n/* Title: Embedded IO peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x09,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release' ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.io\r\nnamespace( 'iqrf.embed.io' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.io.Direction_Request\r\nEncodes DPA request to set direction of IOs.\r\n\r\nParameters:\r\n  ports - attay: Array of objects with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide for details):\r\n\r\n* port - number: \r\n* mask - number: \r\n* value - number:\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.io.Direction_Request = function ( ports )\r\n{\r\n  var data = '';\r\n  var ports_length = ports.length;\r\n  for ( var index = 0; index < ports_length; index++ )\r\n  {\r\n    if ( data.length !== 0 )\r\n      data += '.';\r\n\r\n    var onePort = ports[index];\r\n    data +=\r\n      iqrf.ToHexStringByte( onePort.port ) + '.' +\r\n      iqrf.ToHexStringByte( onePort.mask ) + '.' +\r\n      iqrf.ToHexStringByte( onePort.value );\r\n  }\r\n\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_IO, '00', data );\r\n};\r\n\r\n/* Function: iqrf.embed.io.Direction_Response\r\nDecodes DPA response from setting direction of IOs.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.io.Direction_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_IO, '80', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.io.Set_Request\r\nEncodes DPA request to set IOs.\r\n\r\nParameters:\r\n  ports - array: Array of objects with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide for details):\r\n\r\n* port - number: \r\n* mask - number: \r\n* value - number: \r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.io.Set_Request = function ( ports )\r\n{\r\n  var data = '';\r\n  var ports_length = ports.length;\r\n  for ( var index = 0; index < ports_length; index++ )\r\n  {\r\n    if ( data.length !== 0 )\r\n      data += '.';\r\n\r\n    var onePort = ports[index];\r\n    data +=\r\n      iqrf.ToHexStringByte( onePort.port ) + '.' +\r\n      iqrf.ToHexStringByte( onePort.mask ) + '.' +\r\n      iqrf.ToHexStringByte( onePort.value );\r\n  }\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_IO, '01', data );\r\n};\r\n\r\n/* Function: iqrf.embed.io.Set_Response\r\nDecodes DPA response from setting IOs.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.io.Set_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_IO, '81', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.io.Get_Request\r\nEncodes DPA request to read the input state of all supported the MCU ports.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.io.Get_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_IO, '02' );\r\n};\r\n\r\n/* Function: iqrf.embed.io.Get_Response\r\nDecodes DPA response from reading the input state of all supported the MCU ports.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  array: Ports values (see DPA documentation https://www.iqrf.org/DpaTechGuide for details).\r\n*/\r\niqrf.embed.io.Get_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_IO, '82', -5 );\r\n};\r\n\r\n//############################################################################################\r\n", "name": "Embed: IO", "notes": "Initial release", "standardID": 9, "version": 0.0, "versionFlags": 0}, {"driver": "//############################################################################################\r\n\r\n/* Title: Embedded Thermometer peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x0A,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.thermometer\r\nnamespace( 'iqrf.embed.thermometer' );\r\n\r\n/* Function: iqrf.embed.thermometer.Read_Request\r\nEncodes DPA request to read temperature.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.thermometer.Read_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_Thermometer, '00' );\r\n};\r\n\r\n/* Function: iqrf.embed.thermometer.Read_Response\r\nDecodes DPA response from reading temperature.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturn:\r\n  number: Temperature value.\r\n*/\r\niqrf.embed.thermometer.Read_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Thermometer, '80', 3 );\r\n  if ( responseData[0] === 0x80 )\r\n    throw new Error( 'iqrf.embed.thermometer.Read_Response: Temperature sensor missing' );\r\n\r\n  return ( responseData[1] + ( responseData[2] * 0x100 ) ) / 16.0;\r\n};\r\n\r\n//############################################################################################\r\n", "name": "Embed: Thermometer", "notes": "Initial release", "standardID": 10, "version": 0.0, "versionFlags": 0}, {"driver": "//############################################################################################\r\n\r\n/* Title: Embedded UART peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x0C,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.uart\r\nnamespace( 'iqrf.embed.uart' );\r\n\r\n// Baudrates\r\n/* Const: iqrf.embed.uart.DpaBaud_1200\r\n*/\r\niqrf.embed.uart.DpaBaud_1200 = 0x00;\r\n/* Const: iqrf.embed.uart.DpaBaud_2400\r\n*/\r\niqrf.embed.uart.DpaBaud_2400 = 0x01;\r\n/* Const: iqrf.embed.uart.DpaBaud_4800\r\n*/\r\niqrf.embed.uart.DpaBaud_4800 = 0x02;\r\n/* Const: iqrf.embed.uart.DpaBaud_9600\r\n*/\r\niqrf.embed.uart.DpaBaud_9600 = 0x03;\r\n/* Const: iqrf.embed.uart.DpaBaud_19200\r\n*/\r\niqrf.embed.uart.DpaBaud_19200 = 0x04;\r\n/* Const: iqrf.embed.uart.DpaBaud_38400\r\n*/\r\niqrf.embed.uart.DpaBaud_38400 = 0x05;\r\n/* Const: iqrf.embed.uart.DpaBaud_57600\r\n*/\r\niqrf.embed.uart.DpaBaud_57600 = 0x06;\r\n/* Const: iqrf.embed.uart.DpaBaud_115200\r\n*/\r\niqrf.embed.uart.DpaBaud_115200 = 0x07;\r\n/* Const: iqrf.embed.uart.DpaBaud_230400\r\n*/\r\niqrf.embed.uart.DpaBaud_230400 = 0x08;\r\n\r\n// --------------\r\n/* Function: iqrf.embed.uart.Open_Request\r\nEncodes DPA request to open UART peripheral.\r\n\r\nParameters:\r\n  baudRate - number: BaudRate value. See iqrf.embed.uart.DpaBaud_??? constants.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.uart.Open_Request = function ( baudRate )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_UART, '00', iqrf.ToHexStringByte( baudRate ) );\r\n};\r\n\r\n/* Function: iqrf.embed.uart.Open_Response\r\nDecodes DPA response from opening UART peripheral\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.uart.Open_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_UART, '80', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.uart.Close_Request\r\nEncodes DPA request to close UART peripheral.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.uart.Close_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_UART, '01' );\r\n};\r\n\r\n/* Function: iqrf.embed.uart.Close_Response\r\nDecodes DPA response from closing UART peripheral.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n*/\r\niqrf.embed.uart.Close_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_UART, '81', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.uart.WriteRead_Request\r\nEncodes DPA request to write and/or read data to/from UART peripheral.\r\n\r\nParameters:\r\n  readTimeout - number: \r\n  writtenData - array: Array of bytes.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.uart.WriteRead_Request = function ( readTimeout, writtenData )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_UART, '02', iqrf.ToHexStringByte( readTimeout ) + iqrf.BytesToHexStringBytesArray( writtenData, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.uart.WriteRead_Response\r\nDecodes DPA response from writing and/or reading data to/from UART peripheral.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  Read data.\r\n*/\r\niqrf.embed.uart.WriteRead_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_UART, '82' );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.uart.ClearWriteRead_Request\r\nEncodes DPA request to clear rx buffer and then write and/or read data to/from UART peripheral.\r\n\r\nParameters:\r\n  readTimeout - number: \r\n  writtenData - array: Array of bytes.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.uart.ClearWriteRead_Request = function ( readTimeout, writtenData )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_UART, '03', iqrf.ToHexStringByte( readTimeout ) + iqrf.BytesToHexStringBytesArray( writtenData, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.uart.ClearWriteRead_Response\r\nDecodes DPA response from clearing rx buffer and writing and/or reading data to/from UART peripheral.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  array: Read data.\r\n*/\r\niqrf.embed.uart.ClearWriteRead_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_UART, '83' );\r\n};\r\n\r\n//############################################################################################\r\n", "name": "Embed: UART", "notes": "Initial release", "standardID": 12, "version": 0.0, "versionFlags": 0}, {"driver": "//############################################################################################\r\n\r\n/* Title: Embedded FRC peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x0D,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.frc\r\n// All prepared DPA requests have nadr set to '00'.\r\nnamespace( 'iqrf.embed.frc' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.frc.Send_Request\r\nEncodes DPA request to send a FRC command\r\n\r\nParameters:\r\n  frcCommand - number: Specifies data to be collected. \r\n  userData - array: User data.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.frc.Send_Request = function ( frcCommand, userData )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_FRC, '00', iqrf.ToHexStringByte( frcCommand ) + iqrf.BytesToHexStringBytesArray( userData, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.frc.Send_Response\r\nDecodes DPA response from sending a FRC command. It also handles response from iqrf.embed.frc.SendSelective_Request.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  object: Object with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide/ for details):\r\n\r\n* status - number\r\n* frcData - array\r\n*/\r\niqrf.embed.frc.Send_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_FRC, '80.82', -2 );\r\n\r\n  var result =\r\n  {\r\n    status: responseData[0],\r\n    frcData: responseData.slice( 1, responseData.length )\r\n  };\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.frc.ExtraResult_Request\r\nEncodes DPA request to read remaining bytes of the FRC result.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.frc.ExtraResult_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_FRC, '01' );\r\n};\r\n\r\n/* Function: iqrf.embed.frc.ExtraResult_Response\r\nDecodes DPA response from reading remaining bytes of the FRC result.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  array: Remaining FRC data.\r\n*/\r\niqrf.embed.frc.ExtraResult_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_FRC, '81', -1 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.frc.SendSelective_Request\r\nEncodes DPA request to send a selective FRC command.\r\n\r\nParameters:\r\n  frcCommand - number: Specifies data to be collected.\r\n  selectedNodes - array: Array if integer values corresponding to the selected nodes.\r\n  userData - array: User data.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.frc.SendSelective_Request = function ( frcCommand, selectedNodes, userData )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_FRC, '02',\r\n    iqrf.ToHexStringByte( frcCommand ) +\r\n    iqrf.BytesToHexStringBytesArray( iqrf.IndexesToBitmap( selectedNodes, 30 ), true ) +\r\n    iqrf.BytesToHexStringBytesArray( userData, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.frc.SendSelective_Response\r\nDecodes DPA response from sending a selective FRC command.  It also handles response from iqrf.embed.frc.Send_Request.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  Object with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide/ for details):\r\n\r\n* status - number\r\n* frcData - array\r\n*/\r\niqrf.embed.frc.SendSelective_Response = function ( response )\r\n{\r\n  return iqrf.embed.frc.Send_Response( response );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.frc.SetParams_Request\r\nEncodes DPA request to set global FRC parameters.\r\n\r\nParameters:\r\n  frcResponseTime - number: See DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.frc.SetParams_Request = function ( frcResponseTime )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_FRC, '03', iqrf.ToHexStringByte( frcResponseTime ) );\r\n};\r\n\r\n/* Function: iqrf.embed.frc.SetParams_Response\r\nDecodes DPA response from setting global FRC parameters.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  number: Previous FRCresponseTime value. \r\n*/\r\niqrf.embed.frc.SetParams_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_FRC, '83', 1 );\r\n  return responseData[0];\r\n};\r\n\r\n/* Function: iqrf.embed.frc.ParseResponses\r\nDecodes DPA responses returned by iqrf.embed.frc.Send[Selective]_Response and iqrf.embed.frc.ExtraResult_Response\r\n\r\nParameters:\r\n  frcCommand - number: FRC command passed to iqrf.embed.frc.Send[Selective]_Request\r\n  sendResponse - object: Return value from iqrf.embed.frc.Send[Selective]_Response\r\n  extraResultResponse - array: [optional] Return value from iqrf.embed.frc.ExtraResult_Response. For smaller networks extra FRC result might not be needed.\r\n\r\nReturns:\r\n  array: Based on the FRC command the items of the array are 2 bits, 1 byte or 2 bytes numbers. Only indexes of the array of the Nodes that returned non-zero value are filled in.\r\n\r\n\r\n--- Text\r\nExample:\r\n\r\n* Input\r\n// Both sendResponse.frcData[] and extraResultResponse full of 0s except:\r\nsendResponse.frcData[2]  = 6\r\nsendResponse.frcData[34] = 2\r\n\r\n* Result\r\n// for 2 bits FRC command\r\n{\r\n  \"17\": 3,\r\n  \"18\": 1\r\n}\r\n\r\n// for 1 byte FRC command\r\n{\r\n  \"2\": 6,\r\n  \"34\": 2\r\n}\r\n\r\n// for 2 bytes FRC command\r\n{\r\n  \"1\": 6,\r\n  \"17\": 2\r\n}\r\n---\r\n*/\r\niqrf.embed.frc.ParseResponses = function ( frcCommand, sendResponse, extraResultResponse )\r\n{\r\n  if ( frcCommand < 0 || frcCommand > 0xff )\r\n    throw new Error( 'iqrf.embed.frc.ParseResponses: Parameter frcCommand = ' + frcCommand + ' is out of range.' );\r\n\r\n  var frcData;\r\n  if ( extraResultResponse !== undefined )\r\n    frcData = sendResponse.frcData.concat( extraResultResponse );\r\n  else\r\n    frcData = sendResponse.frcData;\r\n\r\n  var result = [];\r\n\r\n  var frcData_length = frcData.length;\r\n  if ( frcCommand <= 0x7F )\r\n  {\r\n    // 2 bits FRC\r\n    for ( var index = 1; index <= 239; index++ )\r\n    {\r\n      var mask = 1 << ( index % 8 );\r\n      var valueIndex = Math.floor( index / 8 );\r\n\r\n      if ( ( valueIndex + 32 ) >= frcData_length )\r\n        break;\r\n\r\n      var frcValue = 0;\r\n      if ( ( frcData[valueIndex] & mask ) !== 0 )\r\n        frcValue = 0x01;\r\n\r\n      if ( ( frcData[valueIndex + 32] & mask ) !== 0 )\r\n        frcValue |= 0x02;\r\n\r\n      if ( frcValue !== 0 )\r\n        result[index] = frcValue;\r\n    }\r\n  }\r\n  else if ( frcCommand <= 0xDF )\r\n    // 1 byte FRC\r\n    for ( var byteIndex = 0; byteIndex < frcData_length; byteIndex++ )\r\n    {\r\n      var frcValue1B = frcData[byteIndex];\r\n      if ( frcValue1B !== 0 )\r\n        result[byteIndex] = frcValue1B;\r\n    }\r\n  else if ( frcCommand <= 0xF7 )\r\n    // 2 bytes FRC\r\n    for ( var byte2index = 2; byte2index < frcData_length - 1; byte2index += 2 )\r\n    {\r\n      var frcValue2B = frcData[byte2index] + ( frcData[byte2index + 1] * 0x100 );\r\n      if ( frcValue2B !== 0 )\r\n        result[byte2index / 2] = frcValue2B;\r\n    }\r\n  else\r\n    // 4 bytes FRC\r\n    for ( var byte4index = 4; byte4index < frcData_length - 3; byte4index += 4 )\r\n    {\r\n      var frcValue4B = frcData[byte4index] + ( frcData[byte4index + 1] * 0x100 ) + ( frcData[byte4index + 2] * 0x10000 ) + ( frcData[byte4index + 3] * 0x1000000 );\r\n      if ( frcValue4B !== 0 )\r\n        result[byte4index / 4] = frcValue4B;\r\n    }\r\n\r\n  return result;\r\n};\r\n\r\n//############################################################################################\r\n", "name": "Embed: FRC", "notes": "Initial release", "standardID": 13, "version": 0.0, "versionFlags": 0}, {"driver": "//############################################################################################\r\n\r\n/* Title: Embedded DPA exploration driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0xFF,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        '1st line',\r\n        '2nd line' ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.explore\r\nnamespace( 'iqrf.embed.explore' );\r\n\r\n/* Function: iqrf.embed.explore.Enumerate_Request\r\nEncodes DPA request to enumerate DPA peripherals.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.explore.Enumerate_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_Enumeration, '3f' );\r\n};\r\n\r\n/* Function: iqrf.embed.explore.Enumerate_Response\r\nDecodes DPA response from enumerating DPA peripherals.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  object: Object with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide/ for details):\r\n\r\n* dpaVer\r\n* perNr\r\n* embeddedPers\r\n* hwpid\r\n* hwpidVer\r\n* flags\r\n* userPer\r\n*/\r\niqrf.embed.explore.Enumerate_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Enumeration, 'bf', -12 );\r\n  var result =\r\n    {\r\n      dpaVer: responseData[0] + ( responseData[1] * 0x100 ),\r\n      perNr: responseData[2],\r\n      embeddedPers: iqrf.BitmapToIndexes( responseData, 3, 6 ),\r\n      hwpid: responseData[7] + ( responseData[8] * 0x100 ),\r\n      hwpidVer: responseData[9] + ( responseData[10] * 0x100 ),\r\n      flags: responseData[11],\r\n      userPer: iqrf.BitmapToIndexes( responseData, 12, responseData.length - 1, 0x20 )\r\n    };\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.embed.explore.PeripheralInformation_Request\r\nEncodes DPA request to get information about a peripheral.\r\n\r\nParameters:\r\n  per - number: Peripheral to get information about.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.explore.PeripheralInformation_Request = function ( per )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.ToHexStringByte( per ), '3f' );\r\n};\r\n\r\n/* Function: iqrf.embed.explore.PeripheralInformation_Response\r\nDecodes DPA response from getting information about a peripheral.\r\n\r\nParameters:\r\n  per - number: Peripheral the information is about.\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  object: Object with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide/ for details):\r\n\r\n* perTe - number:\r\n* perT - number:\r\n* par1 - number:\r\n* par2 - number:\r\n*/\r\niqrf.embed.explore.PeripheralInformation_Response = function ( per, response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.ToHexStringByte( per ), 'bf', 4 );\r\n  var result =\r\n    {\r\n      perTe: responseData[0],\r\n      perT: responseData[1],\r\n      par1: responseData[2],\r\n      par2: responseData[3]\r\n    };\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.embed.explore.MorePeripheralsInformation_Request\r\nEncodes DPA request to get information about more peripherals.\r\n\r\nParameters:\r\n  per - number: 1st peripheral to get information about.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.embed.explore.MorePeripheralsInformation_Request = function ( per )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( 'ff', iqrf.ToHexStringByte( per ) );\r\n};\r\n\r\n/* Function: iqrf.embed.explore.MorePeripheralsInformation_Response\r\nDecodes DPA response from getting information about more peripherals.\r\n\r\nParameters:\r\n  per - number: 1st peripheral the information is about.\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  array: Array of objects with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide/ for details):\r\n\r\n* perTe - number:\r\n* perT - number:\r\n* par1 - number: \r\n* par2 - number: \r\n*/\r\niqrf.embed.explore.MorePeripheralsInformation_Response = function ( per, response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, 'ff', iqrf.ToHexStringByte( parseInt( per, 16 ) | 0x80 ) );\r\n\r\n  var result = [];\r\n  var responseData_length = responseData.length;\r\n  for ( var index = 0; index < responseData_length; index += 4 )\r\n    result[result.length] =\r\n      {\r\n        perTe: responseData[index + 0],\r\n        perT: responseData[index + 1],\r\n        par1: responseData[index + 2],\r\n        par2: responseData[index + 3]\r\n      };\r\n\r\n  return result;\r\n};\r\n\r\n//############################################################################################\r\n", "name": "Embed: DPA Exploration", "notes": "1st line\n2nd line", "standardID": 255, "version": 0.0, "versionFlags": 0}]}