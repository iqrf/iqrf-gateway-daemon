{"driver": "//############################################################################################\r\n\r\n/* Title: IQRF Standards Sensor driver\r\nSee also: <https://www.iqrfalliance.org/techDocs/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x5E,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 15, 'Notes' : [\r\n        '+ New quantities added (TimeSpan, Illuminance, NO2 (nitrogen dioxide), SO2 (sulfur dioxide), CO (carbon monoxide), O3 (ozone), Atmospheric Pressure, Color Temperature, TimeSpanLong, UV Index, Sound Pressure Level, Particulates PM2.5, Data Block, Altitude, Acceleration, pH, Ammonia, Methane ).',\r\n        '+ 4 bytes FRC added.',\r\n        '! Fixed negative numbers calculation for signed quantities.' ,\r\n        '! Fixed computation of Earth\u2019s Magnetic Field value.' ,\r\n        '+ Error sensor values detected and returned as NaN.',\r\n        '+ Sensor enumeration gives list of supported FRC commands.',\r\n        '+ iqrf.sensor.Frc* functions added.' ,\r\n        '+ Optional parameter writtenData at iqrf.sensor.ReadSensorsWithTypes_Request.' ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.sensor\r\nnamespace( 'iqrf.sensor' );\r\n\r\n// IQRF Standards Sensor PNUM value\r\niqrf.sensor.PNUM = '5e';\r\n\r\n// IQRF Sensor standard peripheral - sensor types\r\n// 2 bytes\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE\r\nTemperature sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE = 0x01;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_CO2\r\nCarbon dioxide sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_CO2 = 0x02;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_VOC\r\nVolatile organic compounds sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_VOC = 0x03;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE\r\nExtra-low voltage sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE = 0x04;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD\r\nEarth\u2019s magnetic field sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD = 0x05;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE\r\nLow voltage sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE = 0x06;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_CURRENT\r\nCurrent sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_CURRENT = 0x07;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_POWER\r\nPower sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_POWER = 0x08;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY\r\nMains frequency sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY = 0x09;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN\r\nTimespan value.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_TIMESPAN = 0x0A;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE\r\nIlluminance sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE = 0x0B;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_NO2\r\nNitrogen dioxide sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_NO2 = 0x0C;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_SO2\r\nSulfur dioxide sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_SO2 = 0x0D;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_CO\r\nCarbon monoxide sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_CO = 0x0E;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_O3\r\nOzone sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_O3 = 0x0F;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE\r\nAtmospheric pressure sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE = 0x10;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE\r\nColor temperature sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE = 0x11;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_PARTICULATES_PM25\r\nParticulates PM2.5 sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_PARTICULATES_PM25 = 0x12;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_SOUND_PRESSURE_LEVEL\r\nSound pressure level sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_SOUND_PRESSURE_LEVEL = 0x13;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_ALTITUDE\r\nAltitude sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_ALTITUDE = 0x14;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_ACCELERATION\r\nAcceleration sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_ACCELERATION = 0x15;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_NH3\r\nAmmonia sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_NH3 = 0x16;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_METHANE\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_METHANE = 0x17;\r\n\r\n//  1 byte\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY\r\nRelative humidity sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY = 0x80;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7\r\n7 bits binary data sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7 = 0x81;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR\r\nPower factor sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR = 0x82;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_UV_INDEX\r\nUV index sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_UV_INDEX = 0x83;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_PH\r\npH sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_PH = 0x84;\r\n\r\n//  4 bytes\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30\r\n30 bits binary data sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30 = 0xA0;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_CONSUMPTION\r\nConsumption sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_CONSUMPTION = 0xA1;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_DATETIME\r\nDate and time vallue.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_DATETIME = 0xA2;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN_LONG\r\nLong timespan value.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_TIMESPAN_LONG = 0xA3;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_LATITUDE\r\nLatitude value.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_LATITUDE = 0xA4;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_LONGITUDE\r\nLongitude value.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_LONGITUDE = 0xA5;\r\n\r\n//  Multiple bytes\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_DATA_BLOCK\r\nData block containing proprietary data.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_DATA_BLOCK = 0xC0;\r\n\r\n// FRC commands\r\n/* Const: iqrf.sensor.STD_SENSOR_FRC_2BITS\r\nFRC command to return 2-bits sensor data of the supporting sensor types.\r\n*/\r\niqrf.sensor.STD_SENSOR_FRC_2BITS = 0x10;\r\n/* Const: iqrf.sensor.STD_SENSOR_FRC_1BYTE\r\nFRC command to return 1-byte wide sensor data of the supporting sensor types. \r\n*/\r\niqrf.sensor.STD_SENSOR_FRC_1BYTE = 0x90;\r\n/* Const: iqrf.sensor.STD_SENSOR_FRC_2BYTES\r\nFRC command to return 2-bytes wide sensor data of the supporting sensor types.\r\n*/\r\niqrf.sensor.STD_SENSOR_FRC_2BYTES = 0xE0;\r\n/* Const: iqrf.sensor.STD_SENSOR_FRC_4BYTES\r\nFRC command to return 4-bytes wide sensor data of the supporting sensor types.\r\n*/\r\niqrf.sensor.STD_SENSOR_FRC_4BYTES = 0xF9;\r\n\r\n// Sensor types\r\niqrf.sensor.SensorTypes = [];\r\n// 2 bytes\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE] =\r\n  {\r\n    id: 'TEMPERATURE',\r\n    name: 'Temperature',\r\n    shortName: 'T',\r\n    unit: '\u00b0C',\r\n    decimalPlaces: 4,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE, iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_CO2] =\r\n  {\r\n    id: 'CO2',\r\n    name: 'Carbon dioxide',\r\n    shortName: 'CO2',\r\n    unit: 'ppm',\r\n    decimalPlaces: 0,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE, iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_VOC] =\r\n  {\r\n    id: 'VOC',\r\n    name: 'Volatile organic compound',\r\n    shortName: 'VOC',\r\n    unit: 'ppm',\r\n    decimalPlaces: 0,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE, iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE] =\r\n  {\r\n    id: 'EXTRA_LOW_VOLTAGE',\r\n    name: 'Extra-low voltage',\r\n    shortName: 'U',\r\n    unit: 'V',\r\n    decimalPlaces: 3,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD] =\r\n  {\r\n    id: 'EARTHS_MAGNETIC_FIELD',\r\n    name: 'Earth\u2019s magnetic field',\r\n    shortName: 'B',\r\n    unit: 'T',\r\n    decimalPlaces: 7,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE] =\r\n  {\r\n    id: 'LOW_VOLTAGE',\r\n    name: 'Low voltage',\r\n    shortName: 'U',\r\n    unit: 'V',\r\n    decimalPlaces: 4,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_CURRENT] =\r\n  {\r\n    id: 'CURRENT',\r\n    name: 'Current',\r\n    shortName: 'I',\r\n    unit: 'A',\r\n    decimalPlaces: 3,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_POWER] =\r\n  {\r\n    id: 'POWER',\r\n    name: 'Power',\r\n    shortName: 'E',\r\n    unit: 'W',\r\n    decimalPlaces: 2,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY] =\r\n  {\r\n    id: 'MAINS_FREQUENCY',\r\n    name: 'Mains frequency',\r\n    shortName: 'f',\r\n    unit: 'Hz',\r\n    decimalPlaces: 3,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN] =\r\n  {\r\n    id: 'TIMESPAN',\r\n    name: 'Timespan',\r\n    shortName: 't',\r\n    unit: 's',\r\n    decimalPlaces: 0,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE] =\r\n  {\r\n    id: 'ILLUMINANCE',\r\n    name: 'Illuminance',\r\n    shortName: 'Ev',\r\n    unit: 'lx',\r\n    decimalPlaces: 0,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_NO2] =\r\n  {\r\n    id: 'NO2',\r\n    name: 'Nitrogen dioxide',\r\n    shortName: 'NO2',\r\n    unit: 'ppm',\r\n    decimalPlaces: 3,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_SO2] =\r\n  {\r\n    id: 'SO2',\r\n    name: 'Sulfur dioxide',\r\n    shortName: 'SO2',\r\n    unit: 'ppm',\r\n    decimalPlaces: 3,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_CO] =\r\n  {\r\n    id: 'CO',\r\n    name: 'Carbon monoxide',\r\n    shortName: 'CO',\r\n    unit: 'ppm',\r\n    decimalPlaces: 2,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_O3] =\r\n  {\r\n    id: 'O3',\r\n    name: 'Ozone',\r\n    shortName: 'O3',\r\n    unit: 'ppm',\r\n    decimalPlaces: 4,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE] =\r\n  {\r\n    id: 'ATMOSPHERIC_PRESSURE',\r\n    name: 'Atmospheric pressure',\r\n    shortName: 'p',\r\n    unit: 'hPa',\r\n    decimalPlaces: 4,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE] =\r\n  {\r\n    id: 'COLOR_TEMPERATURE',\r\n    name: 'Color temperature',\r\n    shortName: 'Tc',\r\n    unit: 'K',\r\n    decimalPlaces: 0,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_PARTICULATES_PM25] =\r\n  {\r\n    id: 'PARTICULATES_PM25',\r\n    name: 'Particulates PM2.5',\r\n    shortName: 'PM2.5',\r\n    unit: '\u00b5g/m3',\r\n    decimalPlaces: 2,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_SOUND_PRESSURE_LEVEL] =\r\n  {\r\n    id: 'SOUND_PRESSURE_LEVEL',\r\n    name: 'Sound pressure level',\r\n    shortName: 'Lp',\r\n    unit: 'dB',\r\n    decimalPlaces: 4,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_ALTITUDE] =\r\n  {\r\n    id: 'ALTITUDE',\r\n    name: 'Altitude',\r\n    shortName: 'h',\r\n    unit: 'm',\r\n    decimalPlaces: 2,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_ACCELERATION] =\r\n  {\r\n    id: 'ACCELERATION',\r\n    name: 'Acceleration',\r\n    shortName: 'a',\r\n    unit: 'm/s2',\r\n    decimalPlaces: 8,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_NH3] =\r\n  {\r\n    id: 'NH3',\r\n    name: 'Ammonia',\r\n    shortName: 'NH3',\r\n    unit: 'ppm',\r\n    decimalPlaces: 1,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_METHANE] =\r\n  {\r\n    id: 'METHANE',\r\n    name: 'Methane',\r\n    shortName: 'CH4',\r\n    unit: '%',\r\n    decimalPlaces: 3,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\n\r\n// 1 byte\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY] =\r\n  {\r\n    id: 'RELATIVE_HUMIDITY',\r\n    name: 'Relative humidity',\r\n    shortName: 'RH',\r\n    unit: '%',\r\n    decimalPlaces: 1,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7] =\r\n  {\r\n    id: 'BINARYDATA7',\r\n    name: 'Binary data7',\r\n    shortName: 'bin7',\r\n    unit: '?',\r\n    decimalPlaces: 0,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BITS, iqrf.sensor.STD_SENSOR_FRC_1BYTE]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR] =\r\n  {\r\n    id: 'POWER_FACTOR',\r\n    name: 'Power factor',\r\n    shortName: 'cos ?',\r\n    unit: '',\r\n    decimalPlaces: 3,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_UV_INDEX] =\r\n  {\r\n    id: 'UV_INDEX',\r\n    name: 'UV index',\r\n    shortName: 'UV',\r\n    unit: '',\r\n    decimalPlaces: 3,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_PH] =\r\n  {\r\n    id: 'PH',\r\n    name: 'pH',\r\n    shortName: 'pH',\r\n    unit: '',\r\n    decimalPlaces: 4,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE]\r\n  };\r\n\r\n// 4 bytes\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30] =\r\n  {\r\n    id: 'BINARYDATA30',\r\n    name: 'Binary data30',\r\n    shortName: 'bin30',\r\n    unit: '?',\r\n    decimalPlaces: 0,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES, iqrf.sensor.STD_SENSOR_FRC_4BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_CONSUMPTION] =\r\n  {\r\n    id: 'CONSUMPTION',\r\n    name: 'Consumption',\r\n    shortName: 'E',\r\n    unit: 'Wh',\r\n    decimalPlaces: 0,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_4BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_DATETIME] =\r\n  {\r\n    id: 'DATETIME',\r\n    name: 'DateTime',\r\n    shortName: 'DateTime',\r\n    unit: '',\r\n    decimalPlaces: 0,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_4BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN_LONG] =\r\n  {\r\n    id: 'TIMESPAN_LONG',\r\n    name: 'Timespan long',\r\n    shortName: 't',\r\n    unit: 's',\r\n    decimalPlaces: 4,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_4BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_LATITUDE] =\r\n  {\r\n    id: 'LATITUDE',\r\n    name: 'Latitude',\r\n    shortName: 'LAT',\r\n    unit: '\u00b0',\r\n    decimalPlaces: 7,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_4BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_LONGITUDE] =\r\n  {\r\n    id: 'LONGITUDE',\r\n    name: 'Longitude',\r\n    shortName: 'LONG',\r\n    unit: '\u00b0',\r\n    decimalPlaces: 7,\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_4BYTES]\r\n  };\r\n\r\n// Multiple bytes\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_DATA_BLOCK] =\r\n  {\r\n    id: 'DATA_BLOCK',\r\n    name: 'Data block',\r\n    shortName: 'datablock',\r\n    unit: '?',\r\n    decimalPlaces: 0,\r\n    frcs: []\r\n  };\r\n\r\n/* Function: iqrf.sensor.Enumerate_Request\r\nEncodes DPA request to enumerate sensors.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.sensor.Enumerate_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.sensor.PNUM, '3e' );\r\n};\r\n\r\n/* Function: iqrf.sensor.Enumerate_Response\r\nDecodes DPA response from sensor enumeration.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n\r\nReturns:\r\n  array: Array of objects describing each sensor. The object has the following fields:\r\n\r\n* id - string: Value type as \"identifier\" text.\r\n* type - number: Value type of the sensor (quantity). See IQRF Sensor standard for details.\r\n* name - string: Name of the sensor (quantity).\r\n* shortName - string: Short name of the sensor (quantity). Typically it is a symbol used at physics.\r\n* unit - string: Unit of the quantity. Dimensionless quantity has empty string \"\".\r\n* decimalPlaces - number: Number of valid decimal places.\r\n* frcs - array: Array of FRC commands supported by the sensor.\r\n* breakdown - array: [optional] see <iqrf.sensor.ReadSensorsWithTypes_Response> for more information.\r\n*/\r\niqrf.sensor.Enumerate_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.sensor.PNUM, 'be', -1 );\r\n\r\n  var result = [];\r\n  for ( var index in responseData )\r\n  {\r\n    var sensorType = responseData[index];\r\n    var sensorObj = iqrf.sensor.SensorTypes[sensorType];\r\n    if ( sensorObj === undefined )\r\n      throw new Error( 'iqrf.sensor.Enumerate_Response: Unknown sensor type ' + sensorType );\r\n\r\n    var sensorOut =\r\n    {\r\n      id: sensorObj.id,\r\n      type: sensorType,\r\n      name: sensorObj.name,\r\n      shortName: sensorObj.shortName,\r\n      unit: sensorObj.unit,\r\n      decimalPlaces: sensorObj.decimalPlaces,\r\n      frcs: sensorObj.frcs\r\n    };\r\n\r\n    var sensorOutIndex = result.length;\r\n    result[sensorOutIndex] = sensorOut;\r\n\r\n    if ( iqrf.sensor.FinalizeSensor !== undefined )\r\n      iqrf.sensor.FinalizeSensor( sensorOut, sensorOutIndex );\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\niqrf.sensor.Indexes2bitmap = function ( sensorIndexes )\r\n{\r\n  var bitmap = 0;\r\n  for ( var index in sensorIndexes )\r\n    bitmap |= 1 << sensorIndexes[index];\r\n\r\n  return iqrf.IntToHexStringBytesArray( bitmap, 4 );\r\n};\r\n\r\n/* Function: iqrf.sensor.ReadSensorsWithTypes_Request\r\nEncodes DPA request to read sensors values.\r\n\r\nParameters:\r\n  sensorIndexes - Specifies sensors to read data from:\r\n\r\n* undefined: Missing parameter: reads 1st sensor.\r\n* number: -1: reads all sensors.\r\n* array: array of indexes: specifies sensors to read.\r\n  \r\n  writtenData - array: [optional] array of 5-bytes-arrays (for each sensor). See IQRF Sensor standards for details.\r\n\r\nReturns:\r\n  iqrf.DpaRawHdpMessage: DPA request object.\r\n*/\r\niqrf.sensor.ReadSensorsWithTypes_Request = function ( sensorIndexes, writtenData )\r\n{\r\n  var result = new iqrf.DpaRawHdpMessage( iqrf.sensor.PNUM, '01' );\r\n  if ( sensorIndexes !== undefined )\r\n  {\r\n    if ( sensorIndexes === -1 )\r\n      result.rdata = 'ff.ff.ff.ff';\r\n    else\r\n      result.rdata = iqrf.sensor.Indexes2bitmap( sensorIndexes );\r\n  }\r\n\r\n  if ( writtenData !== undefined )\r\n  {\r\n    var writtenData_length = writtenData.length;\r\n    for ( var index = 0; index < writtenData_length; index++ )\r\n    {\r\n      var oneData = writtenData[index];\r\n      if ( oneData.length !== 5 )\r\n        throw new Error( 'iqrf.sensor.ReadSensorsWithTypes_Request: Written data item length is not 5 but ' + oneData.length );\r\n\r\n      result.rdata += iqrf.BytesToHexStringBytesArray( oneData, true );\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.sensor.ReadSensorsWithTypes_Response\r\nDecodes DPA response from sensor value reading.\r\n\r\nParameters:\r\n  response - iqrf.DpaRawHdpMessage: DPA response object.\r\n  request - string: [optional] request used to generate specified \"response\" parameter. It is a return value from <iqrf.sensor.ReadSensorsWithTypes_Request>. Although this parameter is optional it is needed for breakdown of the \"anonymous\" sensor types \"Binary Data7\", \"Binary Data30\" and \"Data Block\" by the product specific driver. Please see <iqrf.sensor.FinalizeSensor> for more information.\r\n\r\nReturns:\r\n  array: Array of objects for every read sensor. The object has the following fields:\r\n\r\n* id - string: Value type as \"identifier\" text.\r\n* type - number: Value type of the sensor (quantity). See IQRF Sensor standard for details.\r\n* name - string: Name of the sensor (quantity).\r\n* shortName - string: Short name of the sensor (quantity). Typically it is a symbol used at physics.\r\n* value - number: Value of the sensor. It equals to NaN to indicate an error value.\r\n* unit - string: Unit of the quantity. Dimensionless quantity has empty string \"\".\r\n* decimalPlaces - number: Number of valid decimal places.\r\n* breakdown - array: [optional] See <iqrf.sensor.FinalizeSensor> for more information.\r\n\r\nExample:\r\n--- Text\r\n[\r\n  {\r\n    \"id\" : \"TEMPERATURE\",\r\n    \"type\": 1,\r\n    \"name\": \"Temperature\",\r\n    \"shortName\": \"T\",\r\n    \"value\": 22.3,\r\n    \"unit\": \"\u00b0C\",\r\n    \"decimalPlaces\": 4\r\n  },\r\n  {\r\n    \"id\" : \"RELATIVE_HUMIDITY\",\r\n    \"type\": 128,\r\n    \"name\": \"Relative humidity\",\r\n    \"shortName\": \"RH\",\r\n    \"value\": 35,\r\n    \"unit\": \"%\",\r\n    \"decimalPlaces\": 1\r\n  },\r\n  {\r\n    \"id\" : \"MAINS_FREQUENCY\",\r\n    \"type\": 9,\r\n    \"name\": \"Mains frequency\",\r\n    \"shortName\": \"f\",\r\n    \"value\": 49.98,\r\n    \"unit\": \"Hz\", 3,\r\n    \"decimalPlaces\": 4\r\n  },\r\n  {\r\n    \"id\" : \"BINARYDATA7\",\r\n    \"type\": 129,\r\n    \"name\": \"Binary data7\",\r\n    \"shortName\": \"bin7\",\r\n    \"value\": 88,\r\n    \"unit\": \"?\",\r\n    \"decimalPlaces\": 0,\r\n    \"breakdown\":\r\n    [\r\n      {\r\n        \"id\" : \"BINARYDATA7\",\r\n        \"type\": 129,\r\n        \"name\": \"Potentiometer\",\r\n        \"shortName\": \"pot\",\r\n        \"value\": 30.7,\r\n        \"unit\": \"%\",\r\n        \"decimalPlaces\": 1\r\n      }\r\n    ]\r\n  }\r\n]\r\n---\r\n*/\r\niqrf.sensor.ReadSensorsWithTypes_Response = function ( response, request )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.sensor.PNUM, '81' );\r\n\r\n  if ( request !== undefined )\r\n  {\r\n    var requestData = iqrf.ParseStringBytes( request.rdata );\r\n    var RequestedIndexes = iqrf.BitmapToIndexes( requestData, 0, 3 );\r\n    // If no sensor was requested, then actually the 1st was requested\r\n    if ( RequestedIndexes.length === 0 )\r\n      RequestedIndexes[0] = 0;\r\n  }\r\n\r\n  var result = [];\r\n  var responseData_length = responseData.length;\r\n  for ( var index = 0; index < responseData_length; )\r\n  {\r\n    var sensorType = responseData[index++];\r\n    var sensorObj = iqrf.sensor.SensorTypes[sensorType];\r\n    if ( sensorObj === undefined )\r\n      throw new Error( 'iqrf.sensor.ReadSensorsWithTypes_Response: Unknown sensor type ' + sensorType );\r\n\r\n    var sensorValue;\r\n\r\n    switch ( sensorType )\r\n    {\r\n      default:\r\n        throw new Error( 'iqrf.sensor.ReadSensorsWithTypes_Response: Unimplemented sensor type value ' + sensorType );\r\n\r\n      // 2 bytes\r\n      // ----------------\r\n      case iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : iqrf.UInt16toInt16( sensorValue ) / 16.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 16.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_CO2:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_VOC:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        if ( sensorValue === 0x8000 )\r\n          sensorValue = NaN;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        if ( sensorValue === 0xFfFf )\r\n          sensorValue = NaN;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_CURRENT:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : iqrf.UInt16toInt16( sensorValue ) / 1000.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_NO2:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_SO2:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_METHANE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 1000.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : iqrf.UInt16toInt16( sensorValue ) / 10000000.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_POWER:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 4.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_CO:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 100.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_O3:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 10000.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_PARTICULATES_PM25:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : sensorValue / 4.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_SOUND_PRESSURE_LEVEL:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : sensorValue / 16.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_ALTITUDE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 4.0 - 1024.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_ACCELERATION:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : iqrf.UInt16toInt16( sensorValue ) / 256.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_NH3:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 10.0;\r\n        break;\r\n\r\n      // 1 byte\r\n      // ----------------\r\n      case iqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY:\r\n        sensorValue = responseData[index] === 0xEE ? NaN : ( responseData[index] / 2.0 );\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7:\r\n        sensorValue = ( responseData[index] & 0x80 ) !== 0 ? NaN : responseData[index];\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR:\r\n        sensorValue = responseData[index] === 0xEE ? NaN : responseData[index] / 200.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_UV_INDEX:\r\n        sensorValue = responseData[index] === 0xFF ? NaN : responseData[index] / 8.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_PH:\r\n        sensorValue = responseData[index] === 0xFF ? NaN : responseData[index] / 16.0;\r\n        break;\r\n\r\n      // 4 bytes\r\n      // ----------------\r\n      case iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30:\r\n        sensorValue = ( responseData[index + 3] & 0x80 ) !== 0 ? NaN : ( responseData[index] + ( responseData[index + 1] * 0x100 ) + ( responseData[index + 2] * 0x10000 ) + ( responseData[index + 3] * 0x1000000 ) );\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_CONSUMPTION:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 ) + ( responseData[index + 2] * 0x10000 ) + ( responseData[index + 3] * 0x1000000 );\r\n        if ( sensorValue === 0xFfFfFfFf )\r\n          sensorValue = NaN;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_DATETIME:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 ) + ( responseData[index + 2] * 0x10000 ) + ( responseData[index + 3] * 0x1000000 );\r\n        if ( sensorValue === 0xFfFfFfFf )\r\n          sensorValue = NaN;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN_LONG:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 ) + ( responseData[index + 2] * 0x10000 ) + ( responseData[index + 3] * 0x1000000 );\r\n        sensorValue = sensorValue === 0xFfFfFfFf ? NaN : sensorValue / 16.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_LATITUDE:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_LONGITUDE:\r\n        if ( responseData[index + 3] === 0xFF || ( responseData[index + 2] & 0x40 ) === 0x00 )\r\n          sensorValue = NaN;\r\n        else\r\n        {\r\n          sensorValue = responseData[index + 3] + ( ( responseData[index + 2] & 0x3F ) + ( responseData[index] + ( responseData[index + 1] * 0x100 ) ) / 10000 ) / 60;\r\n          if ( ( responseData[index + 2] & 0x80 ) !== 0x00 )\r\n            sensorValue = -sensorValue;\r\n        }\r\n        break;\r\n\r\n      // Multiple bytes\r\n      // ----------------\r\n      case iqrf.sensor.STD_SENSOR_TYPE_DATA_BLOCK:\r\n        {\r\n          sensorValue = [];\r\n          var length = responseData[index];\r\n          for ( var dataIndex = 1; dataIndex <= length; dataIndex++ )\r\n            sensorValue[sensorValue.length] = responseData[index + dataIndex];\r\n          break;\r\n        }\r\n    }\r\n\r\n    var oneSensor =\r\n    {\r\n      id: sensorObj.id,\r\n      type: sensorType,\r\n      name: sensorObj.name,\r\n      shortName: sensorObj.shortName,\r\n      value: sensorValue,\r\n      unit: sensorObj.unit,\r\n      decimalPlaces: sensorObj.decimalPlaces\r\n    };\r\n\r\n    if ( iqrf.sensor.FinalizeSensor !== undefined )\r\n      iqrf.sensor.FinalizeSensor( oneSensor, RequestedIndexes !== undefined ? RequestedIndexes[result.length] : undefined );\r\n\r\n    result[result.length] = oneSensor;\r\n\r\n    var sensorDataLength;\r\n    if ( ( sensorType & 0x80 ) === 0 )\r\n      sensorDataLength = 2;\r\n    else if ( ( sensorType & 0xE0 ) === 0x80 )\r\n      sensorDataLength = 1;\r\n    else if ( ( sensorType & 0xE0 ) === 0xA0 )\r\n      sensorDataLength = 4;\r\n    else\r\n      sensorDataLength = responseData[index] + 1;\r\n\r\n    index += sensorDataLength;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.sensor.Frc_Request\r\nPrepares FRC request to read standard sensor values.\r\n_Requires FRC embedded peripheral driver_.\r\n\r\nParameters:\r\n  sensorType - number: Type of sensor (quantity) to read values of. Use iqrf.sensor.STD_SENSOR_TYPE_* constant. Use 0 to specify the sensor only by sensorIndex parameter.\r\n  sensorIndex - number: Index of the sensor. If the sensor type is specified, then it is an index among of all sensors of the specified type. If sensorType is 0 then it is overall sensor index. Some FRC commands might use top 3 bits of this parameter for passing additional data.\r\n  frcCommand - number: One of predefined standard sensor FRC commands. See iqrf.sensor.STD_SENSOR_FRC_* constants.\r\n  selectedNodes - array: [optional] Array if integer values corresponding to the selected nodes. Use default value or empty array to select all nodes and use sleepAfterFrc parameter.\r\n  sleepAfterFrc - object: [optional] Object with the following fields to put the nodes into sleep mode after the FRC is finished:\r\n      * time - number: See DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n      * control - number: See DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n\r\nReturns: \r\n  array: 2 items long array. 1st item is a prepared request to initiate the RFC. 2nd item is a prepared request to get additional FRC data from the network. For smaller networks extra FRC result might not be needed.\r\n*/\r\niqrf.sensor.Frc_Request = function ( sensorType, sensorIndex, frcCommand, selectedNodes, sleepAfterFrc )\r\n{\r\n  var userData = [0x5E, sensorType, sensorIndex];\r\n  if ( sleepAfterFrc === undefined )\r\n    userData[userData.length] = 0x00;\r\n  else\r\n    userData.push( 0x01, sleepAfterFrc.time & 0xFF, sleepAfterFrc.time >> 8, sleepAfterFrc.control );\r\n\r\n  var result = [];\r\n  result[0] = selectedNodes === undefined || selectedNodes.length === 0 ? iqrf.embed.frc.Send_Request( frcCommand, userData ) : iqrf.embed.frc.SendSelective_Request( frcCommand, selectedNodes, userData );\r\n  result[1] = iqrf.embed.frc.ExtraResult_Request();\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.sensor.Frc_Response\r\nParses FRC response into sensor values. See <iqrf.sensor.Frc_Request> for more details.\r\n_Requires FRC embedded peripheral driver_.\r\n\r\nParameters:\r\n  sensorType - number: Type of sensor (quantity) to read values of. The type must be alway specified even when 0 was passed as sensorType parameter at iqrf.sensor.Frc_Request. If an optional parameter frcSendRequest, then the sensorType parameter is internally assigned from frcSendRequest so it does not have to be specified at all.\r\n  frcCommand - number: One of predefined standard sensor FRC commands. Use the same value that was passed to iqrf.sensor.Frc_Request. If an optional parameter frcSendRequest, then the frcCommand parameter is internally assigned from frcSendRequest so it does not have to be specified at all.\r\n  responseFrcSend - object: Response for the 1st request from iqrf.sensor.Frc_Request.\r\n  responseFrcExtraResult - object: [optional] Response for the 2nd request from iqrf.sensor.Frc_Request.\r\n  frcSendRequest - string: [optional] FrcSend request that was used to generate specified responseFrcSend. It is a return value[0] from <iqrf.sensor.Frc_Request>. Although this parameter is optional, it is needed for breakdown of the \"anonymous\" sensor types \"Binary Data7\", \"Binary Data30\" and \"Data Block\" by the product specific driver. Please see iqrf.sensor.FinalizeSensor for more information.\r\n\r\nReturns:\r\n  array: Array of objects for every read sensor. Object array index represent the node address (or index in case selectedNodes parameter was used). The object has the same fields as object at the return  value of <iqrf.sensor.ReadSensorsWithTypes_Response>. If Node does not response then the array item equals null.\r\n*/\r\niqrf.sensor.Frc_Response = function ( sensorType, frcCommand, responseFrcSend, responseFrcExtraResult, frcSendRequest )\r\n{\r\n  var responseFrcExtraResultParsed;\r\n  if ( responseFrcExtraResult !== undefined )\r\n    responseFrcExtraResultParsed = iqrf.embed.frc.ExtraResult_Response( responseFrcExtraResult );\r\n  var parsedFrc = iqrf.embed.frc.ParseResponses( frcCommand, iqrf.embed.frc.Send_Response( responseFrcSend ), responseFrcExtraResultParsed );\r\n\r\n  if ( frcSendRequest !== undefined )\r\n  {\r\n    var requestData = iqrf.ParseStringBytes( frcSendRequest.rdata );\r\n\r\n    // Get FRC command from request\r\n    frcCommand = requestData[0];\r\n\r\n    // user-data offset according to original the FRC command (plain or selective FRC)\r\n    var userDataOffset = frcSendRequest.pcmd === '00' ? 0 : 30;\r\n\r\n    // If specific sensor type requested, use it\r\n    if ( requestData[2 + userDataOffset] !== 0 )\r\n      sensorType = requestData[2 + userDataOffset];\r\n\r\n    if ( iqrf.sensor.FinalizeSensor !== undefined && iqrf.sensor.SensorsList !== undefined )\r\n    {\r\n      // Sensor index from request\r\n      var sensorIndex = requestData[3 + userDataOffset] & 0x1f;\r\n      // Index from the list \r\n      var listIndex = 0;\r\n      for ( ; listIndex < iqrf.sensor.SensorsList.length; listIndex++ )\r\n      {\r\n        // Any sensor type or exact match?\r\n        if ( requestData[2 + userDataOffset] === 0 || requestData[2 + userDataOffset] === iqrf.sensor.SensorsList[listIndex] )\r\n        {\r\n          // Index counted?\r\n          if ( sensorIndex === 0 )\r\n          {\r\n            // Got the sensor index!\r\n            sensorIndex = listIndex;\r\n\r\n            // Flag the sensor index was found\r\n            listIndex = undefined;\r\n            break;\r\n          }\r\n          // Next index\r\n          sensorIndex--;\r\n        }\r\n      }\r\n\r\n      // Sensor index not found?\r\n      if ( listIndex !== undefined )\r\n        sensorIndex = undefined;\r\n    }\r\n  }\r\n\r\n  var sensorObj = iqrf.sensor.SensorTypes[sensorType];\r\n  if ( sensorObj === undefined )\r\n    throw new Error( 'iqrf.sensor.Frc_Response: Unknown sensor type ' + sensorType );\r\n\r\n  if ( -1 === iqrf.indexOf( sensorObj.frcs, frcCommand ) )\r\n    throw new Error( 'iqrf.sensor.Frc_Response: Unsupported FRC command ' + frcCommand + ' by sensor type ' + sensorType + '=' + sensorObj.name );\r\n\r\n  var result = [];\r\n  for ( var index in parsedFrc )\r\n  {\r\n    var frcValue = parsedFrc[index];\r\n    if ( frcValue === 0 )\r\n      result[index] = null;\r\n    else\r\n    {\r\n      var value;\r\n      var decodeValue = false;\r\n\r\n      if ( frcCommand !== iqrf.sensor.STD_SENSOR_FRC_2BITS )\r\n        switch ( frcValue )\r\n        {\r\n          case 1:\r\n            value = undefined;\r\n            break;\r\n\r\n          case 2:\r\n            value = NaN;\r\n            break;\r\n\r\n          case 3:\r\n            throw new Error( 'iqrf.sensor.Frc_Response: Unsupported FRC value 3 at index ' + index );\r\n\r\n          default:\r\n            decodeValue = true;\r\n            break;\r\n        }\r\n      else\r\n        switch ( frcValue )\r\n        {\r\n          case 1:\r\n            value = undefined;\r\n            break;\r\n\r\n          case 2:\r\n          case 3:\r\n            decodeValue = true;\r\n            break;\r\n\r\n          default:\r\n            throw new Error( 'iqrf.sensor.Frc_Response: Error FRC value ' + frcValue + ' at index ' + index );\r\n        }\r\n\r\n      if ( decodeValue )\r\n        switch ( sensorType )\r\n        {\r\n          default:\r\n            throw new Error( 'iqrf.sensor.Frc_Response: Unimplemented sensor type value ' + sensorType + '=' + sensorObj.name );\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE:\r\n            switch ( frcCommand )\r\n            {\r\n              case iqrf.sensor.STD_SENSOR_FRC_1BYTE:\r\n                value = iqrf.UInt8toInt8( frcValue ) / 2.0 - 22;\r\n                break;\r\n\r\n              case iqrf.sensor.STD_SENSOR_FRC_2BYTES:\r\n                value = iqrf.UInt16toInt16( frcValue ^ 0x8000 ) / 16.0;\r\n                break;\r\n            }\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE:\r\n            value = iqrf.UInt16toInt16( frcValue ^ 0x8000 ) / 16.0;\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE:\r\n          case iqrf.sensor.STD_SENSOR_TYPE_SOUND_PRESSURE_LEVEL:\r\n          case iqrf.STD_SENSOR_TYPE_TIMESPAN_LONG:\r\n            value = ( frcValue - 4 ) / 16.0;\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_CO2:\r\n          case iqrf.sensor.STD_SENSOR_TYPE_VOC:\r\n            switch ( frcCommand )\r\n            {\r\n              case iqrf.sensor.STD_SENSOR_FRC_1BYTE:\r\n                value = ( frcValue - 4 ) * 16;\r\n                break;\r\n\r\n              case iqrf.sensor.STD_SENSOR_FRC_2BYTES:\r\n                value = frcValue - 4;\r\n                break;\r\n            }\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE:\r\n          case iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN:\r\n          case iqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE:\r\n          case iqrf.STD_SENSOR_TYPE_CONSUMPTION:\r\n          case iqrf.STD_SENSOR_TYPE_DATETIME:\r\n            value = frcValue - 4;\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE:\r\n          case iqrf.sensor.STD_SENSOR_TYPE_CURRENT:\r\n            value = iqrf.UInt16toInt16( frcValue ^ 0x8000 ) / 1000.0;\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY:\r\n          case iqrf.sensor.STD_SENSOR_TYPE_NO2:\r\n          case iqrf.sensor.STD_SENSOR_TYPE_SO2:\r\n          case iqrf.sensor.STD_SENSOR_TYPE_METHANE:\r\n            value = ( frcValue - 4 ) / 1000.0;\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD:\r\n            value = iqrf.UInt16toInt16( frcValue ^ 0x8000 ) / 10000000.0;\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_POWER:\r\n          case iqrf.sensor.STD_SENSOR_TYPE_PARTICULATES_PM25:\r\n            value = ( frcValue - 4 ) / 4.0;\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_CO:\r\n            value = ( frcValue - 4 ) / 100.0;\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_O3:\r\n            value = ( frcValue - 4 ) / 10000.0;\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_ALTITUDE:\r\n            value = iqrf.UInt16toInt16( frcValue ^ 0x8000 ) / 4.0 - 1024.0;\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_ACCELERATION:\r\n            value = ( iqrf.UInt16toInt16( frcValue ) - 4 ) / 256.0;\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_NH3:\r\n            value = ( frcValue - 4 ) / 10.0;\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY:\r\n            value = ( frcValue - 4 ) / 2.0;\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7:\r\n            switch ( frcCommand )\r\n            {\r\n              case iqrf.sensor.STD_SENSOR_FRC_2BITS:\r\n                value = frcValue & 0x01;\r\n                break;\r\n\r\n              case iqrf.sensor.STD_SENSOR_FRC_1BYTE:\r\n                value = frcValue - 4;\r\n                break;\r\n            }\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR:\r\n            value = ( frcValue - 4 ) / 200.0;\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_UV_INDEX:\r\n            value = ( frcValue - 4 ) / 8.0;\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_PH:\r\n            value = ( frcValue - 4 ) / 16.0;\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30:\r\n            switch ( frcCommand )\r\n            {\r\n              case iqrf.sensor.STD_SENSOR_FRC_2BITS:\r\n                value = frcValue & 0x01;\r\n                break;\r\n\r\n              case iqrf.sensor.STD_SENSOR_FRC_4BYTES:\r\n                value = frcValue - 4;\r\n                break;\r\n            }\r\n            break;\r\n\r\n          case iqrf.sensor.STD_SENSOR_TYPE_LATITUDE:\r\n          case iqrf.sensor.STD_SENSOR_TYPE_LONGITUDE:\r\n            value = frcValue;\r\n            break;\r\n        }\r\n\r\n      if ( value !== undefined )\r\n      {\r\n        var oneSensor =\r\n        {\r\n          id: sensorObj.id,\r\n          type: sensorType,\r\n          name: sensorObj.name,\r\n          shortName: sensorObj.shortName,\r\n          value: value,\r\n          unit: sensorObj.unit,\r\n          decimalPlaces: sensorObj.decimalPlaces\r\n        };\r\n\r\n        if ( iqrf.sensor.FinalizeSensor !== undefined )\r\n          iqrf.sensor.FinalizeSensor(\r\n            // Sensor object\r\n            oneSensor,\r\n            // Sensor index\r\n            sensorIndex,\r\n            // FRC command\r\n            frcCommand,\r\n            // Extended FRC data if specified\r\n            requestData !== undefined ? ( requestData[3] >> 5 ) : undefined );\r\n\r\n        result[index] = oneSensor;\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.sensor.FinalizeSensor\r\nThis function should be implemented in the product driver in order to breakdown \"anonymous\" sensor types \"Binary Data7\", \"Binary Data30\" and \"Data Block\". The function is called by <iqrf.sensor.ReadSensorsWithTypes_Response>, <iqrf.sensor.Enumerate_Response>, and <iqrf.sensor.Frc_Response>. Also variable <iqrf.sensor.SensorsList> should be declared in the product driver. The function might also add custom product specific properties to the sensor object.\r\n\r\nWhen the function is called from <iqrf.sensor.Enumerate_Response> then sensor.value is undefined, therefore \"value\" property should not be created at the resulting breakdown sensor object.\r\n\r\nThis function might modify the sensor object. It must not alter the properties \"id\", \"type\", \"name\", \"shortName\", \"value\", \"unit\" and \"decimalPlaces\", but it might add custom product specific properties. In case of anonymous sensor data types it is supposed to add property \"breakdown\" that has the same format as return value at <iqrf.sensor.ReadSensorsWithTypes_Response>. Each array member must share the same sensor type as the \"sensor\" parameter. Please also note, that the \"value\" property must be number.\r\n\r\nParameters:\r\n  sensor - object: See member of the return array at <iqrf.sensor.ReadSensorsWithTypes_Response>.\r\n  index - number: Sensor index. It might be undefined if the required parameters were not passed to the functions that call this function.\r\n  frcCommand - number: [optional] When sensor value from the FRC result is to be processed, then this parameter is FRC command.\r\n  extendedFrcData - number: [optional] When sensor value from the FRC result is to be processed, then this parameter is extended FRC data according to the IQRF Sensor standards FRC that is used by some standard quantities.\r\n\r\nExample:\r\n--- Text\r\n// \"sensor\" parameter in entry:\r\n{\r\n    \"id\" : \"BINARYDATA7\",\r\n    \"type\": 129,\r\n    \"name\": \"Binary data7\",\r\n    \"shortName\": \"bin7\",\r\n    \"value\": 88,\r\n    \"unit\": \"?\",\r\n    \"decimalPlaces\": 0\r\n}\r\n---\r\n--- Text\r\n// \"sensor\" parameter on exit:\r\n{\r\n    \"id\" : \"BINARYDATA7\",\r\n    \"type\": 129,\r\n    \"name\": \"Binary data7\",\r\n    \"shortName\": \"bin7\",\r\n    \"value\": 88,\r\n    \"unit\": \"?\",\r\n    \"decimalPlaces\": 0,\r\n    \"breakdown\":\r\n    [\r\n      {\r\n        \"id\" : \"BINARYDATA7\",\r\n        \"type\": 129,\r\n        \"name\": \"Potentiometer\",\r\n        \"shortName\": \"pot\",\r\n        \"value\": 30.7,\r\n        \"unit\": \"%\",\r\n        \"decimalPlaces\": 1\r\n      }\r\n    ]\r\n}\r\n---\r\n*/\r\n\r\n/* Variable: iqrf.sensor.SensorsList\r\nThis variable declared in the product driver is an array listing all supported sensor types in the right order. The variable should be implemented in order to breakdown \"anonymous\" sensor types \"Binary Data7\", \"Binary Data30\" and \"Data Block\".\r\n\r\nExample:\r\n--- Text\r\n// This product sensors list\r\niqrf.sensor.SensorsList =\r\n  [\r\n    iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE,  // 0\r\n    iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE,  // 1\r\n    iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7,  // 2 : Light indicator\r\n    iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7   // 3 : Potentiometer\r\n  ];\r\n---\r\n*/\r\n\r\n//############################################################################################\r\n", "name": "IQRF: Sensor", "notes": "+ New quantities added (TimeSpan, Illuminance, NO2 (nitrogen dioxide), SO2 (sulfur dioxide), CO (carbon monoxide), O3 (ozone), Atmospheric Pressure, Color Temperature, TimeSpanLong, UV Index, Sound Pressure Level, Particulates PM2.5, Data Block, Altitude, Acceleration, pH, Ammonia, Methane ).\n+ 4 bytes FRC added.\n! Fixed negative numbers calculation for signed quantities.\n! Fixed computation of Earth\u2019s Magnetic Field value.\n+ Error sensor values detected and returned as NaN.\n+ Sensor enumeration gives list of supported FRC commands.\n+ iqrf.sensor.Frc* functions added.\n+ Optional parameter writtenData at iqrf.sensor.ReadSensorsWithTypes_Request.", "standardID": 94, "version": 15.0, "versionFlags": 0}