{"version":15.00,"versionFlags":0,"driver":"//############################################################################################\r\n\r\n/* Title: IQRF Standards Sensor driver\r\nSee also: <https://www.iqrfalliance.org/techDocs/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x5E,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 15, 'Notes' : [\r\n        '+ New quantities added (TimeSpan, Illuminance, NO2 (nitrogen dioxide), SO2 (sulfur dioxide), CO (carbon monoxide), O3 (ozone), Atmospheric Pressure, Color Temperature, TimeSpanLong, UV Index, Sound Pressure Level, Particulates PM2.5, Data Block, Altitude, Acceleration).',\r\n        '+ 4 bytes FRC added.',\r\n        '! Fixed negative numbers calculation for signed quantities.' ,\r\n        '! Fixed computation of Earth’s Magnetic Field value.' ,\r\n        '+ Error sensor values detected and returned as NaN.',\r\n        '+ Sensor enumeration gives list of supported FRC commands.',\r\n        '+ iqrf.sensor.Frc* functions added.' ,\r\n        '+ Optional parameter writtenData at iqrf.sensor.ReadSensorsWithTypes_Request.' ]\r\n    },\r\n    { 'Version' : 14, 'Notes' : [\r\n        '- Initial public release' ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.sensor\r\nnamespace( 'iqrf.sensor' );\r\n\r\n// IQRF Standards Sensor PNUM value\r\niqrf.sensor.PNUM = '5e';\r\n\r\n// IQRF Sensor standard peripheral - sensor types\r\n// 2 bytes\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE\r\nTemperature sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE = 0x01;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_CO2\r\nCarbon dioxide sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_CO2 = 0x02;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_VOC\r\nVolatile organic compounds sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_VOC = 0x03;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE\r\nExtra-low voltage sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE = 0x04;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD\r\nEarth’s magnetic field sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD = 0x05;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE\r\nLow voltage sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE = 0x06;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_CURRENT\r\nCurrent sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_CURRENT = 0x07;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_POWER\r\nPower sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_POWER = 0x08;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY\r\nMains frequency sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY = 0x09;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN\r\nTimespan value.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_TIMESPAN = 0x0A;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE\r\nIlluminance sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE = 0x0B;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_NO2\r\nNitrogen dioxide sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_NO2 = 0x0C;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_SO2\r\nSulfur dioxide sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_SO2 = 0x0D;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_CO\r\nCarbon monoxide sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_CO = 0x0E;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_O3\r\nOzone sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_O3 = 0x0F;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE\r\nAtmospheric pressure sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE = 0x10;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE\r\nColor temperature sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE = 0x11;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_PARTICULATES_PM25\r\nParticulates PM2.5 sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_PARTICULATES_PM25 = 0x12;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_SOUND_PRESSURE_LEVEL\r\nSound pressure level sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_SOUND_PRESSURE_LEVEL = 0x13;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_ALTITUDE\r\nAltitude sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_ALTITUDE = 0x14;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_ACCELERATION\r\nAcceleration sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_ACCELERATION = 0x15;\r\n\r\n//  1 byte\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY\r\nRelative humidity sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY = 0x80;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7\r\n7 bits binary data sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7 = 0x81;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR\r\nPower factor sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR = 0x82;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_UV_INDEX\r\nUV index sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_UV_INDEX = 0x83;\r\n\r\n//  4 bytes\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30\r\n30 bits binary data sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30 = 0xA0;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_CONSUMPTION\r\nConsumption sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_CONSUMPTION = 0xA1;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_DATETIME\r\nDate and time vallue.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_DATETIME = 0xA2;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN_LONG\r\nLong timespan value.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_TIMESPAN_LONG = 0xA3;\r\n\r\n//  Multiple bytes\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_DATA_BLOCK\r\nData block containing proprietary data.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_DATA_BLOCK = 0xC0;\r\n\r\n// FRC commands\r\n/* Const: iqrf.sensor.STD_SENSOR_FRC_2BITS\r\nFRC command to return 2-bits sensor data of the supporting sensor types.\r\n*/\r\niqrf.sensor.STD_SENSOR_FRC_2BITS = 0x10;\r\n/* Const: iqrf.sensor.STD_SENSOR_FRC_1BYTE\r\nFRC command to return 1-byte wide sensor data of the supporting sensor types. \r\n*/\r\niqrf.sensor.STD_SENSOR_FRC_1BYTE = 0x90;\r\n/* Const: iqrf.sensor.STD_SENSOR_FRC_2BYTES\r\nFRC command to return 2-bytes wide sensor data of the supporting sensor types.\r\n*/\r\niqrf.sensor.STD_SENSOR_FRC_2BYTES = 0xE0;\r\n/* Const: iqrf.sensor.STD_SENSOR_FRC_4BYTES\r\nFRC command to return 4-bytes wide sensor data of the supporting sensor types.\r\n*/\r\niqrf.sensor.STD_SENSOR_FRC_4BYTES = 0xF9;\r\n\r\n// Sensor types\r\niqrf.sensor.SensorTypes = [];\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE] =\r\n  {\r\n    name: 'Temperature',\r\n    shortName: 'T',\r\n    unit: '°C',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE, iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_CO2] =\r\n  {\r\n    name: 'Carbon dioxide',\r\n    shortName: 'CO2',\r\n    unit: 'ppm',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE, iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_VOC] =\r\n  {\r\n    name: 'Volatile organic compound',\r\n    shortName: 'VOC',\r\n    unit: 'ppm',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE, iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE] =\r\n  {\r\n    name: 'Extra-low voltage',\r\n    shortName: 'U',\r\n    unit: 'V',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD] =\r\n  {\r\n    name: 'Earth’s magnetic field',\r\n    shortName: 'B',\r\n    unit: 'T',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE] =\r\n  {\r\n    name: 'Low voltage',\r\n    shortName: 'U',\r\n    unit: 'V',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_CURRENT] =\r\n  {\r\n    name: 'Current',\r\n    shortName: 'I',\r\n    unit: 'A',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_POWER] =\r\n  {\r\n    name: 'Power',\r\n    shortName: 'E',\r\n    unit: 'W',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY] =\r\n  {\r\n    name: 'Mains frequency',\r\n    shortName: 'f',\r\n    unit: 'Hz',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY] =\r\n  {\r\n    name: 'Timespan',\r\n    shortName: 't',\r\n    unit: 's',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE] =\r\n  {\r\n    name: 'Illuminance',\r\n    shortName: 'Ev',\r\n    unit: 'lx',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_NO2] =\r\n  {\r\n    name: 'Nitrogen dioxide',\r\n    shortName: 'NO2',\r\n    unit: 'ppm',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_SO2] =\r\n  {\r\n    name: 'Sulfur dioxide',\r\n    shortName: 'SO2',\r\n    unit: 'ppm',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_CO] =\r\n  {\r\n    name: 'Carbon monoxide',\r\n    shortName: 'CO',\r\n    unit: 'ppm',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_O3] =\r\n  {\r\n    name: 'Ozone',\r\n    shortName: 'O3',\r\n    unit: 'ppm',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE] =\r\n  {\r\n    name: 'Atmospheric pressure',\r\n    shortName: 'p',\r\n    unit: 'hPa',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE] =\r\n  {\r\n    name: 'Color temperature',\r\n    shortName: 'Tc',\r\n    unit: 'K',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_PARTICULATES_PM25] =\r\n  {\r\n    name: 'Particulates PM2.5',\r\n    shortName: 'PM2.5',\r\n    unit: 'μg/m³',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_SOUND_PRESSURE_LEVEL] =\r\n  {\r\n    name: 'Sound pressure level',\r\n    shortName: 'Lp',\r\n    unit: 'dB',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_ALTITUDE] =\r\n  {\r\n    name: 'Altitude',\r\n    shortName: 'h',\r\n    unit: 'm',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_ACCELERATION] =\r\n  {\r\n    name: 'Acceleration',\r\n    shortName: 'a',\r\n    unit: 'm/s²',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY] =\r\n  {\r\n    name: 'Relative humidity',\r\n    shortName: 'RH',\r\n    unit: '%',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7] =\r\n  {\r\n    name: 'Binary data7',\r\n    shortName: 'bin7',\r\n    unit: '?',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BITS, iqrf.sensor.STD_SENSOR_FRC_1BYTE]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR] =\r\n  {\r\n    name: 'Power factor',\r\n    shortName: 'cos φ',\r\n    unit: '',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_UV_INDEX] =\r\n  {\r\n    name: 'UV index',\r\n    shortName: 'UV',\r\n    unit: '',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30] =\r\n  {\r\n    name: 'Binary data30',\r\n    shortName: 'bin30',\r\n    unit: '?',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES, iqrf.sensor.STD_SENSOR_FRC_4BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_CONSUMPTION] =\r\n  {\r\n    name: 'Consumption',\r\n    shortName: 'E',\r\n    unit: 'Wh',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_4BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_DATETIME] =\r\n  {\r\n    name: 'DateTime',\r\n    shortName: 'DateTime',\r\n    unit: '',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_4BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN_LONG] =\r\n  {\r\n    name: 'Timespan long',\r\n    shortName: 't',\r\n    unit: 's',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_4BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_DATA_BLOCK] =\r\n  {\r\n    name: 'Data block',\r\n    shortName: 'datablock',\r\n    unit: '?',\r\n    frcs: []\r\n  };\r\n\r\n\r\n/* Function: iqrf.sensor.Enumerate_Request\r\nEncodes DPA request to enumerate sensors.\r\n\r\nReturns:\r\n  string: DPA request string.  \r\n*/\r\niqrf.sensor.Enumerate_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.sensor.PNUM, '3e' );\r\n};\r\n\r\n/* Function: iqrf.sensor.Enumerate_Response\r\nDecodes DPA response from sensor enumeration.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Array of objects describing each sensor. The object has the following fields:\r\n\r\n* type - number: Value type of the sensor (quantity). See IQRF Sensor standard for details.\r\n* name - string: Name of the sensor (quantity).\r\n* shortName - string: Short name of the sensor (quantity). Typically it is a symbol used at physics.\r\n* unit - string: Unit of the quantity. Dimensionless quantity has empty string \"\".\r\n* frcs - array: Array of FRC commands supported by the sensor.\r\n*/\r\niqrf.sensor.Enumerate_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.sensor.PNUM, 'be', -1 );\r\n\r\n  var result = [];\r\n  for ( var index in responseData )\r\n  {\r\n    var sensorType = responseData[index];\r\n    var sensorObj = iqrf.sensor.SensorTypes[sensorType];\r\n    if ( sensorObj === undefined )\r\n      throw new Error( 'iqrf.sensor.Enumerate_Response: Unknown sensor type ' + sensorType );\r\n\r\n    result[result.length] =\r\n      {\r\n        type: sensorType,\r\n        name: sensorObj.name,\r\n        shortName: sensorObj.shortName,\r\n        unit: sensorObj.unit,\r\n        frcs: sensorObj.frcs\r\n      };\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\niqrf.sensor.Indexes2bitmap = function ( sensorIndexes )\r\n{\r\n  var bitmap = 0;\r\n  for ( var index in sensorIndexes )\r\n    bitmap |= 1 << sensorIndexes[index];\r\n\r\n  return iqrf.IntToHexStringBytesArray( bitmap, 4 );\r\n};\r\n\r\n/* Function: iqrf.sensor.ReadSensorsWithTypes_Request\r\nEncodes DPA request to read sensors values.\r\n\r\nParameters:\r\n  sensorIndexes - Specifies sensors to read data from:\r\n\r\n* undefined: Missing parameter: reads 1st sensor.\r\n* number: -1: reads all sensors.\r\n* array: array of indexes: specifies sensors to read.\r\n  \r\n  writtenData - array: [optional] array of 5-bytes-arrays (for each sensor). See IQRF Sensor standards for details.\r\n\r\nReturns:\r\n  string: DPA request string.  \r\n*/\r\niqrf.sensor.ReadSensorsWithTypes_Request = function ( sensorIndexes, writtenData )\r\n{\r\n  var result = new iqrf.DpaRawHdpMessage( iqrf.sensor.PNUM, '01' );\r\n  if ( sensorIndexes !== undefined )\r\n  {\r\n    if ( sensorIndexes === -1 )\r\n      result.rdata = 'ff.ff.ff.ff';\r\n    else\r\n      result.rdata = iqrf.sensor.Indexes2bitmap( sensorIndexes );\r\n  }\r\n\r\n  if ( writtenData !== undefined )\r\n  {\r\n    var writtenData_length = writtenData.length;\r\n    for ( var index = 0; index < writtenData_length; index++ )\r\n    {\r\n      var oneData = writtenData[index];\r\n      if ( oneData.length !== 5 )\r\n        throw new Error( 'iqrf.sensor.ReadSensorsWithTypes_Request: Written data item length is not 5 but ' + oneData.length );\r\n\r\n      result.rdata += iqrf.BytesToHexStringBytesArray( oneData, true );\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.sensor.ReadSensorsWithTypes_Response\r\nDecodes DPA response from sensor value reading.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Array of objects for every read sensor. The object has the following fields:\r\n\r\n* type - number: Value type of the sensor (quantity). See IQRF Sensor standard for details.\r\n* name - string: Name of the sensor (quantity).\r\n* shortName - string: Short name of the sensor (quantity). Typically it is a symbol used at physics.\r\n* value - number: Value of the sensor. It equals to NaN to indicate an error value.\r\n* unit - string: Unit of the quantity. Dimensionless quantity has empty string \"\".\r\n\r\n--- Text\r\nExample:\r\n\r\n{\r\n  \"length\": 3,\r\n  \"0\": {\r\n    \"type\": 1,\r\n    \"name\": \"Temperature\"\r\n    \"shortName\": \"T\",\r\n    \"value\": 22.3,\r\n    \"unit\": \"°C\"\r\n  },\r\n  \"1\": {\r\n    \"type\": 128,\r\n    \"name\": \"Relative humidity\"\r\n    \"shortName\": \"RH\",\r\n    \"value\": 35,\r\n    \"unit\": \"%\"\r\n  },\r\n  \"2\": {\r\n    \"type\": 9,\r\n    \"name\": \"Mains frequency\",\r\n    \"shortName\": \"f\",\r\n    \"value\": 49.98,\r\n    \"unit\": \"Hz\"\r\n  }\r\n}\r\n---\r\n*/\r\niqrf.sensor.ReadSensorsWithTypes_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.sensor.PNUM, '81' );\r\n\r\n  var result = [];\r\n  var responseData_length = responseData.length;\r\n  for ( var index = 0; index < responseData_length; )\r\n  {\r\n    var sensorType = responseData[index++];\r\n    var sensorObj = iqrf.sensor.SensorTypes[sensorType];\r\n    if ( sensorObj === undefined )\r\n      throw new Error( 'iqrf.sensor.ReadSensorsWithTypes_Response: Unknown sensor type ' + sensorType );\r\n\r\n    var sensorValue;\r\n\r\n    switch ( sensorType )\r\n    {\r\n      default:\r\n        throw new Error( 'iqrf.sensor.ReadSensorsWithTypes_Response: Unimplemented sensor type value ' + sensorType );\r\n\r\n      // 2 bytes\r\n      // ----------------\r\n      case iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : iqrf.UInt16toInt16( sensorValue ) / 16.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 16.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_CO2:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_VOC:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        if ( sensorValue === 0x8000 )\r\n          sensorvalue = NaN;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        if ( sensorValue === 0xFfFf )\r\n          sensorvalue = NaN;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_CURRENT:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : iqrf.UInt16toInt16( sensorValue ) / 1000.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_NO2:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_SO2:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 1000.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : iqrf.UInt16toInt16( sensorValue ) / 10000000.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_POWER:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 4.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_CO:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 100.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_O3:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 10000.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_PARTICULATES_PM25:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : sensorValue / 4.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_SOUND_PRESSURE_LEVEL:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : sensorValue / 16.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_ALTITUDE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 4.0 + 1024.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_ACCELERATION:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : sensorValue / 256.0;\r\n        break;\r\n\r\n      // 1 byte\r\n      // ----------------\r\n      case iqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY:\r\n        sensorValue = responseData[index] === 0xEE ? NaN : ( responseData[index] / 2.0 );\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7:\r\n        sensorValue = ( responseData[index] & 0x80 ) !== 0 ? NaN : responseData[index];\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR:\r\n        sensorValue = responseData[index] === 0xEE ? NaN : responseData[index] / 200.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_UV_INDEX:\r\n        sensorValue = responseData[index] === 0xFF ? NaN : responseData[index] / 8.0;\r\n        break;\r\n\r\n      // 4 bytes\r\n      // ----------------\r\n      case iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30:\r\n        sensorValue = ( responseData[index + 3] & 0x80 ) !== 0 ? NaN : ( responseData[index] + ( responseData[index + 1] * 0x100 ) + ( responseData[index + 2] * 0x10000 ) + ( responseData[index + 3] * 0x1000000 ) );\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_CONSUMPTION:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 ) + ( responseData[index + 2] * 0x10000 ) + ( responseData[index + 3] * 0x1000000 );\r\n        if ( sensorValue === -1 )\r\n          sensorvalue = NaN;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_DATETIME:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 ) + ( responseData[index + 2] * 0x10000 ) + ( responseData[index + 3] * 0x1000000 );\r\n        if ( sensorValue === -1 )\r\n          sensorValue = NaN;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN_LONG:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 ) + ( responseData[index + 2] * 0x10000 ) + ( responseData[index + 3] * 0x1000000 );\r\n        sensorValue = sensorValue === -1 ? NaN : sensorValue / 16.0;\r\n        break;\r\n\r\n      // Multiple bytes\r\n      // ----------------\r\n      case iqrf.sensor.STD_SENSOR_TYPE_DATA_BLOCK:\r\n        {\r\n          sensorValue = [];\r\n          var length = responseData[index];\r\n          for ( var dataIndex = 1; dataIndex <= length; dataIndex++ )\r\n            sensorValue[sensorValue.length] = responseData[index + dataIndex];\r\n          break;\r\n        }\r\n    }\r\n\r\n    result[result.length] =\r\n      {\r\n        type: sensorType,\r\n        name: sensorObj.name,\r\n        shortName: sensorObj.shortName,\r\n        value: sensorValue,\r\n        unit: sensorObj.unit\r\n      };\r\n\r\n    var sensorDataLength;\r\n    if ( ( sensorType & 0x80 ) === 0 )\r\n      sensorDataLength = 2;\r\n    else if ( ( sensorType & 0xE0 ) === 0x80 )\r\n      sensorDataLength = 1;\r\n    else if ( ( sensorType & 0xE0 ) === 0xA0 )\r\n      sensorDataLength = 4;\r\n    else\r\n      sensorDataLength = responseData[index] + 1;\r\n\r\n    index += sensorDataLength;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.sensor.Frc_Request\r\nPrepares FRC request to read standard sensor values.\r\n_Requires FRC embedded peripheral driver_.\r\n\r\nParameters:\r\n  sensorType - number: Type of sensor (quantity) to read values of. Use iqrf.sensor.STD_SENSOR_TYPE_* constant. Use 0 to specify the sensor only by sensorIndex parameter.\r\n  sensorIndex - number: Index of the sensor. If the sensor type is specified, then its is an index among of all sensors of the specified type. If sensorType is 0 then it is overall sensor index. Some FRC commands might use top 3 bits of this parameter for passing additional data.\r\n  frcCommand - number: One of predefined standard sensor FRC commands. See iqrf.sensor.STD_SENSOR_FRC_* constants.\r\n  selectedNodes - array: [optional] Array if integer values corresponding to the selected nodes. Use default value to select all nodes and use sleepAfterFrc parameter.\r\n  sleepAfterFrc - object: [optional] Object with the following fields to put the nodes into sleep mode after the FRC is finished:\r\n      * time - number: See DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n      * control - number: See DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n\r\nReturns: \r\n  array: 2 items long array. 1st item is a prepared request to initiate the RFC. 2nd item is a prepared request to get additional FRC data from the network. For smaller networks extra FRC result might not be needed.\r\n*/\r\niqrf.sensor.Frc_Request = function ( sensorType, sensorIndex, frcCommand, selectedNodes, sleepAfterFrc )\r\n{\r\n  var userData = [0x5E, sensorType, sensorIndex];\r\n  if ( sleepAfterFrc === undefined )\r\n    userData[userData.length] = 0x00;\r\n  else\r\n    userData.push( 0x01, sleepAfterFrc.time & 0xFF, sleepAfterFrc.time >> 8, sleepAfterFrc.control );\r\n\r\n  var result = [];\r\n  result[0] = selectedNodes === undefined ? iqrf.embed.frc.Send_Request( frcCommand, userData ) : iqrf.embed.frc.SendSelective_Request( frcCommand, selectedNodes, userData );\r\n  result[1] = iqrf.embed.frc.ExtraResult_Request();\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.sensor.Frc_Response\r\nParses FRC response into sensor values. See <iqrf.sensor.Frc_Request> for more details.\r\n_Requires FRC embedded peripheral driver_.\r\n\r\nParameters:\r\n  sensorType - number: Type of sensor (quantity) to read values of. The type must be alway specified even when 0 was passed as sensorType parameter at iqrf.sensor.Frc_Request.\r\n  frcCommand - number: One of predefined standard sensor FRC commands. Use the same value that was passed to iqrf.sensor.Frc_Request.\r\n  responseFrcSend - object: Response for the 1st request from iqrf.sensor.Frc_Request.\r\n  responseFrcExtraResult - object: [optional] Response for the 2nd request from iqrf.sensor.Frc_Request.\r\n\r\nReturns:\r\n  array: Array of objects for every read sensor. Object array index represent the node address (or index in case selectedNodes parameter was used). The object has the following fields:\r\n\r\n* type - number: Value type of the sensor (quantity). See IQRF Sensor standard for details.\r\n* name - string: Name of the sensor (quantity).\r\n* shortName - string: Short name of the sensor (quantity). Typically it is a symbol used at physics.\r\n* value - number: Value of the sensor. It equals to NaN to indicate an error value. It equals to undefined to indicate that the node does not support the FRC command.\r\n* unit - string: Unit of the quantity. Dimensionless quantity has empty string \"\".\r\n*/\r\niqrf.sensor.Frc_Response = function ( sensorType, frcCommand, responseFrcSend, responseFrcExtraResult )\r\n{\r\n  var responseFrcExtraResultParsed;\r\n  if ( responseFrcExtraResult !== undefined )\r\n    responseFrcExtraResultParsed = iqrf.embed.frc.ExtraResult_Response( responseFrcExtraResult );\r\n  var parsedFrc = iqrf.embed.frc.ParseResponses( frcCommand, iqrf.embed.frc.Send_Response( responseFrcSend ), responseFrcExtraResultParsed );\r\n\r\n  var sensorObj = iqrf.sensor.SensorTypes[sensorType];\r\n  if ( sensorObj === undefined )\r\n    throw new Error( 'iqrf.sensor.Frc_Response: Unknown sensor type ' + sensorType );\r\n\r\n  if ( -1 === iqrf.indexOf( sensorObj.frcs, frcCommand ) )\r\n    throw new Error( 'iqrf.sensor.Frc_Response: Unsupported FRC command ' + frcCommand + ' by sensor type ' + sensorType + '=' + sensorObj.name );\r\n\r\n  var result = [];\r\n  for ( var index in parsedFrc )\r\n  {\r\n    var frcValue = parsedFrc[index];\r\n\r\n    if ( frcValue === 0 )\r\n      throw new Error( 'iqrf.sensor.Frc_Response: Error FRC value 0 at index ' + index );\r\n\r\n    var value;\r\n    var decodeValue = false;\r\n\r\n    if ( frcCommand !== iqrf.sensor.STD_SENSOR_FRC_2BITS )\r\n      switch ( frcValue )\r\n      {\r\n        case 1:\r\n          value = undefined;\r\n          break;\r\n\r\n        case 2:\r\n          value = NaN;\r\n          break;\r\n\r\n        case 3:\r\n          throw new Error( 'iqrf.sensor.Frc_Response: Unsupported FRC value 3 at index ' + index );\r\n\r\n        default:\r\n          decodeValue = true;\r\n          break;\r\n      }\r\n    else\r\n      switch ( frcValue )\r\n      {\r\n        case 1:\r\n          value = undefined;\r\n          break;\r\n\r\n        case 2:\r\n        case 3:\r\n          decodeValue = true;\r\n          break;\r\n\r\n        default:\r\n          throw new Error( 'iqrf.sensor.Frc_Response: Error FRC value ' + frcValue + ' at index ' + index );\r\n      }\r\n\r\n    if ( decodeValue )\r\n      switch ( sensorType )\r\n      {\r\n        default:\r\n          throw new Error( 'iqrf.sensor.Frc_Response: Unimplemented sensor type value ' + sensorType + '=' + sensorObj.name );\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE:\r\n          switch ( frcCommand )\r\n          {\r\n            case iqrf.sensor.STD_SENSOR_FRC_1BYTE:\r\n              value = iqrf.UInt8toInt8( frcValue ) / 2.0 - 22;\r\n              break;\r\n\r\n            case iqrf.sensor.STD_SENSOR_FRC_2BYTES:\r\n              value = iqrf.UInt16toInt16( frcValue ^ 0x8000 ) / 16.0;\r\n              break;\r\n          }\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE:\r\n          value = iqrf.UInt16toInt16( frcValue ^ 0x8000 ) / 16.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_SOUND_PRESSURE_LEVEL:\r\n        case iqrf.STD_SENSOR_TYPE_TIMESPAN_LONG:\r\n          value = ( frcValue - 4 ) / 16.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_CO2:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_VOC:\r\n          switch ( frcCommand )\r\n          {\r\n            case iqrf.sensor.STD_SENSOR_FRC_1BYTE:\r\n              value = ( frcValue - 4 ) * 16;\r\n              break;\r\n\r\n            case iqrf.sensor.STD_SENSOR_FRC_2BYTES:\r\n              value = frcValue - 4;\r\n              break;\r\n          }\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE:\r\n        case iqrf.STD_SENSOR_TYPE_CONSUMPTION:\r\n        case iqrf.STD_SENSOR_TYPE_DATETIME:\r\n          value = frcValue - 4;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_CURRENT:\r\n          value = iqrf.UInt16toInt16( frcValue ^ 0x8000 ) / 1000.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_NO2:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_SO2:\r\n          value = ( frcValue - 4 ) / 1000.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD:\r\n          value = iqrf.UInt16toInt16( frcValue ^ 0x8000 ) / 10000000.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_POWER:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_PARTICULATES_PM25:\r\n          value = ( frcValue - 4 ) / 4.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_CO:\r\n          value = ( frcValue - 4 ) / 100.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_O3:\r\n          value = ( frcValue - 4 ) / 10000.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_ALTITUDE:\r\n          value = iqrf.UInt16toInt16( frcValue ^ 0x8000 ) / 4.0 + 1024.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_ACCELERATION:\r\n          value = ( frcValue - 4 ) / 256.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY:\r\n          value = ( frcValue - 4 ) / 2.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7:\r\n          switch ( frcCommand )\r\n          {\r\n            case iqrf.sensor.STD_SENSOR_FRC_2BITS:\r\n              value = frcValue & 0x01;\r\n              break;\r\n\r\n            case iqrf.sensor.STD_SENSOR_FRC_1BYTE:\r\n              value = frcValue - 4;\r\n              break;\r\n          }\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR:\r\n          value = ( frcValue - 4 ) / 200.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_UV_INDEX:\r\n          value = ( frcValue - 4 ) / 8.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30:\r\n          switch ( frcCommand )\r\n          {\r\n            case iqrf.sensor.STD_SENSOR_FRC_2BITS:\r\n              value = frcValue & 0x01;\r\n              break;\r\n\r\n            case iqrf.sensor.STD_SENSOR_FRC_4BYTES:\r\n              value = frcValue - 4;\r\n              break;\r\n          }\r\n          break;\r\n      }\r\n\r\n    result[index] =\r\n      {\r\n        type: sensorType,\r\n        name: sensorObj.name,\r\n        shortName: sensorObj.shortName,\r\n        value: value,\r\n        unit: sensorObj.unit\r\n      };\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n//############################################################################################\r\n","notes":"+ New quantities added (TimeSpan, Illuminance, NO2 (nitrogen dioxide), SO2 (sulfur dioxide), CO (carbon monoxide), O3 (ozone), Atmospheric Pressure, Color Temperature, TimeSpanLong, UV Index, Sound Pressure Level, Particulates PM2.5, Data Block, Altitude, Acceleration).\n+ 4 bytes FRC added.\n! Fixed negative numbers calculation for signed quantities.\n! Fixed computation of Earth’s Magnetic Field value.\n+ Error sensor values detected and returned as NaN.\n+ Sensor enumeration gives list of supported FRC commands.\n+ iqrf.sensor.Frc* functions added.\n+ Optional parameter writtenData at iqrf.sensor.ReadSensorsWithTypes_Request.","standardID":94,"name":"IQRF: Sensor"}