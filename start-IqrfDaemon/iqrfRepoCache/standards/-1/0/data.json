{"version":0.00,"versionFlags":0,"driver":"//############################################################################################\r\n\r\n/* Title: Global IQRF driver library routines\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n\r\nBecause of potential usage of JScript at *Microsoft.ClearScript.Windows.JScriptEngine* the following features cannot used:\r\n\r\n* 'let' instead of 'var' where appropriate\r\n* 'const'\r\n* default parameter values\r\n* binary literals\r\n* enums\r\n*/\r\n\r\n/*\r\nToDo\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : -1,\r\n  'Type' : 'Standard',  \r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release' ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n\r\n// JavaScript 'namespace' helper routine\r\nvar globalObject = this;\r\n\r\n/* Function: namespace\r\nDeclares a new namespace.\r\n\r\nParameters:\r\n  name - string: Namespace name. Use dots for multilevel namespace.\r\n*/\r\nvar namespace = function ( name )\r\n{\r\n  var tokens = name.split( '.' );\r\n  var object = globalObject;\r\n  while ( tokens.length > 0 )\r\n  {\r\n    var token = tokens.shift();\r\n    object = object[token] = object[token] || {};\r\n  }\r\n  return object;\r\n};\r\n\r\n//############################################################################################\r\n\r\n// Array.isArray is not defined at JScript\r\nif ( Array.isArray === undefined )\r\n{\r\n  Array.isArray = function ( obj ) \r\n  {\r\n    return obj.constructor === Array;\r\n  };\r\n}\r\n\r\n//############################################################################################\r\n// Namespace: iqrf\r\nnamespace( 'iqrf' );\r\n\r\n/* String: iqrf.PNUM_Coordinator\r\nCoordinator peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_Coordinator = '00';\r\n/* String: iqrf.PNUM_Node\r\nNode peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_Node = '01';\r\n/* String: iqrf.PNUM_OS\r\nOS peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_OS = '02';\r\n/* String: iqrf.PNUM_EEPROM\r\nEEPROM peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_EEPROM = '03';\r\n/* String: iqrf.PNUM_EEEPROM\r\nExternal EEPROM peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_EEEPROM = '04';\r\n/* String: iqrf.PNUM_RAM\r\nRAM peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_RAM = '05';\r\n/* String: iqrf.PNUM_LEDR\r\nRed LED peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_LEDR = '06';\r\n/* String: iqrf.PNUM_LEDG\r\nGreen LED peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_LEDG = '07';\r\n/* String: iqrf.PNUM_SPI\r\nSPI peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_SPI = '08';\r\n/* String: iqrf.PNUM_IO\r\nIO peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_IO = '09';\r\n/* String: iqrf.PNUM_Thermometer\r\nThermometer peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_Thermometer = '0A';\r\n/* String: iqrf.PNUM_PWM\r\nPWM peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_PWM = '0B';\r\n/* String: iqrf.PNUM_UART\r\nUART peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_UART = '0C';\r\n/* String: iqrf.PNUM_FRC\r\nFRC peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_FRC = '0D';\r\n/* String: iqrf.PNUM_Enumeration\r\nEnumeration peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_Enumeration = 'FF';\r\n\r\n// PCMD response flag\r\niqrf.PCMD_ResponseFlag = 0x80;\r\n\r\n/* Constructor: iqrf.DpaRawHdpMessage\r\nCreates a raw-hdp DPA message with specified PNUM and PCMD.\r\n\r\nParameters:\r\n  pnum - string: PNUM value.\r\n  pcmd - string: PCMD value.\r\n  rdata - string: [optional] PDATA value as a string of dot separated bytes.\r\n*/\r\n\r\niqrf.DpaRawHdpMessage = function ( pnum, pcmd, rdata )\r\n{\r\n  // 'Asserts'\r\n  iqrf.ParseStringByte( pnum );\r\n  iqrf.ParseStringByte( pcmd );\r\n\r\n  this.pnum = pnum;\r\n  this.pcmd = pcmd;\r\n\r\n  this.ctype = 'dpa';\r\n  this.type = 'raw-hdp';\r\n  this.hwpid = 'FfFf';\r\n\r\n  if ( rdata !== undefined )\r\n  {\r\n    if ( typeof rdata !== 'string' )\r\n      throw new Error( 'iqrf.DpaRawHdpMessage: Optional string parameter rdata is defined but type is ' + typeof rdata );\r\n\r\n    if ( rdata.length !== 0 )\r\n    {\r\n      // 'Assert'\r\n      iqrf.ParseStringBytes( rdata );\r\n\r\n      this.rdata = rdata;\r\n    }\r\n  }\r\n};\r\n\r\n/* Constructor: iqrf.DpaRawHdpMessageCoordinator\r\nSame as <iqrf.DpaRawHdpMessage> but it also sets nadr to '00'.\r\n*/\r\niqrf.DpaRawHdpMessageCoordinator = function ( pnum, pcmd, rdata )\r\n{\r\n  var result = new iqrf.DpaRawHdpMessage( pnum, pcmd, rdata );\r\n  result.nadr = '00';\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.stricmp\r\nCompares two string in case insensitive way (not using locale).\r\n\r\nParameters:\r\n  str1 - string: 1st string to compare.\r\n  str2 - string: 2nd string to compare.\r\n\r\nReturns:\r\n  boolean: true if strings are equal, otherwise false.\r\n*/\r\niqrf.stricmp = function ( str1, str2 )\r\n{\r\n  return str1.toUpperCase() === str2.toUpperCase();\r\n};\r\n\r\n/* Function: iqrf.indexOf\r\nReturns the index of the first occurrence of a value in an array.\r\nReason for the implementation is that some engines (JScript) does not support Array.indexOf().\r\n\r\nParameters:\r\n  arr - array: An array.\r\n  val - object: The value to locate in arr.\r\n  useStricmp - boolean: [optional] if true then iqrf.stricmp() is used for the object match. Default is false.\r\n\r\nReturns:\r\n  number: The index of the first occurrence of val in the arr, or -1 if val is not found.  \r\n*/\r\niqrf.indexOf = function ( arr, val, useStricmp )\r\n{\r\n  // Test if the indexOf() is supported (e.g. JScriptEngine does not, V8ScriptEngine does)\r\n  if ( arr.indexOf !== undefined && useStricmp !== true )\r\n    return arr.indexOf( val );\r\n\r\n  var arr_length = arr.length;\r\n  for ( var indexOfResult = 0; indexOfResult < arr_length; indexOfResult++ )\r\n    if ( useStricmp === true )\r\n    {\r\n      if ( iqrf.stricmp( arr[indexOfResult], val ) )\r\n        return indexOfResult;\r\n    }\r\n    else\r\n    {\r\n      if ( arr[indexOfResult] === val )\r\n        return indexOfResult;\r\n    }\r\n\r\n  return -1;\r\n};\r\n\r\n/* Function: iqrf.CheckResponsePnumPcmdDlen\r\nChecks DPA Response.\r\n\r\nParameters:\r\n  response - object: DPA Response message (raw-hdp format)\r\n  pnum - string: Required PNUM, e.g. '01'.\r\n  pcmd - string: Required PCMD(s), e.g. '03', '04.05'.\r\n  dlen - string: [optional] Required PDATA (rdata part) length. Negative number specifies a minimum length. When not used (undefined), then no check is performed.\r\n\r\nReturns:\r\n  array: Array of bytes containing rdata bytes from the original DPA Response message.  \r\n*/\r\niqrf.CheckResponsePnumPcmdDlen = function ( response, pnum, pcmd, dlen )\r\n{\r\n  if ( response.rcode !== '00' )\r\n    throw new Error( 'iqrf.CheckResponsePnumPcmdDlen: Field response.rcode is not \\'00\\' but \\'' + response.rcode + '\\', status=' + response.status );\r\n\r\n  if ( !iqrf.stricmp( response.pnum, pnum ) )\r\n    throw new Error( 'iqrf.CheckResponsePnumPcmdDlen: Invalid pnum=' + response.pnum + ', expected ' + pnum );\r\n\r\n  if ( -1 === iqrf.indexOf( pcmd.split( '.' ), response.pcmd, true ) )\r\n    throw new Error( 'iqrf.CheckResponsePnumPcmdDlen: Invalid pcmd=' + response.pcmd + ', expected ' + pcmd );\r\n\r\n  var result = iqrf.ParseRdata( response );\r\n  if ( dlen !== undefined )\r\n  {\r\n    if ( dlen >= 0 )\r\n    {\r\n      if ( result.length !== dlen )\r\n        throw new Error( 'iqrf.CheckResponsePnumPcmdDlen: Invalid response length=' + result.length + ', expected ' + dlen );\r\n    }\r\n    else\r\n      if ( result.length < -dlen )\r\n        throw new Error( 'iqrf.CheckResponsePnumPcmdDlen: Invalid response length=' + result.length + ', expected at least ' + -dlen );\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.ParseStringByte\r\nConverts hexadecimal byte from string into a number.\r\n\r\nParameters:\r\n  byte - string: string to convert.\r\n\r\nReturns:\r\n  number: Byte value of the string.  \r\n*/\r\niqrf.ParseStringByte = function ( byte )\r\n{\r\n  if ( typeof byte !== 'string' )\r\n    throw new Error( 'ParseStringByte: Parameter byte expected string but is ' + typeof byte );\r\n\r\n  if ( byte.length !== 2 )\r\n    throw new Error( 'ParseStringByte: Parameter byte expected 2 characters long but is ' + byte.length + ' characters long' );\r\n\r\n  var result = parseInt( byte, 16 );\r\n  if ( isNaN( result ) )\r\n    throw new Error( 'ParseStringByte: Parameter byte ' + byte + ' cannot be converted from hexadecimal' );\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.ParseStringBytes\r\nSplits dot separated bytes from string into array of bytes.\r\n\r\nParameters:\r\n  bytes - string: [optional] Input string with bytes.\r\n\r\nReturns:\r\n  array: Array of bytes containing bytes from the string. If parameter bytes is not used an ampty array is returned.\r\n*/\r\niqrf.ParseStringBytes = function ( bytes )\r\n{\r\n  var result = [];\r\n  if ( bytes !== undefined )\r\n  {\r\n    if ( typeof bytes !== 'string' )\r\n      throw new Error( 'iqrf.ParseStringBytes: Type of parameter bytes is not string, but ' + typeof bytes );\r\n\r\n    if ( bytes.length !== 0 )\r\n    {\r\n      var bytesSplit = bytes.split( '.' );\r\n      while ( bytesSplit.length > 0 )\r\n        result[result.length] = iqrf.ParseStringByte( bytesSplit.shift() );\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.ParseRdata\r\nSplits rdata from DPA message (raw-hdp format) into array of bytes.\r\n\r\nParameters:\r\n  response - object: DPA message (raw-hdp format).\r\n\r\nReturns:\r\n  array: Array of bytes containing rdata bytes from the original DPA message.  \r\n*/\r\niqrf.ParseRdata = function ( response )\r\n{\r\n  return iqrf.ParseStringBytes( response.rdata );\r\n};\r\n\r\n/* Function: iqrf.ToHexStringByte\r\nConverts byte value to the 2 character long hexadecimal string.\r\n\r\nParameters:\r\n  value - number: Input byte value.\r\n\r\nReturns:\r\n  string: 2 character long hexadecimal string.  \r\n*/\r\niqrf.ToHexStringByte = function ( value )\r\n{\r\n  if ( typeof value !== 'number' )\r\n    throw new Error( 'iqrf.ToHexStringByte: Parameter value is not number but ' + typeof value );\r\n\r\n  if ( value < 0 || value > 0xFF )\r\n    throw new Error( 'iqrf.ToHexStringByte: Parameter value ' + String( value ) + ' out of range' );\r\n\r\n  var result = value.toString( 16 );\r\n  if ( result.length !== 2 )\r\n    result = '0' + result;\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.IntToHexStringBytesArray\r\nConverts integer value to hexadecimal string of the specified length containing the bytes the little-endian value consists of.\r\n\r\nParameters:\r\n  value - number: Input integer value.\r\n  length - number: Number of bytes the integer consists of.\r\n\r\nReturns:\r\n  string: String list of the individual bytes.  \r\n*/\r\niqrf.IntToHexStringBytesArray = function ( value, length )\r\n{\r\n  if ( typeof value !== 'number' )\r\n    throw new Error( 'iqrf.IntToHexStringBytesArray: Parameter value is not number but ' + typeof value );\r\n\r\n  if ( typeof length !== 'number' || length < 1 )\r\n    throw new Error( 'iqrf.IntToHexStringBytesArray: Parameter length is invalid: ' + length );\r\n\r\n  var result = '';\r\n  do\r\n  {\r\n    if ( result.length !== 0 )\r\n      result += '.';\r\n    result += iqrf.ToHexStringByte( value & 0xFF );\r\n\r\n    value >>= 8;\r\n  }\r\n  while ( --length !== 0 );\r\n\r\n  // ToDo: Improve (e.g. 2197816638 >> 8 == -8191995)\r\n  if ( value !== 0 && value !== -1 )\r\n    throw new Error( 'iqrf.IntToHexStringBytesArray: Parameter value is out of range' );\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.BytesToHexStringBytesArray\r\nConverts array of bytes to the string representation (list of dot separated 2 character long byte values).\r\n\r\nParameters:\r\n  bytes - array: Array of bytes.\r\n  prefixDot - boolean: [optional] If true then the result is always prefixed by a dot character. Default is false.\r\n  startIndex - number: [optional] Staring index of the byte to convert from. Default is 0.\r\n  endIndex - number: [optional] Ending index of the byte to convert to. Default is bytes.length - 1.\r\n\r\nReturns:\r\n  string: String list of the individual bytes.  \r\n*/\r\niqrf.BytesToHexStringBytesArray = function ( bytes, prefixDot, startIndex, endIndex )\r\n{\r\n  var result = '';\r\n  if ( bytes !== undefined )\r\n  {\r\n    if ( !Array.isArray( bytes ) )\r\n      throw new Error( 'iqrf.BytesToHexStringBytesArray: Parameter bytes is not an array but ' + typeof bytes );\r\n\r\n    if ( startIndex === undefined )\r\n      startIndex = 0;\r\n\r\n    if ( endIndex === undefined )\r\n      endIndex = bytes.length - 1;\r\n\r\n    for ( var index = startIndex; index <= endIndex; index++ )\r\n    {\r\n      if ( result.length !== 0 || prefixDot === true )\r\n        result += '.';\r\n      result += iqrf.ToHexStringByte( bytes[index] );\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.BitmapToIndexes\r\nReturns an array of indexes of set bits in the bitmap.\r\n\r\nParameters:\r\n  bitmap - array: Array of bytes.\r\n  indexFrom - number: Starting index of the byte in the bitmap.\r\n  indexTo - number: Ending index of the byte in the bitmap.\r\n  offset - number: [optional] Value to start indexing from. Default value is 0.\r\n\r\nReturns:\r\n  array: Array of integers specifying the offset indexes of bits set in the bitmap.  \r\n*/\r\niqrf.BitmapToIndexes = function ( bitmap, indexFrom, indexTo, offset )\r\n{\r\n  if ( !Array.isArray( bitmap ) )\r\n    throw new Error( 'iqrf.BitmapToIndexes: Parameter bitmap is not an array but ' + typeof bitmap );\r\n\r\n  if ( offset === undefined )\r\n    offset = 0;\r\n\r\n  var result = [];\r\n  for ( var index = indexFrom; index <= indexTo; index++ )\r\n  {\r\n    var bitmapByte = bitmap[index];\r\n    if ( bitmapByte === 0 )\r\n      offset += 8;\r\n    else\r\n      for ( var bitMask = 0x01; bitMask !== 0x100; bitMask <<= 1 )\r\n      {\r\n        if ( ( bitmapByte & bitMask ) !== 0 )\r\n          result[result.length] = offset;\r\n        offset++;\r\n      }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.IndexesToBitmap\r\nReturns an array of bytes with the selected indexes.\r\n\r\nParameters:\r\n  indexes - array: array of integers each specifying the index of bit to set in the bitmap.\r\n  bitmapSize - number: Size of the bitmap in bytes.\r\n\r\nReturns:\r\n  array: Array of bytes with the bit set according to the indexes parameter.  \r\n*/\r\niqrf.IndexesToBitmap = function ( indexes, bitmapSize )\r\n{\r\n  if ( !Array.isArray( indexes ) )\r\n    throw new Error( 'iqrf.IndexesToBitmap: Parameter bitmap is not an array but ' + typeof indexes );\r\n\r\n  var bitmap = [];\r\n  for ( var index = 0; index < bitmapSize; index++ )\r\n    bitmap[index] = 0;\r\n\r\n  var indexes_length = indexes.length;\r\n  for ( index = 0; index < indexes_length; index++ )\r\n  {\r\n    var oneIndex = indexes[index];\r\n    var bitmapIndex = Math.floor( oneIndex / 8 );\r\n    if ( bitmapIndex >= bitmapSize )\r\n      throw new Error( 'iqrf.IndexesToBitmap: Index ' + oneIndex + ' out of bitmap size ' + bitmapSize );\r\n\r\n    bitmap[bitmapIndex] |= 1 << ( oneIndex % 8 );\r\n  }\r\n\r\n  return bitmap;\r\n};\r\n\r\n/* Function: iqrf.NormalizeStringByte\r\nConverts string byte into 2 character string for sure.\r\n\r\nParameters:\r\n  byte - string: string byte value to normalize.\r\n\r\nReturns:\r\n  string: 2 character long hexadecimal string.\r\n*/\r\niqrf.NormalizeStringByte = function ( byte )\r\n{\r\n  return iqrf.ToHexStringByte( iqrf.ParseStringByte( byte ) );\r\n};\r\n\r\n/* Function: iqrf.UInt16toInt16\r\nConverts one's complement signed value stored at unsigned word (2 bytes or 16 bits) into signed 16 bit value.\r\n\r\nParameters:\r\n  uint16 - number: Input unsigned 16 bit value containing 16 bit signed value.\r\n\r\nReturns:\r\n  number: Signed 16 bit value.\r\n*/\r\niqrf.UInt16toInt16 = function ( uint16 )\r\n{\r\n  if ( uint16 < 0 || uint16 > 0xFfFf )\r\n    throw new Error( 'iqrf.UInt16toInt16: Parameter uint16 = ' + uint16 + ' is out of range' );\r\n\r\n  return uint16 < 0x8000 ? uint16 : uint16 - 0x10000;\r\n};\r\n\r\n/* Function: iqrf.UInt8toInt8\r\nConverts one's complement signed value stored at unsigned word (1 byte or 8 bits) into signed 8 bit value.\r\n\r\nParameters:\r\n  uint8 - number: Input unsigned 8 bit value containing 8 bit signed value.\r\n\r\nReturns:\r\n  number: Signed 8 bit value.\r\n*/\r\niqrf.UInt8toInt8 = function ( uint8 )\r\n{\r\n  if ( uint8 < 0 || uint8 > 0xFf )\r\n    throw new Error( 'iqrf.UInt8toInt8: Parameter uint8 = ' + uint8 + ' is out of range' );\r\n\r\n  return uint8 < 0x80 ? uint8 : uint8 - 0x100;\r\n};\r\n\r\n//############################################################################################\r\n","notes":"Initial release","standardID":-1,"name":"Driver Library"}