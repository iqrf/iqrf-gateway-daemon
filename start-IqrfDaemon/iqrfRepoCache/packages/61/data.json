{"driver":"/* <none> */","standards":[{"version":0.00,"versionFlags":0,"driver":"// File_:   $RCSfile: _1_DriverLibrary.js,v $\r\n// Version: $Revision: 1.28 $\r\n// Date:    $Date: 2018/07/02 09:01:35 $\r\n//############################################################################################\r\n\r\n/* Title: Global IQRF driver library routines\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n\r\nBecause of potential usage of JScript at *Microsoft.ClearScript.Windows.JScriptEngine* the following features cannot used:\r\n\r\n* 'let' instead of 'var' where appropriate\r\n* 'const'\r\n* default parameter values\r\n* binary literals\r\n* enums\r\n*/\r\n\r\n/*\r\nToDo\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : -1,\r\n  'Type' : 'Standard',  \r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release' ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n\r\n// JavaScript 'namespace' helper routine\r\nvar globalObject = this;\r\n\r\n/* Function: namespace\r\nDeclares a new namespace.\r\n\r\nParameters:\r\n  name - string: Namespace name. Use dots for multilevel namespace.\r\n*/\r\nvar namespace = function ( name )\r\n{\r\n  var tokens = name.split( '.' );\r\n  var object = globalObject;\r\n  while ( tokens.length > 0 )\r\n  {\r\n    var token = tokens.shift();\r\n    object = object[token] = object[token] || {};\r\n  }\r\n  return object;\r\n};\r\n\r\n//############################################################################################\r\n\r\n// Array.isArray is not defined at JScript\r\nif ( Array.isArray === undefined )\r\n{\r\n  Array.isArray = function ( obj ) \r\n  {\r\n    return obj.constructor === Array;\r\n  };\r\n}\r\n\r\n//############################################################################################\r\n// Namespace: iqrf\r\nnamespace( 'iqrf' );\r\n\r\n/* String: iqrf.PNUM_Coordinator\r\nCoordinator peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_Coordinator = '00';\r\n/* String: iqrf.PNUM_Node\r\nNode peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_Node = '01';\r\n/* String: iqrf.PNUM_OS\r\nOS peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_OS = '02';\r\n/* String: iqrf.PNUM_EEPROM\r\nEEPROM peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_EEPROM = '03';\r\n/* String: iqrf.PNUM_EEEPROM\r\nExternal EEPROM peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_EEEPROM = '04';\r\n/* String: iqrf.PNUM_RAM\r\nRAM peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_RAM = '05';\r\n/* String: iqrf.PNUM_LEDR\r\nRed LED peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_LEDR = '06';\r\n/* String: iqrf.PNUM_LEDG\r\nGreen LED peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_LEDG = '07';\r\n/* String: iqrf.PNUM_SPI\r\nSPI peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_SPI = '08';\r\n/* String: iqrf.PNUM_IO\r\nIO peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_IO = '09';\r\n/* String: iqrf.PNUM_Thermometer\r\nThermometer peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_Thermometer = '0A';\r\n/* String: iqrf.PNUM_PWM\r\nPWM peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_PWM = '0B';\r\n/* String: iqrf.PNUM_UART\r\nUART peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_UART = '0C';\r\n/* String: iqrf.PNUM_FRC\r\nFRC peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_FRC = '0D';\r\n/* String: iqrf.PNUM_Enumeration\r\nEnumeration peripheral byte value as a hexadecimal string.\r\n*/\r\niqrf.PNUM_Enumeration = 'FF';\r\n\r\n// PCMD response flag\r\niqrf.PCMD_ResponseFlag = 0x80;\r\n\r\n/* Constructor: iqrf.DpaRawHdpMessage\r\nCreates a raw-hdp DPA message with specified PNUM and PCMD.\r\n\r\nParameters:\r\n  pnum - string: PNUM value.\r\n  pcmd - string: PCMD value.\r\n  rdata - string: [optional] PDATA value as a string of dot separated bytes.\r\n*/\r\n\r\niqrf.DpaRawHdpMessage = function ( pnum, pcmd, rdata )\r\n{\r\n  // 'Asserts'\r\n  iqrf.ParseStringByte( pnum );\r\n  iqrf.ParseStringByte( pcmd );\r\n\r\n  this.pnum = pnum;\r\n  this.pcmd = pcmd;\r\n\r\n  this.ctype = 'dpa';\r\n  this.type = 'raw-hdp';\r\n  this.hwpid = 'FfFf';\r\n\r\n  if ( rdata !== undefined )\r\n  {\r\n    if ( typeof rdata !== 'string' )\r\n      throw new Error( 'iqrf.DpaRawHdpMessage: Optional string parameter rdata is defined but type is ' + typeof rdata );\r\n\r\n    if ( rdata.length !== 0 )\r\n    {\r\n      // 'Assert'\r\n      iqrf.ParseStringBytes( rdata );\r\n\r\n      this.rdata = rdata;\r\n    }\r\n  }\r\n};\r\n\r\n/* Constructor: iqrf.DpaRawHdpMessageCoordinator\r\nSame as <iqrf.DpaRawHdpMessage> but it also sets nadr to '00'.\r\n*/\r\niqrf.DpaRawHdpMessageCoordinator = function ( pnum, pcmd, rdata )\r\n{\r\n  var result = new iqrf.DpaRawHdpMessage( pnum, pcmd, rdata );\r\n  result.nadr = '00';\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.stricmp\r\nCompares two string in case insensitive way (not using locale).\r\n\r\nParameters:\r\n  str1 - string: 1st string to compare.\r\n  str2 - string: 2nd string to compare.\r\n\r\nReturns:\r\n  boolean: true if strings are equal, otherwise false.\r\n*/\r\niqrf.stricmp = function ( str1, str2 )\r\n{\r\n  return str1.toUpperCase() === str2.toUpperCase();\r\n};\r\n\r\n/* Function: iqrf.indexOf\r\nReturns the index of the first occurrence of a value in an array.\r\nReason for the implementation is that some engines (JScript) does not support Array.indexOf().\r\n\r\nParameters:\r\n  arr - array: An array.\r\n  val - object: The value to locate in arr.\r\n  useStricmp - boolean: [optional] if true then iqrf.stricmp() is used for the object match. Default is false.\r\n\r\nReturns:\r\n  number: The index of the first occurrence of val in the arr, or -1 if val is not found.  \r\n*/\r\niqrf.indexOf = function ( arr, val, useStricmp )\r\n{\r\n  // Test if the indexOf() is supported (e.g. JScriptEngine does not, V8ScriptEngine does)\r\n  if ( arr.indexOf !== undefined && useStricmp !== true )\r\n    return arr.indexOf( val );\r\n\r\n  var arr_length = arr.length;\r\n  for ( var indexOfResult = 0; indexOfResult < arr_length; indexOfResult++ )\r\n    if ( useStricmp === true )\r\n    {\r\n      if ( iqrf.stricmp( arr[indexOfResult], val ) )\r\n        return indexOfResult;\r\n    }\r\n    else\r\n    {\r\n      if ( arr[indexOfResult] === val )\r\n        return indexOfResult;\r\n    }\r\n\r\n  return -1;\r\n};\r\n\r\n/* Function: iqrf.CheckResponsePnumPcmdDlen\r\nChecks DPA Response.\r\n\r\nParameters:\r\n  response - object: DPA Response message (raw-hdp format)\r\n  pnum - string: Required PNUM, e.g. '01'.\r\n  pcmd - string: Required PCMD(s), e.g. '03', '04.05'.\r\n  dlen - string: [optional] Required PDATA (rdata part) length. Negative number specifies a minimum length. When not used (undefined), then no check is performed.\r\n\r\nReturns:\r\n  array: Array of bytes containing rdata bytes from the original DPA Response message.  \r\n*/\r\niqrf.CheckResponsePnumPcmdDlen = function ( response, pnum, pcmd, dlen )\r\n{\r\n  if ( response.rcode !== '00' )\r\n    throw new Error( 'iqrf.CheckResponsePnumPcmdDlen: Field response.rcode is not \\'00\\' but \\'' + response.rcode + '\\', status=' + response.status );\r\n\r\n  if ( !iqrf.stricmp( response.pnum, pnum ) )\r\n    throw new Error( 'iqrf.CheckResponsePnumPcmdDlen: Invalid pnum=' + response.pnum + ', expected ' + pnum );\r\n\r\n  if ( -1 === iqrf.indexOf( pcmd.split( '.' ), response.pcmd, true ) )\r\n    throw new Error( 'iqrf.CheckResponsePnumPcmdDlen: Invalid pcmd=' + response.pcmd + ', expected ' + pcmd );\r\n\r\n  var result = iqrf.ParseRdata( response );\r\n  if ( dlen !== undefined )\r\n  {\r\n    if ( dlen >= 0 )\r\n    {\r\n      if ( result.length !== dlen )\r\n        throw new Error( 'iqrf.CheckResponsePnumPcmdDlen: Invalid response length=' + result.length + ', expected ' + dlen );\r\n    }\r\n    else\r\n      if ( result.length < -dlen )\r\n        throw new Error( 'iqrf.CheckResponsePnumPcmdDlen: Invalid response length=' + result.length + ', expected at least ' + -dlen );\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.ParseStringByte\r\nConverts hexadecimal byte from string into a number.\r\n\r\nParameters:\r\n  byte - string: string to convert.\r\n\r\nReturns:\r\n  number: Byte value of the string.  \r\n*/\r\niqrf.ParseStringByte = function ( byte )\r\n{\r\n  if ( typeof byte !== 'string' )\r\n    throw new Error( 'ParseStringByte: Parameter byte expected string but is ' + typeof byte );\r\n\r\n  if ( byte.length !== 2 )\r\n    throw new Error( 'ParseStringByte: Parameter byte expected 2 characters long but is ' + byte.length + ' characters long' );\r\n\r\n  var result = parseInt( byte, 16 );\r\n  if ( isNaN( result ) )\r\n    throw new Error( 'ParseStringByte: Parameter byte ' + byte + ' cannot be converted from hexadecimal' );\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.ParseStringBytes\r\nSplits dot separated bytes from string into array of bytes.\r\n\r\nParameters:\r\n  bytes - string: [optional] Input string with bytes.\r\n\r\nReturns:\r\n  array: Array of bytes containing bytes from the string. If parameter bytes is not used an ampty array is returned.\r\n*/\r\niqrf.ParseStringBytes = function ( bytes )\r\n{\r\n  var result = [];\r\n  if ( bytes !== undefined )\r\n  {\r\n    if ( typeof bytes !== 'string' )\r\n      throw new Error( 'iqrf.ParseStringBytes: Type of parameter bytes is not string, but ' + typeof bytes );\r\n\r\n    if ( bytes.length !== 0 )\r\n    {\r\n      var bytesSplit = bytes.split( '.' );\r\n      while ( bytesSplit.length > 0 )\r\n        result[result.length] = iqrf.ParseStringByte( bytesSplit.shift() );\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.ParseRdata\r\nSplits rdata from DPA message (raw-hdp format) into array of bytes.\r\n\r\nParameters:\r\n  response - object: DPA message (raw-hdp format).\r\n\r\nReturns:\r\n  array: Array of bytes containing rdata bytes from the original DPA message.  \r\n*/\r\niqrf.ParseRdata = function ( response )\r\n{\r\n  return iqrf.ParseStringBytes( response.rdata );\r\n};\r\n\r\n/* Function: iqrf.ToHexStringByte\r\nConverts byte value to the 2 character long hexadecimal string.\r\n\r\nParameters:\r\n  value - number: Input byte value.\r\n\r\nReturns:\r\n  string: 2 character long hexadecimal string.  \r\n*/\r\niqrf.ToHexStringByte = function ( value )\r\n{\r\n  if ( typeof value !== 'number' )\r\n    throw new Error( 'iqrf.ToHexStringByte: Parameter value is not number but ' + typeof value );\r\n\r\n  if ( value < 0 || value > 0xFF )\r\n    throw new Error( 'iqrf.ToHexStringByte: Parameter value ' + String( value ) + ' out of range' );\r\n\r\n  var result = value.toString( 16 );\r\n  if ( result.length !== 2 )\r\n    result = '0' + result;\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.IntToHexStringBytesArray\r\nConverts integer value to hexadecimal string of the specified length containing the bytes the little-endian value consists of.\r\n\r\nParameters:\r\n  value - number: Input integer value.\r\n  length - number: Number of bytes the integer consists of.\r\n\r\nReturns:\r\n  string: String list of the individual bytes.  \r\n*/\r\niqrf.IntToHexStringBytesArray = function ( value, length )\r\n{\r\n  if ( typeof value !== 'number' )\r\n    throw new Error( 'iqrf.IntToHexStringBytesArray: Parameter value is not number but ' + typeof value );\r\n\r\n  if ( typeof length !== 'number' || length < 1 )\r\n    throw new Error( 'iqrf.IntToHexStringBytesArray: Parameter length is invalid: ' + length );\r\n\r\n  var result = '';\r\n  do\r\n  {\r\n    if ( result.length !== 0 )\r\n      result += '.';\r\n    result += iqrf.ToHexStringByte( value & 0xFF );\r\n\r\n    value >>= 8;\r\n  }\r\n  while ( --length !== 0 );\r\n\r\n  // ToDo: Improve (e.g. 2197816638 >> 8 == -8191995)\r\n  if ( value !== 0 && value !== -1 )\r\n    throw new Error( 'iqrf.IntToHexStringBytesArray: Parameter value is out of range' );\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.BytesToHexStringBytesArray\r\nConverts array of bytes to the string representation (list of dot separated 2 character long byte values).\r\n\r\nParameters:\r\n  bytes - array: Array of bytes.\r\n  prefixDot - boolean: [optional] If true then the result is always prefixed by a dot character. Default is false.\r\n  startIndex - number: [optional] Staring index of the byte to convert from. Default is 0.\r\n  endIndex - number: [optional] Ending index of the byte to convert to. Default is bytes.length - 1.\r\n\r\nReturns:\r\n  string: String list of the individual bytes.  \r\n*/\r\niqrf.BytesToHexStringBytesArray = function ( bytes, prefixDot, startIndex, endIndex )\r\n{\r\n  var result = '';\r\n  if ( bytes !== undefined )\r\n  {\r\n    if ( !Array.isArray( bytes ) )\r\n      throw new Error( 'iqrf.BytesToHexStringBytesArray: Parameter bytes is not an array but ' + typeof bytes );\r\n\r\n    if ( startIndex === undefined )\r\n      startIndex = 0;\r\n\r\n    if ( endIndex === undefined )\r\n      endIndex = bytes.length - 1;\r\n\r\n    for ( var index = startIndex; index <= endIndex; index++ )\r\n    {\r\n      if ( result.length !== 0 || prefixDot === true )\r\n        result += '.';\r\n      result += iqrf.ToHexStringByte( bytes[index] );\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.BitmapToIndexes\r\nReturns an array of indexes of set bits in the bitmap.\r\n\r\nParameters:\r\n  bitmap - array: Array of bytes.\r\n  indexFrom - number: Starting index of the byte in the bitmap.\r\n  indexTo - number: Ending index of the byte in the bitmap.\r\n  offset - number: [optional] Value to start indexing from. Default value is 0.\r\n\r\nReturns:\r\n  array: Array of integers specifying the offset indexes of bits set in the bitmap.  \r\n*/\r\niqrf.BitmapToIndexes = function ( bitmap, indexFrom, indexTo, offset )\r\n{\r\n  if ( !Array.isArray( bitmap ) )\r\n    throw new Error( 'iqrf.BitmapToIndexes: Parameter bitmap is not an array but ' + typeof bitmap );\r\n\r\n  if ( offset === undefined )\r\n    offset = 0;\r\n\r\n  var result = [];\r\n  for ( var index = indexFrom; index <= indexTo; index++ )\r\n  {\r\n    var bitmapByte = bitmap[index];\r\n    if ( bitmapByte === 0 )\r\n      offset += 8;\r\n    else\r\n      for ( var bitMask = 0x01; bitMask !== 0x100; bitMask <<= 1 )\r\n      {\r\n        if ( ( bitmapByte & bitMask ) !== 0 )\r\n          result[result.length] = offset;\r\n        offset++;\r\n      }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.IndexesToBitmap\r\nReturns an array of bytes with the selected indexes.\r\n\r\nParameters:\r\n  indexes - array: array of integers each specifying the index of bit to set in the bitmap.\r\n  bitmapSize - number: Size of the bitmap in bytes.\r\n\r\nReturns:\r\n  array: Array of bytes with the bit set according to the indexes parameter.  \r\n*/\r\niqrf.IndexesToBitmap = function ( indexes, bitmapSize )\r\n{\r\n  if ( !Array.isArray( indexes ) )\r\n    throw new Error( 'iqrf.IndexesToBitmap: Parameter bitmap is not an array but ' + typeof indexes );\r\n\r\n  var bitmap = [];\r\n  for ( var index = 0; index < bitmapSize; index++ )\r\n    bitmap[index] = 0;\r\n\r\n  var indexes_length = indexes.length;\r\n  for ( index = 0; index < indexes_length; index++ )\r\n  {\r\n    var oneIndex = indexes[index];\r\n    var bitmapIndex = Math.floor( oneIndex / 8 );\r\n    if ( bitmapIndex >= bitmapSize )\r\n      throw new Error( 'iqrf.IndexesToBitmap: Index ' + oneIndex + ' out of bitmap size ' + bitmapSize );\r\n\r\n    bitmap[bitmapIndex] |= 1 << ( oneIndex % 8 );\r\n  }\r\n\r\n  return bitmap;\r\n};\r\n\r\n/* Function: iqrf.NormalizeStringByte\r\nConverts string byte into 2 character string for sure.\r\n\r\nParameters:\r\n  byte - string: string byte value to normalize.\r\n\r\nReturns:\r\n  string: 2 character long hexadecimal string.\r\n*/\r\niqrf.NormalizeStringByte = function ( byte )\r\n{\r\n  return iqrf.ToHexStringByte( iqrf.ParseStringByte( byte ) );\r\n};\r\n\r\n/* Function: iqrf.UInt16toInt16\r\nConverts one's complement signed value stored at unsigned word (2 bytes or 16 bites) into signed 16 bit value.\r\n\r\nParameters:\r\n  uint16 - number: Input unsigned 16 bit value containing 16 bit signed value.\r\n\r\nReturns:\r\n  number: Signed 16 bit value.\r\n*/\r\niqrf.UInt16toInt16 = function ( uint16 )\r\n{\r\n  if ( uint16 < 0 || uint16 > 0xFfFf )\r\n    throw new Error( 'iqrf.UInt16toInt16: Parameter uint16 = ' + uint16 + ' is out of range' );\r\n\r\n  return uint16 < 0x8000 ? uint16 : uint16 - 0x10000;\r\n};\r\n\r\n//############################################################################################\r\n","notes":"Initial release","standardID":-1,"name":"Driver Library"},{"version":15.00,"versionFlags":0,"driver":"// File_:   $RCSfile: 5E_IqrfStandardSensor.js,v $\r\n// Version: $Revision: 1.35 $\r\n// Date:    $Date: 2018/07/09 15:13:45 $\r\n//############################################################################################\r\n\r\n/* Title: IQRF Standards Sensor driver\r\nSee also: <https://www.iqrfalliance.org/techDocs/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x5E,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 15, 'Notes' : [\r\n        '+ New quantities added (TimeSpan, Illuminance, NO2 (nitrogen dioxide), SO2 (sulfur dioxide), CO (carbon monoxide), O3 (ozone), Atmospheric Pressure, Color Temperature, TimeSpanLong).',\r\n        '+ New quantity added (Data Block).',\r\n        '! Fixed negative numbers calculation for signed quantities.' ,\r\n        '! Fixed computation of Earth’s Magnetic Field value.' ,\r\n        '+ Error sensor values detected and returned as NaN.',\r\n        '+ Sensor enumeration gives list of supported FRC commands.',\r\n        '+ iqrf.sensor.Frc* functions added.' ,\r\n        '+ Optional parameter writtenData at iqrf.sensor.ReadSensorsWithTypes_Request.' ]\r\n    },\r\n    { 'Version' : 14, 'Notes' : [\r\n        '- Initial public release' ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.sensor\r\nnamespace( 'iqrf.sensor' );\r\n\r\n// IQRF Standards Sensor PNUM value\r\niqrf.sensor.PNUM = '5e';\r\n\r\n// IQRF Sensor standard peripheral - sensor types\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE\r\nTemperature sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE = 0x01;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_CO2\r\nCarbon dioxide sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_CO2 = 0x02;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_VOC\r\nVolatile organic compounds sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_VOC = 0x03;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE\r\nExtra-low voltage sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE = 0x04;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD\r\nEarth’s magnetic field sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD = 0x05;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE\r\nLow voltage sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE = 0x06;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_CURRENT\r\nCurrent sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_CURRENT = 0x07;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_POWER\r\nPower sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_POWER = 0x08;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY\r\nMains frequency sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY = 0x09;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN\r\nTimespan value.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_TIMESPAN = 0x0A;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE\r\nIlluminance sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE = 0x0B;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_NO2\r\nNitrogen dioxide sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_NO2 = 0x0C;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_SO2\r\nSulfur dioxide sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_SO2 = 0x0D;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_CO\r\nCarbon monoxide sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_CO = 0x0E;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_O3\r\nOzone sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_O3 = 0x0F;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE\r\nAtmospheric pressure sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE = 0x10;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE\r\nColor temperature sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE = 0x11;\r\n\r\n//  1 byte\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY\r\nRelative humidity sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY = 0x80;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7\r\n7 bits binary data sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7 = 0x81;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR\r\nPower factor sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR = 0x82;\r\n\r\n//  4 bytes\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30\r\n30 bits binary data sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30 = 0xA0;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_CONSUMPTION\r\nConsumption sensor.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_CONSUMPTION = 0xA1;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_DATETIME\r\nDate and time vallue.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_DATETIME = 0xA2;\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN_LONG\r\nLong timespan value.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_TIMESPAN_LONG = 0xA3;\r\n\r\n//  Multiple bytes\r\n/* Const: iqrf.sensor.STD_SENSOR_TYPE_DATA_BLOCK\r\nData block containing proprietary data.\r\n*/\r\niqrf.sensor.STD_SENSOR_TYPE_DATA_BLOCK = 0xC0;\r\n\r\n// FRC commands\r\n/* Const: iqrf.sensor.STD_SENSOR_FRC_2BITS\r\nFRC command to return 2-bits sensor data of the supporting sensor types.\r\n*/\r\niqrf.sensor.STD_SENSOR_FRC_2BITS = 0x10;\r\n/* Const: iqrf.sensor.STD_SENSOR_FRC_1BYTE\r\nFRC command to return 1-byte wide sensor data of the supporting sensor types. \r\n*/\r\niqrf.sensor.STD_SENSOR_FRC_1BYTE = 0x90;\r\n/* Const: iqrf.sensor.STD_SENSOR_FRC_2BYTES\r\nFRC command to return 2-bytes wide sensor data of the supporting sensor types.\r\n*/\r\niqrf.sensor.STD_SENSOR_FRC_2BYTES = 0xE0;\r\n\r\n// Sensor types\r\niqrf.sensor.SensorTypes = [];\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE] =\r\n  {\r\n    name: 'Temperature',\r\n    shortName: 'T',\r\n    unit: '°C',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE, iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_CO2] =\r\n  {\r\n    name: 'Carbon dioxide',\r\n    shortName: 'CO2',\r\n    unit: 'ppm',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE, iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_VOC] =\r\n  {\r\n    name: 'Volatile organic compound',\r\n    shortName: 'VOC',\r\n    unit: 'ppm',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE, iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE] =\r\n  {\r\n    name: 'Extra-low voltage',\r\n    shortName: 'U',\r\n    unit: 'V',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD] =\r\n  {\r\n    name: 'Earth’s magnetic field',\r\n    shortName: 'B',\r\n    unit: 'T',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE] =\r\n  {\r\n    name: 'Low voltage',\r\n    shortName: 'U',\r\n    unit: 'V',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_CURRENT] =\r\n  {\r\n    name: 'Current',\r\n    shortName: 'I',\r\n    unit: 'A',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_POWER] =\r\n  {\r\n    name: 'Power',\r\n    shortName: 'E',\r\n    unit: 'W',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY] =\r\n  {\r\n    name: 'Mains frequency',\r\n    shortName: 'f',\r\n    unit: 'Hz',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY] =\r\n  {\r\n    name: 'Timespan',\r\n    shortName: 't',\r\n    unit: 's',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE] =\r\n  {\r\n    name: 'Illuminance',\r\n    shortName: 'Ev',\r\n    unit: 'lx',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_NO2] =\r\n  {\r\n    name: 'Nitrogen dioxide',\r\n    shortName: 'NO2',\r\n    unit: 'ppm',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_SO2] =\r\n  {\r\n    name: 'Sulfur dioxide',\r\n    shortName: 'SO2',\r\n    unit: 'ppm',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_CO] =\r\n  {\r\n    name: 'Carbon monoxide',\r\n    shortName: 'CO',\r\n    unit: 'ppm',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_O3] =\r\n  {\r\n    name: 'Ozone',\r\n    shortName: 'O3',\r\n    unit: 'ppm',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE] =\r\n  {\r\n    name: 'Atmospheric pressure',\r\n    shortName: 'p',\r\n    unit: 'hPa',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE] =\r\n  {\r\n    name: 'Color temperature',\r\n    shortName: 'Tc',\r\n    unit: 'K',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY] =\r\n  {\r\n    name: 'Relative humidity',\r\n    shortName: 'RH',\r\n    unit: '%',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7] =\r\n  {\r\n    name: 'Binary data7',\r\n    shortName: 'bin7',\r\n    unit: '?',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BITS, iqrf.sensor.STD_SENSOR_FRC_1BYTE]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR] =\r\n  {\r\n    name: 'Power factor',\r\n    shortName: 'cos φ',\r\n    unit: '',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_1BYTE]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30] =\r\n  {\r\n    name: 'Binary data30',\r\n    shortName: 'bin30',\r\n    unit: '?',\r\n    frcs: [iqrf.sensor.STD_SENSOR_FRC_2BYTES]\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_CONSUMPTION] =\r\n  {\r\n    name: 'Consumption',\r\n    shortName: 'E',\r\n    unit: 'Wh',\r\n    frcs: []\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_DATETIME] =\r\n  {\r\n    name: 'DateTime',\r\n    shortName: 'DateTime',\r\n    unit: '',\r\n    frcs: []\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN_LONG] =\r\n  {\r\n    name: 'Timespan long',\r\n    shortName: 't',\r\n    unit: 's',\r\n    frcs: []\r\n  };\r\niqrf.sensor.SensorTypes[iqrf.sensor.STD_SENSOR_TYPE_DATA_BLOCK] =\r\n  {\r\n    name: 'Data block',\r\n    shortName: 'datablock',\r\n    unit: '?',\r\n    frcs: []\r\n  };\r\n\r\n\r\n/* Function: iqrf.sensor.Enumerate_Request\r\nEncodes DPA request to enumerate sensors.\r\n\r\nReturns:\r\n  string: DPA request string.  \r\n*/\r\niqrf.sensor.Enumerate_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.sensor.PNUM, '3e' );\r\n};\r\n\r\n/* Function: iqrf.sensor.Enumerate_Response\r\nDecodes DPA response from sensor enumeration.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Array of objects describing each sensor. The object has the following fields:\r\n\r\n* type - number: Value type of the sensor (quantity). See IQRF Sensor standard for details.\r\n* name - string: Name of the sensor (quantity).\r\n* shortName - string: Short name of the sensor (quantity). Typically it is a symbol used at physics.\r\n* unit - string: Unit of the quantity. Dimensionless quantity has empty string \"\".\r\n* frcs - array: Array of FRC commands supported by the sensor.\r\n*/\r\niqrf.sensor.Enumerate_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.sensor.PNUM, 'be', -1 );\r\n\r\n  var result = [];\r\n  for ( var index in responseData )\r\n  {\r\n    var sensorType = responseData[index];\r\n    var sensorObj = iqrf.sensor.SensorTypes[sensorType];\r\n    if ( sensorObj === undefined )\r\n      throw new Error( 'iqrf.sensor.Enumerate_Response: Unknown sensor type ' + sensorType );\r\n\r\n    result[result.length] =\r\n      {\r\n        type: sensorType,\r\n        name: sensorObj.name,\r\n        shortName: sensorObj.shortName,\r\n        unit: sensorObj.unit,\r\n        frcs: sensorObj.frcs\r\n      };\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\niqrf.sensor.Indexes2bitmap = function ( sensorIndexes )\r\n{\r\n  var bitmap = 0;\r\n  for ( var index in sensorIndexes )\r\n    bitmap |= 1 << sensorIndexes[index];\r\n\r\n  return iqrf.IntToHexStringBytesArray( bitmap, 4 );\r\n};\r\n\r\n/* Function: iqrf.sensor.ReadSensorsWithTypes_Request\r\nEncodes DPA request to read sensors values.\r\n\r\nParameters:\r\n  sensorIndexes - Specifies sensors to read data from:\r\n\r\n* undefined: Missing parameter: reads 1st sensor.\r\n* number: -1: reads all sensors.\r\n* array: array of indexes: specifies sensors to read.\r\n  \r\n  writtenData - array: [optional] array of 5-bytes-arrays (for each sensor). See IQRF Sensor standards for details.\r\n\r\nReturns:\r\n  string: DPA request string.  \r\n*/\r\niqrf.sensor.ReadSensorsWithTypes_Request = function ( sensorIndexes, writtenData )\r\n{\r\n  var result = new iqrf.DpaRawHdpMessage( iqrf.sensor.PNUM, '01' );\r\n  if ( sensorIndexes !== undefined )\r\n  {\r\n    if ( sensorIndexes === -1 )\r\n      result.rdata = 'ff.ff.ff.ff';\r\n    else\r\n      result.rdata = iqrf.sensor.Indexes2bitmap( sensorIndexes );\r\n  }\r\n\r\n  if ( writtenData !== undefined )\r\n  {\r\n    var writtenData_length = writtenData.length;\r\n    for ( var index = 0; index < writtenData_length; index++ )\r\n    {\r\n      var oneData = writtenData[index];\r\n      if ( oneData.length !== 5 )\r\n        throw new Error( 'iqrf.sensor.ReadSensorsWithTypes_Request: Written data item length is not 5 but ' + oneData.length );\r\n\r\n      result.rdata += iqrf.BytesToHexStringBytesArray( oneData, true );\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.sensor.ReadSensorsWithTypes_Response\r\nDecodes DPA response from sensor value reading.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Array of objects for every read sensor. The object has the following fields:\r\n\r\n* type - number: Value type of the sensor (quantity). See IQRF Sensor standard for details.\r\n* name - string: Name of the sensor (quantity).\r\n* shortName - string: Short name of the sensor (quantity). Typically it is a symbol used at physics.\r\n* value - number: Value of the sensor. It equals to NaN to indicate an error value.\r\n* unit - string: Unit of the quantity. Dimensionless quantity has empty string \"\".\r\n\r\n--- Text\r\nExample:\r\n\r\n{\r\n  \"length\": 3,\r\n  \"0\": {\r\n    \"type\": 1,\r\n    \"name\": \"Temperature\"\r\n    \"shortName\": \"T\",\r\n    \"value\": 22.3,\r\n    \"unit\": \"°C\"\r\n  },\r\n  \"1\": {\r\n    \"type\": 128,\r\n    \"name\": \"Relative humidity\"\r\n    \"shortName\": \"RH\",\r\n    \"value\": 35,\r\n    \"unit\": \"%\"\r\n  },\r\n  \"2\": {\r\n    \"type\": 9,\r\n    \"name\": \"Mains frequency\",\r\n    \"shortName\": \"f\",\r\n    \"value\": 49.98,\r\n    \"unit\": \"Hz\"\r\n  }\r\n}\r\n---\r\n*/\r\niqrf.sensor.ReadSensorsWithTypes_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.sensor.PNUM, '81' );\r\n\r\n  var result = [];\r\n  var responseData_length = responseData.length;\r\n  for ( var index = 0; index < responseData_length; )\r\n  {\r\n    var sensorType = responseData[index++];\r\n    var sensorObj = iqrf.sensor.SensorTypes[sensorType];\r\n    if ( sensorObj === undefined )\r\n      throw new Error( 'iqrf.sensor.ReadSensorsWithTypes_Response: Unknown sensor type ' + sensorType );\r\n\r\n    var sensorValue;\r\n\r\n    switch ( sensorType )\r\n    {\r\n      default:\r\n        throw new Error( 'iqrf.sensor.ReadSensorsWithTypes_Response: Unimplemented sensor type value ' + sensorType );\r\n\r\n      // 2 bytes\r\n      // ----------------\r\n      case iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : iqrf.UInt16toInt16( sensorValue ) / 16.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 16.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_CO2:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_VOC:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        if ( sensorValue === 0x8000 )\r\n          sensorvalue = NaN;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        if ( sensorValue === 0xFfFf )\r\n          sensorvalue = NaN;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_CURRENT:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : iqrf.UInt16toInt16( sensorValue ) / 1000.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_NO2:\r\n      case iqrf.sensor.STD_SENSOR_TYPE_SO2:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 1000.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0x8000 ? NaN : iqrf.UInt16toInt16( sensorValue ) / 10000000.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_POWER:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 4.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_CO:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 100.0;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_O3:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 );\r\n        sensorValue = sensorValue === 0xFfFf ? NaN : sensorValue / 10000.0;\r\n        break;\r\n\r\n      // 1 byte\r\n      // ----------------\r\n      case iqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY:\r\n        sensorValue = responseData[index] === 0xEE ? NaN : ( responseData[index] / 2.0 );\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7:\r\n        sensorValue = ( responseData[index] & 0x80 ) !== 0 ? NaN : responseData[index];\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR:\r\n        sensorValue = responseData[index] === 0xEE ? NaN : responseData[index] / 200.0;\r\n        break;\r\n\r\n      // 4 bytes\r\n      // ----------------\r\n      case iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30:\r\n        sensorValue = ( responseData[index + 3] & 0x80 ) !== 0 ? NaN : ( responseData[index] + ( responseData[index + 1] * 0x100 ) + ( responseData[index + 2]  * 0x10000 ) + ( responseData[index + 3]  * 0x1000000 ) );\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_CONSUMPTION:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 ) + ( responseData[index + 2] * 0x10000 ) + ( responseData[index + 3]  * 0x1000000 );\r\n        if ( sensorValue === -1 )\r\n          sensorvalue = NaN;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_DATETIME:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 ) + ( responseData[index + 2] * 0x10000 ) + ( responseData[index + 3] * 0x1000000 );\r\n        if ( sensorValue === -1 )\r\n          sensorValue = NaN;\r\n        break;\r\n\r\n      case iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN_LONG:\r\n        sensorValue = responseData[index] + ( responseData[index + 1] * 0x100 ) + ( responseData[index + 2] * 0x10000 ) + ( responseData[index + 3] * 0x1000000 );\r\n        sensorValue = sensorValue === -1 ? NaN : sensorValue / 16.0;\r\n        break;\r\n\r\n      // Multiple bytes\r\n      // ----------------\r\n      case iqrf.sensor.STD_SENSOR_TYPE_DATA_BLOCK:\r\n        {\r\n          sensorValue = [];\r\n          var length = responseData[index];\r\n          for ( var dataIndex = 1; dataIndex <= length; dataIndex++ )\r\n            sensorValue[sensorValue.length] = responseData[index + dataIndex];\r\n          break;\r\n        }\r\n    }\r\n\r\n    result[result.length] =\r\n      {\r\n        type: sensorType,\r\n        name: sensorObj.name,\r\n        shortName: sensorObj.shortName,\r\n        value: sensorValue,\r\n        unit: sensorObj.unit\r\n      };\r\n\r\n    var sensorDataLength;\r\n    if ( ( sensorType & 0x80 ) === 0 )\r\n      sensorDataLength = 2;\r\n    else if ( ( sensorType & 0xE0 ) === 0x80 )\r\n      sensorDataLength = 1;\r\n    else if ( ( sensorType & 0xE0 ) === 0xA0 )\r\n      sensorDataLength = 4;\r\n    else\r\n      sensorDataLength = responseData[index] + 1;\r\n\r\n    index += sensorDataLength;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.sensor.Frc_Request\r\nPrepares FRC request to read standard sensor values.\r\n_Requires FRC embedded peripheral driver_.\r\n\r\nParameters:\r\n  sensorType - number: Type of sensor (quantity) to read values of. Use iqrf.sensor.STD_SENSOR_TYPE_* constant. Use 0 to specify the sensor only by sensorIndex parameter.\r\n  sensorIndex - number: Index of the sensor. If the sensor type is specified, then its is an index among of all sensors of the specified type. If sensorType is 0 then it is overall sensor index. Some FRC commands might use top 3 bits of this parameter for passing additional data.\r\n  frcCommand - number: One of predefined standard sensor FRC commands. See iqrf.sensor.STD_SENSOR_FRC_* constants.\r\n  selectedNodes - array: [optional] Array if integer values corresponding to the selected nodes. Use default value to select all nodes and use sleepAfterFrc parameter.\r\n  sleepAfterFrc - object: [optional] Object with the following fields to put the nodes into sleep mode after the FRC is finished:\r\n      * time - number: See DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n      * control - number: See DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n\r\nReturns: \r\n  array: 2 items long array. 1st item is a prepared request to initiate the RFC. 2nd item is a prepared request to get additional FRC data from the network. For smaller networks extra FRC result might not be needed.\r\n*/\r\niqrf.sensor.Frc_Request = function ( sensorType, sensorIndex, frcCommand, selectedNodes, sleepAfterFrc )\r\n{\r\n  var userData = [0x5E, sensorType, sensorIndex];\r\n  if ( sleepAfterFrc === undefined )\r\n    userData[userData.length] = 0x00;\r\n  else\r\n    userData.push( 0x01, sleepAfterFrc.time & 0xFF, sleepAfterFrc.time >> 8, sleepAfterFrc.control );\r\n\r\n  var result = [];\r\n  result[0] = selectedNodes === undefined ? iqrf.embed.frc.Send_Request( frcCommand, userData ) : iqrf.embed.frc.SendSelective_Request( frcCommand, selectedNodes, userData );\r\n  result[1] = iqrf.embed.frc.ExtraResult_Request();\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.sensor.Frc_Response\r\nParses FRC response into sensor values. See <iqrf.sensor.Frc_Request> for more details.\r\n_Requires FRC embedded peripheral driver_.\r\n\r\nParameters:\r\n  sensorType - number: Type of sensor (quantity) to read values of. The type must be alway specified even when 0 was passed as sensorType parameter at iqrf.sensor.Frc_Request.\r\n  frcCommand - number: One of predefined standard sensor FRC commands. Use the same value that was passed to iqrf.sensor.Frc_Request.\r\n  responseFrcSend - object: Response for the 1st request from iqrf.sensor.Frc_Request.\r\n  responseFrcExtraResult - object: [optional] Response for the 2nd request from iqrf.sensor.Frc_Request.\r\n\r\nReturns:\r\n  array: Array of objects for every read sensor. Object array index represent the node address (or index in case selectedNodes parameter was used). The object has the following fields:\r\n\r\n* type - number: Value type of the sensor (quantity). See IQRF Sensor standard for details.\r\n* name - string: Name of the sensor (quantity).\r\n* shortName - string: Short name of the sensor (quantity). Typically it is a symbol used at physics.\r\n* value - number: Value of the sensor. It equals to NaN to indicate an error value. It equals to undefined to indicate that the node does not support the FRC command.\r\n* unit - string: Unit of the quantity. Dimensionless quantity has empty string \"\".\r\n*/\r\niqrf.sensor.Frc_Response = function ( sensorType, frcCommand, responseFrcSend, responseFrcExtraResult )\r\n{\r\n  var responseFrcExtraResultParsed;\r\n  if ( responseFrcExtraResult !== undefined )\r\n    responseFrcExtraResultParsed = iqrf.embed.frc.ExtraResult_Response( responseFrcExtraResult );\r\n  var parsedFrc = iqrf.embed.frc.ParseResponses( frcCommand, iqrf.embed.frc.Send_Response( responseFrcSend ), responseFrcExtraResultParsed );\r\n\r\n  var sensorObj = iqrf.sensor.SensorTypes[sensorType];\r\n  if ( sensorObj === undefined )\r\n    throw new Error( 'iqrf.sensor.Frc_Response: Unknown sensor type ' + sensorType );\r\n\r\n  if ( -1 === iqrf.indexOf( sensorObj.frcs, frcCommand ) )\r\n    throw new Error( 'iqrf.sensor.Frc_Response: Unsupported FRC command ' + frcCommand + ' by sensor type ' + sensorType + '=' + sensorObj.name );\r\n\r\n  var result = [];\r\n  for ( var index in parsedFrc )\r\n  {\r\n    var frcValue = parsedFrc[index];\r\n\r\n    if ( frcValue === 0 )\r\n      throw new Error( 'iqrf.sensor.Frc_Response: Error FRC value 0 at index ' + index );\r\n\r\n    var value;\r\n    var decodeValue = false;\r\n\r\n    if ( frcCommand !== iqrf.sensor.STD_SENSOR_FRC_2BITS )\r\n      switch ( frcValue )\r\n      {\r\n        case 1:\r\n          value = undefined;\r\n          break;\r\n\r\n        case 2:\r\n          value = NaN;\r\n          break;\r\n\r\n        case 3:\r\n          throw new Error( 'iqrf.sensor.Frc_Response: Unsupported FRC value 3 at index ' + index );\r\n\r\n        default:\r\n          decodeValue = true;\r\n          break;\r\n      }\r\n    else\r\n      switch ( frcValue )\r\n      {\r\n        case 1:\r\n          value = undefined;\r\n          break;\r\n\r\n        case 2:\r\n        case 3:\r\n          decodeValue = true;\r\n          break;\r\n\r\n        default:\r\n          throw new Error( 'iqrf.sensor.Frc_Response: Error FRC value ' + frcValue + ' at index ' + index );\r\n      }\r\n\r\n    if ( decodeValue )\r\n      switch ( sensorType )\r\n      {\r\n        default:\r\n          throw new Error( 'iqrf.sensor.Frc_Response: Unimplemented sensor type value ' + sensorType + '=' + sensorObj.name );\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_TEMPERATURE:\r\n          switch ( frcCommand )\r\n          {\r\n            case iqrf.sensor.STD_SENSOR_FRC_1BYTE:\r\n              value = frcValue / 2.0 - 22;\r\n              break;\r\n\r\n            case iqrf.sensor.STD_SENSOR_FRC_2BYTES:\r\n              value = ( frcValue ^ 0x8000 ) / 16.0;\r\n              break;\r\n          }\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_LOW_VOLTAGE:\r\n          value = ( frcValue ^ 0x8000 ) / 16.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_ATMOSPHERIC_PRESSURE:\r\n          value = ( frcValue - 4 ) / 16.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_CO2:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_VOC:\r\n          switch ( frcCommand )\r\n          {\r\n            case iqrf.sensor.STD_SENSOR_FRC_1BYTE:\r\n              value = ( frcValue - 4 ) * 16;\r\n              break;\r\n\r\n            case iqrf.sensor.STD_SENSOR_FRC_2BYTES:\r\n              value = frcValue - 4;\r\n              break;\r\n          }\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_COLOR_TEMPERATURE:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_TIMESPAN:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_ILLUMINANCE:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA30:\r\n          value = frcValue - 4;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_EXTRA_LOW_VOLTAGE:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_CURRENT:\r\n          value = ( frcValue ^ 0x8000 ) / 1000.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_MAINS_FREQUENCY:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_NO2:\r\n        case iqrf.sensor.STD_SENSOR_TYPE_SO2:\r\n          value = ( frcValue - 4 ) / 1000.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_EARTHS_MAGNETIC_FIELD:\r\n          value = ( frcValue ^ 0x8000 ) / 10000000.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_POWER:\r\n          value = ( frcValue - 4 ) / 4.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_CO:\r\n          value = ( frcValue - 4 ) / 100.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_O3:\r\n          value = ( frcValue - 4 ) / 10000.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_RELATIVE_HUMIDITY:\r\n          value = ( frcValue - 4 ) / 2.0;\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_BINARYDATA7:\r\n          switch ( frcCommand )\r\n          {\r\n            case iqrf.sensor.STD_SENSOR_FRC_2BITS:\r\n              value = frcValue & 0x01;\r\n              break;\r\n\r\n            case iqrf.sensor.STD_SENSOR_FRC_1BYTE:\r\n              value = frcValue - 4;\r\n              break;\r\n          }\r\n          break;\r\n\r\n        case iqrf.sensor.STD_SENSOR_TYPE_POWER_FACTOR:\r\n          value = ( frcValue - 4 ) / 200.0;\r\n          break;\r\n      }\r\n\r\n    result[index] =\r\n      {\r\n        type: sensorType,\r\n        name: sensorObj.name,\r\n        shortName: sensorObj.shortName,\r\n        value: value,\r\n        unit: sensorObj.unit\r\n      };\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n//############################################################################################\r\n","notes":"+ New quantities added (TimeSpan, Illuminance, NO2 (nitrogen dioxide), SO2 (sulfur dioxide), CO (carbon monoxide), O3 (ozone), Atmospheric Pressure, Color Temperature, TimeSpanLong).\n+ New quantity added (Data Block).\n! Fixed negative numbers calculation for signed quantities.\n! Fixed computation of Earth’s Magnetic Field value.\n+ Error sensor values detected and returned as NaN.\n+ Sensor enumeration gives list of supported FRC commands.\n+ iqrf.sensor.Frc* functions added.\n+ Optional parameter writtenData at iqrf.sensor.ReadSensorsWithTypes_Request.","standardID":94,"name":"IQRF: Sensor"},{"version":1.00,"versionFlags":1,"driver":"// File_:   $RCSfile: 00_EmbedCoordinator.js,v $\r\n// Version: $Revision: 1.22 $\r\n// Date:    $Date: 2018/08/09 07:29:25 $\r\n//############################################################################################\r\n\r\n/* Title: Embedded Coordinator peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x00,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 1.00, 'VersionFlags' : 1, 'Notes' : [\r\n        'Added SmartConnect support for DPA > 3.02.',\r\n        'DiscoveredDevices_Response and BondedDevices_Response ignore addresses above 239.',\r\n        ]\r\n    },\r\n    { 'Version' : 0.00, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n\r\n// Namespace: iqrf.embed.coordinator\r\n// All prepared DPA requests have nadr set to '00'.\r\nnamespace( 'iqrf.embed.coordinator' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.AddrInfo_Request\r\nEncodes DPA request to get basic network information.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.coordinator.AddrInfo_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '00' );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.AddrInfo_Response\r\nDecodes DPA response from getting basic network information.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  object: Object with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide for details):\r\n\r\n* devNr - number: \r\n* did - number: \r\n*/\r\niqrf.embed.coordinator.AddrInfo_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '80', 2 );\r\n\r\n  var result =\r\n    {\r\n      devNr: responseData[0],\r\n      did: responseData[1]\r\n    };\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.DiscoveredDevices_Request\r\nEncodes DPA request to get list of discovered devices\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.coordinator.DiscoveredDevices_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '01' );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.DiscoveredDevices_Response\r\nDecodes DPA response from getting list of discovered devices.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Array if integer values corresponding to the addresses of the discovered devices.\r\n*/\r\niqrf.embed.coordinator.DiscoveredDevices_Response = function ( response )\r\n{\r\n  return iqrf.BitmapToIndexes( iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '81', 32 ), 0, 29 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.BondedDevices_Request\r\nEncodes DPA request to get list of bonded devices\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.coordinator.BondedDevices_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '02' );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.BondedDevices_Response\r\nDecodes DPA response from getting list of bonded devices.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Array if integer values corresponding to the addresses of the bonded devices.\r\n*/\r\niqrf.embed.coordinator.BondedDevices_Response = function ( response )\r\n{\r\n  return iqrf.BitmapToIndexes( iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '82', 32 ), 0, 29 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.ClearAllBonds_Request\r\nEncodes DPA request to clear all bonds.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.coordinator.ClearAllBonds_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '03' );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.ClearAllBonds_Response\r\nDecodes DPA response from clearing all bonds.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.coordinator.ClearAllBonds_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '83', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.BondNode_Request\r\nEncodes DPA request to bond a node.\r\n\r\nParameters:\r\n  reqAddr - number: Requested address.\r\n  bondingMask - number: Bonding mask.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.coordinator.BondNode_Request = function ( reqAddr, bondingMask )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '04', iqrf.ToHexStringByte( reqAddr ) + '.' + iqrf.ToHexStringByte( bondingMask ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.BondNode_Response\r\nDecodes DPA response from bonding a node.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  object: Object with the following fields:\r\n\r\n* bondAddr - number: Address of the node newly bonded to the network.\r\n* devNr - number: Number of bonded network nodes.\r\n*/\r\niqrf.embed.coordinator.BondNode_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '84', 2 );\r\n\r\n  var result =\r\n    {\r\n      bondAddr: responseData[0],\r\n      devNr: responseData[1]\r\n    };\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.RemoveBond_Request\r\nEncodes DPA request to remove bond.\r\n\r\nParameters:\r\n  bondAddr - number: Address of the node to remove the bond to.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.coordinator.RemoveBond_Request = function ( bondAddr )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '05', iqrf.ToHexStringByte( bondAddr ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.RemoveBond_Response\r\nDecodes DPA response from removing bond.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  number: Number of bonded network nodes.\r\n*/\r\niqrf.embed.coordinator.RemoveBond_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '85', 1 );\r\n  return responseData[0];\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.RebondNode_Request\r\nEncodes DPA request to rebond node.\r\n\r\nParameters:\r\n  bondAddr - number: Address of the node to rebond.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.coordinator.RebondNode_Request = function ( bondAddr )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '06', iqrf.ToHexStringByte( bondAddr ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.RebondNode_Response\r\nDecodes DPA response from rebonding node.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  number: Number of bonded network nodes.\r\n*/\r\niqrf.embed.coordinator.RebondNode_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '86', 1 );\r\n  return responseData[0];\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.Discovery_Request\r\nEncodes DPA request to run discovery.\r\n\r\nParameters:\r\n  txPower - number: TX Power used for discovery. \r\n  maxAddr - number: Nonzero value specifies maximum node address to be part of the discovery process. \r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.coordinator.Discovery_Request = function ( txPower, maxAddr )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '07', iqrf.ToHexStringByte( txPower ) + '.' + iqrf.ToHexStringByte( maxAddr ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.Discovery_Response\r\nDecodes DPA response from running discovery.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  number: Number of discovered network nodes.\r\n*/\r\niqrf.embed.coordinator.Discovery_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '87', 1 );\r\n  return responseData[0];\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.SetDpaParams_Request\r\nEncodes DPA request to set DPA parameter.\r\n\r\nParameters:\r\n  dpaParam - number: DPA param to set.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.coordinator.SetDpaParams_Request = function ( dpaParam )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '08', iqrf.ToHexStringByte( dpaParam ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.SetDpaParams_Response\r\nDecodes DPA response from setting DPA parameter.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  number: Previous DPA parameter value.\r\n*/\r\niqrf.embed.coordinator.SetDpaParams_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '88', 1 );\r\n  return responseData[0];\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.SetHops_Request\r\nEncodes DPA request to specify number of hops\r\n\r\nParameters:\r\n  requestHops - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  responseHops - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.coordinator.SetHops_Request = function ( requestHops, responseHops )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '09', iqrf.ToHexStringByte( requestHops ) + '.' + iqrf.ToHexStringByte( responseHops ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.SetHops_Response\r\nDecodes DPA response from specifying number of hops.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\nobject: Object with the following fields storing previous values:\r\n\r\n* requestHops - number: \r\n* responseHops - number: \r\n*/\r\niqrf.embed.coordinator.SetHops_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '89', 2 );\r\n\r\n  var result =\r\n    {\r\n      requestHops: responseData[0],\r\n      responseHops: responseData[1]\r\n    };\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.DiscoveryData_Request\r\nEncodes DPA request to read discovery data.\r\n\r\nParameters:\r\n  address - number: Address of the discovery data to read. See IQRF OS documentation for details.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.coordinator.DiscoveryData_Request = function ( address )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '0A', iqrf.IntToHexStringBytesArray( address, 2 ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.DiscoveryData_Response\r\nDecodes DPA response from reading discovery data.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Array of bytes with discovery data.\r\n*/\r\niqrf.embed.coordinator.DiscoveryData_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '8A', 48 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.Backup_Request\r\nEncodes DPA request to backup coordinator.\r\n\r\nParameters:\r\n  index - number: Index of the block of data.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.coordinator.Backup_Request = function ( index )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '0B', iqrf.ToHexStringByte( index ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.Backup_Response\r\nDecodes DPA response from backing up coordinator.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Array of bytes with the backup content.\r\n*/\r\niqrf.embed.coordinator.Backup_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '8B', 49 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.Restore_Request\r\nEncodes DPA request to restore coordinator.\r\n\r\nParameters:\r\n  networkData - array: One block of the coordinator network info data previously obtained by a backup command.  \r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.coordinator.Restore_Request = function ( networkData )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '0C', iqrf.BytesToHexStringBytesArray( networkData ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.Restore_Response\r\nDecodes DPA response from restoring coordinator.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.coordinator.Restore_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '8C', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.AuthorizeBond_Request\r\nEncodes DPA request to authorize previously remotely pre-bonded node.\r\n\r\nParameters:\r\n  reqAddr - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  mid - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.coordinator.AuthorizeBond_Request = function ( reqAddr, mid )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '0D', iqrf.ToHexStringByte( reqAddr ) + '.' + iqrf.IntToHexStringBytesArray( mid, 4 ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.AuthorizeBond_Response\r\nDecodes DPA response from authorizing previously remotely pre-bonded node.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  object: Object with the following fields:\r\n\r\n* bondAddr - number: Address of the node newly bonded to the network.\r\n* devNr - number: Number of bonded network nodes.\r\n*/\r\niqrf.embed.coordinator.AuthorizeBond_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '8D', 2 );\r\n\r\n  var result =\r\n    {\r\n      bondAddr: responseData[0],\r\n      devNr: responseData[1]\r\n    };\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.ReadRemotelyBondedMid_Request\r\nEncodes DPA request to read remotely bonded nodes.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.coordinator.ReadRemotelyBondedMid_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '0F' );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.ReadRemotelyBondedMid_Response\r\nDecodes DPA response from reading remotely bonded nodes.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Array of objects for every prebonded node. The object has the following fields:\r\n\r\n* mid - number: Prebonded mid.\r\n* userData - array: Array of 4 bytes with user data.\r\n*/\r\niqrf.embed.coordinator.ReadRemotelyBondedMid_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '8F' );\r\n\r\n  var result = [];\r\n  var responseData_length = responseData.length;\r\n  for ( var index = 0; index < responseData_length; index += 8 )\r\n  {\r\n    result[result.length] =\r\n      {\r\n        mid: responseData[index] + ( responseData[index + 1] * 0x100 ) + ( responseData[index + 2] * 0x10000 ) + ( responseData[index + 3] * 0x1000000 ),\r\n        userData: [responseData[index + 4], responseData[index + 5], responseData[index + 6], responseData[index + 7]]\r\n      };\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.ClearRemotelyBondedMid_Request\r\nEncodes DPA request to clear list of remotely bonded nodes.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.coordinator.ClearRemotelyBondedMid_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '10' );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.ClearRemotelyBondedMid_Response\r\nDecodes DPA response from clearing list of remotely bonded nodes.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.coordinator.ClearRemotelyBondedMid_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '90', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.EnableRemoteBonding_Request\r\nEncodes DPA request to enable remote bonding.\r\n\r\nParameters:\r\n  bondingMask - number: see DPA technical documentation.\r\n  control - number: see DPA technical documentation.\r\n  userData - array: Array of 4 bytes, see DPA technical documentation.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.coordinator.EnableRemoteBonding_Request = function ( bondingMask, control, userData )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '11',\r\n    iqrf.ToHexStringByte( bondingMask ) + '.' + iqrf.ToHexStringByte( control ) + iqrf.BytesToHexStringBytesArray( userData, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.EnableRemoteBonding_Response\r\nDecodes DPA response from enabling remote bonding.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.coordinator.EnableRemoteBonding_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '91', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.coordinator.SmartConnect_Request\r\nEncodes DPA request for Smart Connect.\r\nFrom version 1.00 for DPA > 3.02.\r\n\r\nParameters:\r\n  reqAddr - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  bondingTestRetries - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  ibk - array: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  mid - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  virtualDeviceAddress - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  userData - array:  see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\n\r\niqrf.embed.coordinator.SmartConnect_Request = function ( reqAddr, bondingTestRetries, ibk, mid, virtualDeviceAddress, userData )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_Coordinator, '12',\r\n    iqrf.ToHexStringByte( reqAddr ) + '.' +\r\n    iqrf.ToHexStringByte( bondingTestRetries ) + '.' +\r\n    iqrf.BytesToHexStringBytesArray( ibk ) + '.' +\r\n    iqrf.IntToHexStringBytesArray( mid, 4 ) + '.00.00.' +\r\n    iqrf.ToHexStringByte( virtualDeviceAddress ) + '.00.00.00.00.00.00.00.00.00.' +\r\n    iqrf.BytesToHexStringBytesArray( userData ) );\r\n};\r\n\r\n/* Function: iqrf.embed.coordinator.SmartConnect_Response\r\nDecodes DPA response from Smart Connect.\r\nFrom version 1.00 for DPA > 3.02.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  object: Object with the following fields:\r\n\r\n* bondAddr - number: Address of the node newly bonded to the network.\r\n* devNr - number: Number of bonded network nodes.\r\n*/\r\niqrf.embed.coordinator.SmartConnect_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Coordinator, '92', 2 );\r\n\r\n  var result =\r\n    {\r\n      bondAddr: responseData[0],\r\n      devNr: responseData[1]\r\n    };\r\n\r\n  return result;\r\n};\r\n\r\n//############################################################################################\r\n","notes":"Added SmartConnect support for DPA > 3.02.\nDiscoveredDevices_Response and BondedDevices_Response ignore addresses above 239.","standardID":0,"name":"Embed: Coordinator"},{"version":0.00,"versionFlags":0,"driver":"// File_:   $RCSfile: 01_EmbedNode.js,v $\r\n// Version: $Revision: 1.18 $\r\n// Date:    $Date: 2018/07/09 15:13:45 $\r\n//############################################################################################\r\n\r\n/* Title: Embedded Node peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x01,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.node\r\nnamespace( 'iqrf.embed.node' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.node.Read_Request\r\nEncodes DPA request to read Node information.\r\n\r\nReturns:\r\n  string: DPA request string.  \r\n*/\r\niqrf.embed.node.Read_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_Node, '00' );\r\n};\r\n\r\n/* Function: iqrf.embed.node.Read_Response\r\nDecodes DPA response from reading Node information.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  object: Object with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide/start.htm#_Read for details):\r\n\r\n* ntwADDR - number: \r\n* ntwVRN - number: \r\n* ntwZIN - number:  \r\n* ntwDID - number: \r\n* ntwPVRN - number: \r\n* ntwUSERADDRESS - number: \r\n* ntwID - number: \r\n* ntwVRNFNZ - number: \r\n* ntwCFG - number: \r\n* flags - number: \r\n*/\r\niqrf.embed.node.Read_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Node, '80', 12 );\r\n\r\n  var result =\r\n    {\r\n      ntwADDR: responseData[0],\r\n      ntwVRN: responseData[1],\r\n      ntwZIN: responseData[2],\r\n      ntwDID: responseData[3],\r\n      ntwPVRN: responseData[4],\r\n      ntwUSERADDRESS: responseData[5] + ( responseData[6] * 0x100 ),\r\n      ntwID: responseData[7] + ( responseData[8] * 0x100 ),\r\n      ntwVRNFNZ: responseData[9],\r\n      ntwCFG: responseData[10],\r\n      flags: responseData[11]\r\n    };\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.node.RemoveBond_Request\r\nEncodes DPA request to remove bond.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.node.RemoveBond_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_Node, '01' );\r\n};\r\n\r\n/* Function: iqrf.embed.node.RemoveBond_Response\r\nDecodes DPA response from removing bond.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.node.RemoveBond_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Node, '81', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.node.ReadRemotelyBondedMid_Request\r\nEncodes DPA request to read remotely bonded nodes.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.node.ReadRemotelyBondedMid_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_Node, '02' );\r\n};\r\n\r\n/* Function: iqrf.embed.node.ReadRemotelyBondedMid_Response\r\nDecodes DPA response from reading remotely bonded nodes.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Array of objects for every prebonded node. The object has the following fields:\r\n\r\n* mid - number: Prebonded mid.\r\n* userData - array: Array of 4 bytes with user data.\r\n*/\r\niqrf.embed.node.ReadRemotelyBondedMid_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Node, '82' );\r\n\r\n  var result = [];\r\n  var responseData_length = responseData.length;\r\n  for ( var index = 0; index < responseData_length; index += 8 )\r\n  {\r\n    result[result.length] =\r\n      {\r\n        mid: responseData[index] + ( responseData[index + 1] * 0x100 ) + ( responseData[index + 2] * 0x10000 ) + ( responseData[index + 3] * 0x1000000 ),\r\n        userData: [responseData[index + 4], responseData[index + 5], responseData[index + 6], responseData[index + 7]]\r\n      };\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.node.ClearRemotelyBondedMid_Request\r\nEncodes DPA request to clear list of remotely bonded nodes.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.node.ClearRemotelyBondedMid_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_Node, '03' );\r\n};\r\n\r\n/* Function: iqrf.embed.node.ClearRemotelyBondedMid_Response\r\nDecodes DPA response from clearing list of remotely bonded nodes.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.node.ClearRemotelyBondedMid_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Node, '83', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.node.EnableRemoteBonding_Request\r\nEncodes DPA request to enable remote bonding.\r\n\r\nParameters:\r\n  bondingMask - number: see DPA technical documentation.\r\n  control - number: see DPA technical documentation.\r\n  userData - array: Array of 4 bytes, see DPA technical documentation.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.node.EnableRemoteBonding_Request = function ( bondingMask, control, userData )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_Node, '04',\r\n    iqrf.ToHexStringByte( bondingMask ) + '.' + iqrf.ToHexStringByte( control ) + iqrf.BytesToHexStringBytesArray( userData, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.node.EnableRemoteBonding_Response\r\nDecodes DPA response from enabling remote bonding.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.node.EnableRemoteBonding_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Node, '84', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.node.RemoveBondAddress_Request\r\nEncodes DPA request to remove bond address.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.node.RemoveBondAddress_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_Node, '05' );\r\n};\r\n\r\n/* Function: iqrf.embed.node.RemoveBondAddress_Response\r\nDecodes DPA response from removing bond address.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.node.RemoveBondAddress_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Node, '85', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.node.Backup_Request\r\nEncodes DPA request to backup node.\r\n\r\nParameters:\r\n  index - number: Index of the block of data.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.node.Backup_Request = function ( index )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_Node, '06', iqrf.ToHexStringByte( index ) );\r\n};\r\n\r\n/* Function: iqrf.embed.node.Backup_Response\r\nDecodes DPA response from backing up node.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Array of bytes with the backup content.\r\n*/\r\niqrf.embed.node.Backup_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Node, '86', 49 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.node.Restore_Request\r\nEncodes DPA request to restore node.\r\n\r\nParameters:\r\n  networkData - array: One block of the coordinator network info data previously obtained by a backup command.  \r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.node.Restore_Request = function ( networkData )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_Node, '07', iqrf.BytesToHexStringBytesArray( networkData ) );\r\n};\r\n\r\n/* Function: iqrf.embed.node.Restore_Response\r\nDecodes DPA response from restoring node.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.node.Restore_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Node, '87', 0 );\r\n};\r\n\r\n//############################################################################################\r\n","notes":"Initial release","standardID":1,"name":"Embed: Node"},{"version":1.00,"versionFlags":1,"driver":"// File_:   $RCSfile: 02_EmbedOS.js,v $\r\n// Version: $Revision: 1.20 $\r\n// Date:    $Date: 2018/07/09 15:13:45 $\r\n//############################################################################################\r\n\r\n/* Title: Embedded OS peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x02,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 1.00, 'VersionFlags' : 1, 'Notes' : [\r\n        'os.Read returns ibk field compatible with DPA > 3.02',\r\n        ]\r\n    },\r\n    { 'Version' : 0.00, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.os\r\nnamespace( 'iqrf.embed.os' );\r\n\r\n/* Function: iqrf.embed.os.Read_Request\r\nEncodes DPA request to read OS.\r\n\r\nReturns:\r\n  string: DPA request string.  \r\n*/\r\niqrf.embed.os.Read_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '00' );\r\n};\r\n\r\n/* Function: iqrf.embed.os.Read_Response\r\nDecodes DPA response from reading OS.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  object: Object with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide/ for details):\r\n\r\n* mid - number: \r\n* osVersion - number: \r\n* trMcuType - number: \r\n* osBuild - number: \r\n* rssi - number: \r\n* supplyVoltage - number: contains real voltage value\r\n* flags - number: \r\n* slotLimits - number: \r\n* ibk - array: (from version 1.00 for DPA > 3.02)\r\n*/\r\niqrf.embed.os.Read_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '80', 28 );\r\n\r\n  var result =\r\n    {\r\n      mid: responseData[0] + ( responseData[1] * 0x100 ) + ( responseData[2] * 0x10000 ) + ( responseData[3] * 0x1000000 ),\r\n      osVersion: responseData[4],\r\n      trMcuType: responseData[5],\r\n      osBuild: responseData[6] + ( responseData[7] * 0x100 ),\r\n      rssi: responseData[8],\r\n      supplyVoltage: 261.12 / ( 127 - responseData[9] ),\r\n      flags: responseData[10],\r\n      slotLimits: responseData[11],\r\n      ibk: responseData.slice( 12, 28 )\r\n    };\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.Reset_Request\r\nEncodes DPA request to reset.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.os.Reset_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '01' );\r\n};\r\n\r\n/* Function: iqrf.embed.os.Reset_Response\r\nDecodes DPA response from reset.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.os.Reset_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '81', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.ReadCfg_Request\r\nEncodes DPA request to read configuration.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.os.ReadCfg_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '02' );\r\n};\r\n\r\n/* Function: iqrf.embed.os.ReadCfg_Response\r\nDecodes DPA response from reading configuration.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  object: Object with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide for details):\r\n\r\n* checksum - number: \r\n* configuration - array: \r\n* rfpgm - number: \r\n* undocumented - number: \r\n*/\r\niqrf.embed.os.ReadCfg_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '82', 34 );\r\n\r\n  var result =\r\n    {\r\n      checksum: responseData[0],\r\n      configuration: responseData.slice( 1, 32 ),\r\n      rfpgm: responseData[32],\r\n      undocumented: responseData[33]\r\n    };\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.Rfpgm_Request\r\nEncodes DPA request to start RFPGM.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.os.Rfpgm_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '03' );\r\n};\r\n\r\n/* Function: iqrf.embed.os.Rfpgm_Response\r\nDecodes DPA response from starting RFPGM.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.os.Rfpgm_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '83', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.Sleep_Request\r\nEncodes DPA request to sleep.\r\n\r\nParameters:\r\n  time - number: See DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  control - number: See DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.os.Sleep_Request = function ( time, control )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '04', iqrf.IntToHexStringBytesArray( time, 2 ) + '.' + iqrf.ToHexStringByte( control ) );\r\n};\r\n\r\n/* Function: iqrf.embed.os.Sleep_Response\r\nDecodes DPA response from sleeping.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.os.Sleep_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '84', 0 );\r\n};\r\n\r\niqrf.embed.os.Batch_ConstructRequests = function ( requests )\r\n{\r\n  var data = '';\r\n  var requests_length = requests.length;\r\n  for ( var index = 0; index < requests_length; index++ )\r\n  {\r\n    var oneRequest = requests[index];\r\n    var hwpid = parseInt( oneRequest.hwpid, 16 );\r\n    var oneData =\r\n      iqrf.NormalizeStringByte( oneRequest.pnum ) + '.' +\r\n      iqrf.NormalizeStringByte( oneRequest.pcmd ) + '.' +\r\n      iqrf.ToHexStringByte( hwpid & 0xFF ) + '.' +\r\n      iqrf.ToHexStringByte( hwpid >> 8 );\r\n\r\n    if ( oneRequest.rdata !== undefined )\r\n      oneData += '.' + iqrf.BytesToHexStringBytesArray( iqrf.ParseStringBytes( oneRequest.rdata ) );\r\n\r\n    oneData = iqrf.ToHexStringByte( 1 + ( 1 + oneData.length ) / 3 ) + '.' + oneData;\r\n\r\n    if ( data.length !== 0 )\r\n      data += '.';\r\n    data += oneData;\r\n  }\r\n\r\n  return data + '.00';\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.Batch_Request\r\nEncodes DPA request to execute a batch.\r\n\r\nParameters:\r\n  requests - array: Array of objects (requests) created by other ?_Request functions.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.os.Batch_Request = function ( requests )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '05', iqrf.embed.os.Batch_ConstructRequests( requests ) );\r\n};\r\n\r\n/* Function: iqrf.embed.os.Batch_Response\r\nDecodes DPA response from executing a batch.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.os.Batch_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '85', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.SetSecurity_Request\r\nEncodes DPA request to set various security parameters.\r\n\r\nParameters:\r\n  type - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  data - array: see DPA documentation https://www.iqrf.org/DpaTechGuide for details. \r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.os.SetSecurity_Request = function ( type, data )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '06', iqrf.ToHexStringByte( type ) + iqrf.BytesToHexStringBytesArray( data, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.os.SetSecurity_Response\r\nDecodes DPA response from setting various security parameters.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.os.SetSecurity_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '86', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.Restart_Request\r\nEncodes DPA request to restart device.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.os.Restart_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '08' );\r\n};\r\n\r\n/* Function: iqrf.embed.os.Restart_Response\r\nDecodes DPA response from restarting device.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.os.Restart_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '88', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.WriteCfgByte_Request\r\nEncodes DPA request to write configuration bytes.\r\n\r\nParameters:\r\n  bytes - array: Array of objects with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide for details):\r\n\r\n* address - number: \r\n* value - number: \r\n* mask - number: \r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.os.WriteCfgByte_Request = function ( bytes )\r\n{\r\n  var data = '';\r\n  var bytes_length = bytes.length;\r\n  for ( var index = 0; index < bytes_length; index++ )\r\n  {\r\n    if ( data.length !== 0 )\r\n      data += '.';\r\n\r\n    var oneByte = bytes[index];\r\n    data +=\r\n      iqrf.ToHexStringByte( oneByte.address ) + '.' +\r\n      iqrf.ToHexStringByte( oneByte.value ) + '.' +\r\n      iqrf.ToHexStringByte( oneByte.mask );\r\n  }\r\n\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '09', data );\r\n};\r\n\r\n/* Function: iqrf.embed.os.WriteCfgByte_Response\r\nDecodes DPA response from writing configuration bytes.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.os.WriteCfgByte_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '89', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.LoadCode_Request\r\nEncodes DPA request to load code.\r\n\r\nParameters:\r\n  flags - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  address - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  length - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  checkSum - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.os.LoadCode_Request = function ( flags, address, length, checkSum )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '0A',\r\n    iqrf.ToHexStringByte( flags ) + '.' +\r\n    iqrf.IntToHexStringBytesArray( address, 2 ) + '.' +\r\n    iqrf.IntToHexStringBytesArray( length, 2 ) + '.' +\r\n    iqrf.IntToHexStringBytesArray( checkSum, 2 ) );\r\n};\r\n\r\n/* Function: iqrf.embed.os.LoadCode_Response\r\nDecodes DPA response from loading code.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  number: Loading code result value.\r\n*/\r\niqrf.embed.os.LoadCode_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '8A', 1 );\r\n  return responseData[0];\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.SelectiveBatch_Request\r\nEncodes DPA request to execute a selective batch.\r\n\r\nParameters:\r\n  selectedNodes - array: Array if integer values corresponding to the selected nodes.\r\n  requests - array: Array of objects (requests) created by other ?_Request functions.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.os.SelectiveBatch_Request = function ( selectedNodes, requests )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '0B',\r\n    iqrf.BytesToHexStringBytesArray( iqrf.IndexesToBitmap( selectedNodes, 30 ) ) + '.' + iqrf.embed.os.Batch_ConstructRequests( requests ) );\r\n};\r\n\r\n/* Function: iqrf.embed.os.SelectiveBatch_Response\r\nDecodes DPA response from executing a selective batch.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.os.SelectiveBatch_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '8B', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.os.WriteCfg_Request\r\nEncodes DPA request to write configuration.\r\n\r\nParameters:\r\n  checksum - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  configuration - array: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n  rfpgm - number: see DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.os.WriteCfg_Request = function ( checksum, configuration, rfpgm )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_OS, '0F', iqrf.ToHexStringByte( checksum ) + iqrf.BytesToHexStringBytesArray( configuration, true ) + '.' + iqrf.ToHexStringByte( rfpgm ) );\r\n};\r\n\r\n/* Function: iqrf.embed.os.WriteCfg_Response\r\nDecodes DPA response from writing configuration.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.os.WriteCfg_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_OS, '8F', 0 );\r\n};\r\n\r\n//############################################################################################\r\n","notes":"os.Read returns ibk field compatible with DPA > 3.02","standardID":2,"name":"Embed: OS"},{"version":0.00,"versionFlags":0,"driver":"// File_:   $RCSfile: 03_EmbedEEPROM.js,v $\r\n// Version: $Revision: 1.13 $\r\n// Date:    $Date: 2018/01/11 21:21:52 $\r\n//############################################################################################\r\n\r\n/* Title: Embedded EEPROM peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x03,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.eeprom\r\nnamespace( 'iqrf.embed.eeprom' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.eeprom.Read_Request\r\nEncodes DPA request to read from memory.\r\n\r\nParameters:\r\n  address - number: Memory address to read from.\r\n  len - number: Length of data to read.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.eeprom.Read_Request = function ( address, len )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_EEPROM, '00', iqrf.ToHexStringByte( address ) + '.' + iqrf.ToHexStringByte( len ) );\r\n};\r\n\r\n/* Function: iqrf.embed.eeprom.Read_Response\r\nDecodes DPA response from reading from memory.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Read data.\r\n*/\r\niqrf.embed.eeprom.Read_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_EEPROM, '80' );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.eeprom.Write_Request\r\nEncodes DPA request to write to memory.\r\n\r\nParameters:\r\n  address - number: Address to write data to.\r\n  pdata - array: Data to write.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.eeprom.Write_Request = function ( address, pdata )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_EEPROM, '01', iqrf.ToHexStringByte( address ) + iqrf.BytesToHexStringBytesArray( pdata, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.eeprom.Write_Response\r\nDecodes DPA response from writing to memory.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.eeprom.Write_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_EEPROM, '81', 0 );\r\n};\r\n\r\n//############################################################################################\r\n","notes":"Initial release","standardID":3,"name":"Embed: EEPROM"},{"version":0.00,"versionFlags":0,"driver":"// File_:   $RCSfile: 04_EmbedEEEPROM.js,v $\r\n// Version: $Revision: 1.13 $\r\n// Date:    $Date: 2018/01/11 21:21:52 $\r\n//############################################################################################\r\n\r\n/* Title: Embedded External EEPROM (aka EEEPROM) peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x04,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.eeeprom\r\nnamespace( 'iqrf.embed.eeeprom' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.eeeprom.Read_Request\r\nEncodes DPA request to read from memory.\r\n\r\nParameters:\r\n  address - number: Memory address to read from.\r\n  len - number: Length of data to read.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.eeeprom.Read_Request = function ( address, len )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_EEEPROM, '02', iqrf.IntToHexStringBytesArray( address, 2 ) + '.' + iqrf.ToHexStringByte( len ) );\r\n};\r\n\r\n/* Function: iqrf.embed.eeeprom.Read_Response\r\nDecodes DPA response from reading from memory.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Read data.\r\n*/\r\niqrf.embed.eeeprom.Read_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_EEEPROM, '82' );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.eeeprom.Write_Request\r\nEncodes DPA request to write to memory.\r\n\r\nParameters:\r\n  address - number: Address to write data to.\r\n  pdata - number: Data to write.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.eeeprom.Write_Request = function ( address, pdata )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_EEEPROM, '03', iqrf.IntToHexStringBytesArray( address, 2 ) + iqrf.BytesToHexStringBytesArray( pdata, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.eeeprom.Write_Response\r\nDecodes DPA response from writing to memory.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.eeeprom.Write_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_EEEPROM, '83', 0 );\r\n};\r\n\r\n//############################################################################################\r\n","notes":"Initial release","standardID":4,"name":"Embed: EEEPROM"},{"version":0.00,"versionFlags":0,"driver":"// File_:   $RCSfile: 05_EmbedRAM.js,v $\r\n// Version: $Revision: 1.13 $\r\n// Date:    $Date: 2018/01/11 21:21:52 $\r\n//############################################################################################\r\n\r\n/* Title: Embedded RAM peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x05,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.ram\r\nnamespace( 'iqrf.embed.ram' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.ram.Read_Request\r\nEncodes DPA request to read from memory.\r\n\r\nParameters:\r\n  address - number: Memory address to read from.\r\n  len - number: Length of data to read.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.ram.Read_Request = function ( address, len )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_RAM, '00', iqrf.ToHexStringByte( address ) + '.' + iqrf.ToHexStringByte( len ) );\r\n};\r\n\r\n/* Function: iqrf.embed.ram.Read_Response\r\nDecodes DPA response from reading from memory.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Read data.\r\n*/\r\niqrf.embed.ram.Read_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_RAM, '80' );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.ram.Write_Request\r\nEncodes DPA request to write to memory.\r\n\r\nParameters:\r\n  address - number: Address to write data to.\r\n  pdata - array: Data to write.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.ram.Write_Request = function ( address, pdata )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_RAM, '01', iqrf.ToHexStringByte( address ) + iqrf.BytesToHexStringBytesArray( pdata, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.ram.Write_Response\r\nDecodes DPA response from writing to memory.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.ram.Write_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_RAM, '81', 0 );\r\n};\r\n\r\n//############################################################################################\r\n","notes":"Initial release","standardID":5,"name":"Embed: RAM"},{"version":0.00,"versionFlags":0,"driver":"// File_:   $RCSfile: 06_EmbedLEDR.js,v $\r\n// Version: $Revision: 1.12 $\r\n// Date:    $Date: 2018/01/11 21:21:52 $\r\n//############################################################################################\r\n\r\n/* Title: Embedded Red LED peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x06,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.ledr\r\nnamespace( 'iqrf.embed.ledr' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.ledr.Set_Request\r\nEncodes DPA request to set the LED.\r\n\r\nParameters:\r\n  onOff - boolean: Required LED state. true is on, false is off.\r\n\r\nReturns:\r\n  string: DPA request string.  \r\n*/\r\niqrf.embed.ledr.Set_Request = function ( onOff )\r\n{\r\n  if ( typeof onOff !== 'boolean' )\r\n    throw new Error( 'iqrf.embed.ledr.Set_Request: Parameter onOff expected to be boolean but not ' + typeof onOff );\r\n\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_LEDR, iqrf.ToHexStringByte( onOff ? 1 : 0 ) );\r\n};\r\n\r\n/* Function: iqrf.embed.ledr.Set_Response\r\nDecodes DPA response from setting the LED.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.ledr.Set_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_LEDR, '80.81', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.ledr.Get_Request\r\nEncodes DPA request to get the state of the LED.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.ledr.Get_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_LEDR, '02' );\r\n};\r\n\r\n/* Function: iqrf.embed.ledr.Get_Response\r\nDecodes DPA response from getting the state of the LED.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  boolean: true if the LED is on, false if the LED is off.\r\n*/\r\niqrf.embed.ledr.Get_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_LEDR, '82', 1 );\r\n  return responseData[0] === 1;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.ledr.Pulse_Request\r\nEncodes DPA request to pulse the LED.\r\n\r\nReturns:\r\n  string: DPA request string.  \r\n*/\r\niqrf.embed.ledr.Pulse_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_LEDR, '03' );\r\n};\r\n\r\n/* Function: iqrf.embed.ledr.Pulse_Response\r\nDecodes DPA response from pulsing the LED.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.ledr.Pulse_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_LEDR, '83', 0 );\r\n};\r\n\r\n//############################################################################################\r\n","notes":"Initial release","standardID":6,"name":"Embed: Red LED"},{"version":0.00,"versionFlags":0,"driver":"// File_:   $RCSfile: 07_EmbedLEDG.js,v $\r\n// Version: $Revision: 1.12 $\r\n// Date:    $Date: 2018/01/11 21:21:52 $\r\n//############################################################################################\r\n\r\n/* Title: Embedded Green LED peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x07,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.ledg\r\nnamespace( 'iqrf.embed.ledg' );\r\n\r\n/* Function: iqrf.embed.ledg.Set_Request\r\nEncodes DPA request to set the LED.\r\n\r\nParameters:\r\n  onOff - boolean: Required LED state. true is on, false is off.\r\n\r\nReturns:\r\n  string: DPA request string.  \r\n*/\r\niqrf.embed.ledg.Set_Request = function ( onOff )\r\n{\r\n  if ( typeof onOff !== 'boolean' )\r\n    throw new Error( 'iqrf.embed.ledg.Set_Request: Parameter onOff expected to be boolean but not ' + typeof onOff );\r\n\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_LEDG, iqrf.ToHexStringByte( onOff ? 1 : 0 ) );\r\n};\r\n\r\n/* Function: iqrf.embed.ledg.Set_Response\r\nDecodes DPA response from setting the LED.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.ledg.Set_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_LEDG, '80.81', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.ledg.Get_Request\r\nEncodes DPA request to get the state of the LED.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.ledg.Get_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_LEDG, '02' );\r\n};\r\n\r\n/* Function: iqrf.embed.ledg.Get_Response\r\nDecodes DPA response from getting the state of the LED.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  boolean: true if the LED is on, false if the LED is off.\r\n*/\r\niqrf.embed.ledg.Get_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_LEDG, '82', 1 );\r\n  return responseData[0] === 1;\r\n};\r\n\r\n/* Function: iqrf.embed.ledg.Pulse_Request\r\nEncodes DPA request to pulse the LED.\r\n\r\nReturns:\r\n  string: DPA request string.  \r\n*/\r\niqrf.embed.ledg.Pulse_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_LEDG, '03' );\r\n};\r\n\r\n/* Function: iqrf.embed.ledg.Pulse_Response\r\nDecodes DPA response from pulsing the LED.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.ledg.Pulse_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_LEDG, '83', 0 );\r\n};\r\n\r\n//############################################################################################\r\n","notes":"Initial release","standardID":7,"name":"Embed: Green LED"},{"version":0.00,"versionFlags":0,"driver":"// File_:   $RCSfile: 08_EmbedSPI.js,v $\r\n// Version: $Revision: 1.10 $\r\n// Date:    $Date: 2017/12/18 16:31:49 $\r\n//############################################################################################\r\n\r\n/* Title: Embedded SPI peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x08,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.spi\r\nnamespace( 'iqrf.embed.spi' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.spi.WriteRead_Request\r\nEncodes DPA request to write and/or read data to/from SPI peripheral.\r\n\r\nParameters:\r\n  readTimeout - number:\r\n  writtenData - array: Array of bytes.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.spi.WriteRead_Request = function ( readTimeout, writtenData )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_SPI, '00', iqrf.ToHexStringByte( readTimeout ) + iqrf.BytesToHexStringBytesArray( writtenData, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.spi.WriteRead_Response\r\nDecodes DPA response from writing and/or reading data to/from SPI peripheral.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Read data.\r\n*/\r\niqrf.embed.spi.WriteRead_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_SPI, '80' );\r\n};\r\n\r\n//############################################################################################\r\n","notes":"Initial release","standardID":8,"name":"Embed: SPI"},{"version":0.00,"versionFlags":0,"driver":"// File_:   $RCSfile: 09_EmbedIO.js,v $\r\n// Version: $Revision: 1.14 $\r\n// Date:    $Date: 2018/03/26 14:13:31 $\r\n//############################################################################################\r\n\r\n/* Title: Embedded IO peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x09,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release' ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.io\r\nnamespace( 'iqrf.embed.io' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.io.Direction_Request\r\nEncodes DPA request to set direction of IOs.\r\n\r\nParameters:\r\n  ports - attay: Array of objects with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide for details):\r\n\r\n* port - number: \r\n* mask - number: \r\n* value - number:\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.io.Direction_Request = function ( ports )\r\n{\r\n  var data = '';\r\n  var ports_length = ports.length;\r\n  for ( var index = 0; index < ports_length; index++ )\r\n  {\r\n    if ( data.length !== 0 )\r\n      data += '.';\r\n\r\n    var onePort = ports[index];\r\n    data +=\r\n      iqrf.ToHexStringByte( onePort.port ) + '.' +\r\n      iqrf.ToHexStringByte( onePort.mask ) + '.' +\r\n      iqrf.ToHexStringByte( onePort.value );\r\n  }\r\n\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_IO, '00', data );\r\n};\r\n\r\n/* Function: iqrf.embed.io.Direction_Response\r\nDecodes DPA response from setting direction of IOs.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.io.Direction_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_IO, '80', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.io.Set_Request\r\nEncodes DPA request to set IOs.\r\n\r\nParameters:\r\n  ports - array: Array of objects with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide for details):\r\n\r\n* port - number: \r\n* mask - number: \r\n* value - number: \r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.io.Set_Request = function ( ports )\r\n{\r\n  var data = '';\r\n  var ports_length = ports.length;\r\n  for ( var index = 0; index < ports_length; index++ )\r\n  {\r\n    if ( data.length !== 0 )\r\n      data += '.';\r\n\r\n    var onePort = ports[index];\r\n    data +=\r\n      iqrf.ToHexStringByte( onePort.port ) + '.' +\r\n      iqrf.ToHexStringByte( onePort.mask ) + '.' +\r\n      iqrf.ToHexStringByte( onePort.value );\r\n  }\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_IO, '01', data );\r\n};\r\n\r\n/* Function: iqrf.embed.io.Set_Response\r\nDecodes DPA response from setting IOs.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.io.Set_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_IO, '81', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.io.Get_Request\r\nEncodes DPA request to read the input state of all supported the MCU ports.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.io.Get_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_IO, '02' );\r\n};\r\n\r\n/* Function: iqrf.embed.io.Get_Response\r\nDecodes DPA response from reading the input state of all supported the MCU ports.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Ports values (see DPA documentation https://www.iqrf.org/DpaTechGuide for details).\r\n*/\r\niqrf.embed.io.Get_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_IO, '82', -5 );\r\n};\r\n\r\n//############################################################################################\r\n","notes":"Initial release","standardID":9,"name":"Embed: IO"},{"version":0.00,"versionFlags":0,"driver":"// File_:   $RCSfile: 0A_EmbedThermometer.js,v $\r\n// Version: $Revision: 1.10 $\r\n// Date:    $Date: 2018/07/09 15:13:45 $\r\n//############################################################################################\r\n\r\n/* Title: Embedded Thermometer peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x0A,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.thermometer\r\nnamespace( 'iqrf.embed.thermometer' );\r\n\r\n/* Function: iqrf.embed.thermometer.Read_Request\r\nEncodes DPA request to read temperature.\r\n\r\nReturns:\r\n  string: DPA request string.  \r\n*/\r\niqrf.embed.thermometer.Read_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_Thermometer, '00' );\r\n};\r\n\r\n/* Function: iqrf.embed.thermometer.Read_Response\r\nDecodes DPA response from reading temperature.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturn:\r\n  number: Temperature value.\r\n*/\r\niqrf.embed.thermometer.Read_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Thermometer, '80', 3 );\r\n  if ( responseData[0] === 0x80 )\r\n    throw new Error( 'iqrf.embed.thermometer.Read_Response: Temperature sensor missing' );\r\n\r\n  return ( responseData[1] + ( responseData[2] * 0x100 ) ) / 16.0;\r\n};\r\n\r\n//############################################################################################\r\n","notes":"Initial release","standardID":10,"name":"Embed: Thermometer"},{"version":0.00,"versionFlags":0,"driver":"// File_:   $RCSfile: 0C_EmbedUART.js,v $\r\n// Version: $Revision: 1.12 $\r\n// Date:    $Date: 2018/01/30 14:20:02 $\r\n//############################################################################################\r\n\r\n/* Title: Embedded UART peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x0C,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.uart\r\nnamespace( 'iqrf.embed.uart' );\r\n\r\n// Baudrates\r\n/* Const: iqrf.embed.uart.DpaBaud_1200\r\n*/\r\niqrf.embed.uart.DpaBaud_1200 = 0x00;\r\n/* Const: iqrf.embed.uart.DpaBaud_2400\r\n*/\r\niqrf.embed.uart.DpaBaud_2400 = 0x01;\r\n/* Const: iqrf.embed.uart.DpaBaud_4800\r\n*/\r\niqrf.embed.uart.DpaBaud_4800 = 0x02;\r\n/* Const: iqrf.embed.uart.DpaBaud_9600\r\n*/\r\niqrf.embed.uart.DpaBaud_9600 = 0x03;\r\n/* Const: iqrf.embed.uart.DpaBaud_19200\r\n*/\r\niqrf.embed.uart.DpaBaud_19200 = 0x04;\r\n/* Const: iqrf.embed.uart.DpaBaud_38400\r\n*/\r\niqrf.embed.uart.DpaBaud_38400 = 0x05;\r\n/* Const: iqrf.embed.uart.DpaBaud_57600\r\n*/\r\niqrf.embed.uart.DpaBaud_57600 = 0x06;\r\n/* Const: iqrf.embed.uart.DpaBaud_115200\r\n*/\r\niqrf.embed.uart.DpaBaud_115200 = 0x07;\r\n/* Const: iqrf.embed.uart.DpaBaud_230400\r\n*/\r\niqrf.embed.uart.DpaBaud_230400 = 0x08;\r\n\r\n// --------------\r\n/* Function: iqrf.embed.uart.Open_Request\r\nEncodes DPA request to open UART peripheral.\r\n\r\nParameters:\r\n  baudRate - number: BaudRate value. See iqrf.embed.uart.DpaBaud_??? constants.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.uart.Open_Request = function ( baudRate )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_UART, '00', iqrf.ToHexStringByte( baudRate ) );\r\n};\r\n\r\n/* Function: iqrf.embed.uart.Open_Response\r\nDecodes DPA response from opening UART peripheral\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.uart.Open_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_UART, '80', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.uart.Close_Request\r\nEncodes DPA request to close UART peripheral.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.uart.Close_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_UART, '01' );\r\n};\r\n\r\n/* Function: iqrf.embed.uart.Close_Response\r\nDecodes DPA response from closing UART peripheral.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n*/\r\niqrf.embed.uart.Close_Response = function ( response )\r\n{\r\n  iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_UART, '81', 0 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.uart.WriteRead_Request\r\nEncodes DPA request to write and/or read data to/from UART peripheral.\r\n\r\nParameters:\r\n  readTimeout - number: \r\n  writtenData - array: Array of bytes.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.uart.WriteRead_Request = function ( readTimeout, writtenData )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_UART, '02', iqrf.ToHexStringByte( readTimeout ) + iqrf.BytesToHexStringBytesArray( writtenData, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.uart.WriteRead_Response\r\nDecodes DPA response from writing and/or reading data to/from UART peripheral.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  Read data.\r\n*/\r\niqrf.embed.uart.WriteRead_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_UART, '82' );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.uart.ClearWriteRead_Request\r\nEncodes DPA request to clear rx buffer and then write and/or read data to/from UART peripheral.\r\n\r\nParameters:\r\n  readTimeout - number: \r\n  writtenData - array: Array of bytes.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.uart.ClearWriteRead_Request = function ( readTimeout, writtenData )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_UART, '03', iqrf.ToHexStringByte( readTimeout ) + iqrf.BytesToHexStringBytesArray( writtenData, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.uart.ClearWriteRead_Response\r\nDecodes DPA response from clearing rx buffer and writing and/or reading data to/from UART peripheral.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Read data.\r\n*/\r\niqrf.embed.uart.ClearWriteRead_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_UART, '83' );\r\n};\r\n\r\n//############################################################################################\r\n","notes":"Initial release","standardID":12,"name":"Embed: UART"},{"version":0.00,"versionFlags":0,"driver":"// File_:   $RCSfile: 0D_EmbedFRC.js,v $\r\n// Version: $Revision: 1.18 $\r\n// Date:    $Date: 2018/07/09 15:13:45 $\r\n//############################################################################################\r\n\r\n/* Title: Embedded FRC peripheral driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0x0D,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        'Initial release',\r\n        ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.frc\r\n// All prepared DPA requests have nadr set to '00'.\r\nnamespace( 'iqrf.embed.frc' );\r\n\r\n// --------------\r\n/* Function: iqrf.embed.frc.Send_Request\r\nEncodes DPA request to send a FRC command\r\n\r\nParameters:\r\n  frcCommand - number: Specifies data to be collected. \r\n  userData - array: User data.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.frc.Send_Request = function ( frcCommand, userData )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_FRC, '00', iqrf.ToHexStringByte( frcCommand ) + iqrf.BytesToHexStringBytesArray( userData, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.frc.Send_Response\r\nDecodes DPA response from sending a FRC command. It also handles response from iqrf.embed.frc.SendSelective_Request.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  object: Object with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide/ for details):\r\n\r\n* status - number\r\n* frcData - array\r\n*/\r\niqrf.embed.frc.Send_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_FRC, '80.82', -2 );\r\n\r\n  var result =\r\n    {\r\n      status: responseData[0],\r\n      frcData: responseData.slice( 1, responseData.length )\r\n    };\r\n\r\n  return result;\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.frc.ExtraResult_Request\r\nEncodes DPA request to read remaining bytes of the FRC result.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.frc.ExtraResult_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_FRC, '01' );\r\n};\r\n\r\n/* Function: iqrf.embed.frc.ExtraResult_Response\r\nDecodes DPA response from reading remaining bytes of the FRC result.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Remaining FRC data.\r\n*/\r\niqrf.embed.frc.ExtraResult_Response = function ( response )\r\n{\r\n  return iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_FRC, '81', -1 );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.frc.SendSelective_Request\r\nEncodes DPA request to send a selective FRC command.\r\n\r\nParameters:\r\n  frcCommand - number: Specifies data to be collected.\r\n  selectedNodes - array: Array if integer values corresponding to the selected nodes.\r\n  userData - array: User data.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.frc.SendSelective_Request = function ( frcCommand, selectedNodes, userData )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_FRC, '02',\r\n    iqrf.ToHexStringByte( frcCommand ) +\r\n    iqrf.BytesToHexStringBytesArray( iqrf.IndexesToBitmap( selectedNodes, 30 ), true ) +\r\n    iqrf.BytesToHexStringBytesArray( userData, true ) );\r\n};\r\n\r\n/* Function: iqrf.embed.frc.SendSelective_Response\r\nDecodes DPA response from sending a selective FRC command.  It also handles response from iqrf.embed.frc.Send_Request.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  Object with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide/ for details):\r\n\r\n* status - number\r\n* frcData - array\r\n*/\r\niqrf.embed.frc.SendSelective_Response = function ( response )\r\n{\r\n  return iqrf.embed.frc.Send_Response( response );\r\n};\r\n\r\n// --------------\r\n/* Function: iqrf.embed.frc.SetParams_Request\r\nEncodes DPA request to set global FRC parameters.\r\n\r\nParameters:\r\n  frcResponseTime - number: See DPA documentation https://www.iqrf.org/DpaTechGuide for details.\r\n\r\nReturns:\r\n  string: DPA request string.\r\n*/\r\niqrf.embed.frc.SetParams_Request = function ( frcResponseTime )\r\n{\r\n  return new iqrf.DpaRawHdpMessageCoordinator( iqrf.PNUM_FRC, '03', iqrf.ToHexStringByte( frcResponseTime ) );\r\n};\r\n\r\n/* Function: iqrf.embed.frc.SetParams_Response\r\nDecodes DPA response from setting global FRC parameters.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  number: Previous FRCresponseTime value. \r\n*/\r\niqrf.embed.frc.SetParams_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_FRC, '83', 1 );\r\n  return responseData[0];\r\n};\r\n\r\n/* Function: iqrf.embed.frc.ParseResponses\r\nDecodes DPA responses returned by iqrf.embed.frc.Send[Selective]_Response and iqrf.embed.frc.ExtraResult_Response\r\n\r\nParameters:\r\n  frcCommand - number: FRC command passed to iqrf.embed.frc.Send[Selective]_Request\r\n  sendResponse - object: Return value from iqrf.embed.frc.Send[Selective]_Response\r\n  extraResultResponse - array: [optional] Return value from iqrf.embed.frc.ExtraResult_Response. For smaller networks extra FRC result might not be needed.\r\n\r\nReturns:\r\n  array: Based on the FRC command the items of the array are 2 bits, 1 byte or 2 bytes numbers. Only indexes of the array of the Nodes that returned non-zero value are filled in.\r\n\r\n\r\n--- Text\r\nExample:\r\n\r\n* Input\r\n// Both sendResponse.frcData[] and extraResultResponse full of 0s except:\r\nsendResponse.frcData[2]  = 6\r\nsendResponse.frcData[34] = 2\r\n\r\n* Result\r\n// for 2 bits FRC command\r\n{\r\n  \"17\": 3,\r\n  \"18\": 1\r\n}\r\n\r\n// for 1 byte FRC command\r\n{\r\n  \"2\": 6,\r\n  \"34\": 2\r\n}\r\n\r\n// for 2 bytes FRC command\r\n{\r\n  \"1\": 6,\r\n  \"17\": 2\r\n}\r\n---\r\n*/\r\niqrf.embed.frc.ParseResponses = function ( frcCommand, sendResponse, extraResultResponse )\r\n{\r\n  if ( frcCommand < 0 || frcCommand > 0xff )\r\n    throw new Error( 'iqrf.embed.frc.ParseResponses: Parameter frcCommand = ' + frcCommand + ' is out of range.' );\r\n\r\n  var frcData;\r\n  if ( extraResultResponse !== undefined )\r\n    frcData = sendResponse.frcData.concat( extraResultResponse );\r\n  else\r\n    frcData = sendResponse.frcData;\r\n\r\n  var result = [];\r\n\r\n  var frcData_length = frcData.length;\r\n  if ( frcCommand <= 0x7F )\r\n  {\r\n    // 2 bits FRC\r\n    for ( var index = 1; index <= 239; index++ )\r\n    {\r\n      var mask = 1 << ( index % 8 );\r\n      var valueIndex = Math.floor( index / 8 );\r\n\r\n      if ( ( valueIndex + 32 ) >= frcData_length )\r\n        break;\r\n\r\n      var frcValue = 0;\r\n      if ( ( frcData[valueIndex] & mask ) !== 0 )\r\n        frcValue = 0x01;\r\n\r\n      if ( ( frcData[valueIndex + 32] & mask ) !== 0 )\r\n        frcValue |= 0x02;\r\n\r\n      if ( frcValue !== 0 )\r\n        result[index] = frcValue;\r\n    }\r\n  }\r\n  else if ( frcCommand <= 0xDF )\r\n    // 1 byte FRC\r\n    for ( var byteIndex = 0; byteIndex < frcData_length; byteIndex++ )\r\n    {\r\n      var frcValue1B = frcData[byteIndex];\r\n      if ( frcValue1B !== 0 )\r\n        result[byteIndex] = frcValue1B;\r\n    }\r\n  else\r\n    // 2 bytes FRC\r\n    for ( var byte2index = 2; byte2index < frcData_length - 1; byte2index += 2 )\r\n    {\r\n      var frcValue2B = frcData[byte2index] + ( frcData[byte2index + 1] * 0x100 );\r\n      if ( frcValue2B !== 0 )\r\n        result[byte2index / 2] = frcValue2B;\r\n    }\r\n\r\n  return result;\r\n};\r\n\r\n//############################################################################################\r\n","notes":"Initial release","standardID":13,"name":"Embed: FRC"},{"version":0.00,"versionFlags":0,"driver":"// File_:   $RCSfile: FF_EmbedDpaExploration.js,v $\r\n// Version: $Revision: 1.18 $\r\n// Date:    $Date: 2018/07/09 15:13:45 $\r\n//############################################################################################\r\n\r\n/* Title: Embedded DPA exploration driver\r\nSee also: <https://www.iqrf.org/DpaTechGuide/>\r\n*/\r\n\r\n/*DriverDescription\r\n{ 'ID' : 0xFF,\r\n  'Type' : 'Standard',\r\n  'Internal' : false,\r\n  'Versions' : [\r\n    { 'Version' : 0, 'Notes' : [\r\n        '1st line',\r\n        '2nd line' ]\r\n    }\r\n  ] }\r\nDriverDescription*/\r\n\r\n\"use strict\";\r\n// Namespace: iqrf.embed.explore\r\nnamespace( 'iqrf.embed.explore' );\r\n\r\n/* Function: iqrf.embed.explore.Enumerate_Request\r\nEncodes DPA request to enumerate DPA peripherals.\r\n\r\nReturns:\r\n  string: DPA request string.  \r\n*/\r\niqrf.embed.explore.Enumerate_Request = function ()\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.PNUM_Enumeration, '3f' );\r\n};\r\n\r\n/* Function: iqrf.embed.explore.Enumerate_Response\r\nDecodes DPA response from enumerating DPA peripherals.\r\n\r\nParameters:\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  object: Object with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide/ for details):\r\n\r\n* dpaVer\r\n* perNr\r\n* embeddedPers\r\n* hwpid\r\n* hwpidVer\r\n* flags\r\n* userPer\r\n*/\r\niqrf.embed.explore.Enumerate_Response = function ( response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.PNUM_Enumeration, 'bf', -12 );\r\n  var result =\r\n    {\r\n      dpaVer: responseData[0] + ( responseData[1] * 0x100 ),\r\n      perNr: responseData[2],\r\n      embeddedPers: iqrf.BitmapToIndexes( responseData, 3, 6 ),\r\n      hwpid: responseData[7] + ( responseData[8] * 0x100 ),\r\n      hwpidVer: responseData[9] + ( responseData[10] * 0x100 ),\r\n      flags: responseData[11],\r\n      userPer: iqrf.BitmapToIndexes( responseData, 12, responseData.length - 1, 0x20 )\r\n    };\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.embed.explore.PeripheralInformation_Request\r\nEncodes DPA request to get information about a peripheral.\r\n\r\nParameters:\r\n  per - number: Peripheral to get information about.\r\n\r\nReturns:\r\n  string: DPA request string.  \r\n*/\r\niqrf.embed.explore.PeripheralInformation_Request = function ( per )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( iqrf.ToHexStringByte( per ), '3f' );\r\n};\r\n\r\n/* Function: iqrf.embed.explore.PeripheralInformation_Response\r\nDecodes DPA response from getting information about a peripheral.\r\n\r\nParameters:\r\n  per - number: Peripheral the information is about.\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  object: Object with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide/ for details):\r\n\r\n* perTe - number:\r\n* perT - number:\r\n* par1 - number:\r\n* par2 - number:\r\n*/\r\niqrf.embed.explore.PeripheralInformation_Response = function ( per, response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, iqrf.ToHexStringByte( per ), 'bf', 4 );\r\n  var result =\r\n    {\r\n      perTe: responseData[0],\r\n      perT: responseData[1],\r\n      par1: responseData[2],\r\n      par2: responseData[3]\r\n    };\r\n\r\n  return result;\r\n};\r\n\r\n/* Function: iqrf.embed.explore.MorePeripheralsInformation_Request\r\nEncodes DPA request to get information about more peripherals.\r\n\r\nParameters:\r\n  per - number: 1st peripheral to get information about.\r\n\r\nReturns:\r\n  string: DPA request string.  \r\n*/\r\niqrf.embed.explore.MorePeripheralsInformation_Request = function ( per )\r\n{\r\n  return new iqrf.DpaRawHdpMessage( 'ff', iqrf.ToHexStringByte( per ) );\r\n};\r\n\r\n/* Function: iqrf.embed.explore.MorePeripheralsInformation_Response\r\nDecodes DPA response from getting information about more peripherals.\r\n\r\nParameters:\r\n  per - number: 1st peripheral the information is about.\r\n  response - string: DPA response string.\r\n\r\nReturns:\r\n  array: Array of objects with the following fields (see DPA documentation https://www.iqrf.org/DpaTechGuide/ for details):\r\n\r\n* perTe - number:\r\n* perT - number:\r\n* par1 - number: \r\n* par2 - number: \r\n*/\r\niqrf.embed.explore.MorePeripheralsInformation_Response = function ( per, response )\r\n{\r\n  var responseData = iqrf.CheckResponsePnumPcmdDlen( response, 'ff', iqrf.ToHexStringByte( parseInt( per, 16 ) | 0x80 ) );\r\n\r\n  var result = [];\r\n  var responseData_length = responseData.length;\r\n  for ( var index = 0; index < responseData_length; index += 4 )\r\n    result[result.length] =\r\n      {\r\n        perTe: responseData[index + 0],\r\n        perT: responseData[index + 1],\r\n        par1: responseData[index + 2],\r\n        par2: responseData[index + 3]\r\n      };\r\n\r\n  return result;\r\n};\r\n\r\n//############################################################################################\r\n","notes":"1st line\n2nd line","standardID":255,"name":"Embed: DPA Exploration"}],"packageID":61,"hwpid":12289,"hwpidVer":2,"handlerUrl":"https://repository.iqrfalliance.org:443/download/handlers/3001_0002_Protronix-T+RH.hex","handlerHash":"55BD50E47D6FEE8082ED4A272A7965CEDCD868C69E38641E6E36F6CB093CA445","os":"08C2","dpa":"0303","notes":"[none]"}